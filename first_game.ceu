^["@/pico/pico.ceu"]

pico-state-set-size([810,610])
pico-state-set-title("First_Game")
pico-state-set-font("tiny.ttf", 10)

val LOWER-X = -40
val UPPER-X = 40
val LOWER-Y = -30
val UPPER-Y = 30

random-seed()

func random-number(lower, upper){
    val ramdom-value = ( (random-next() % ((upper - lower) + 1)) + lower );
    ramdom-value
}

func set-rect-in-ramdom-position(rect :Rect){

    set rect.pos.x = random-number(LOWER-X, UPPER-X)
    set rect.pos.y = random-number(LOWER-Y, UPPER-Y)
}

task Yoyo(rect:Rect){
    var width = rect.dim.w
    var hight = rect.dim.h

    watching :400:ms{
        loop {
            set rect.dim.w = (rect.dim.w+2)
            set rect.dim.h = (rect.dim.h+2)
            await(:16:ms)
        }
    }

    watching :400:ms {
        loop {
            set rect.dim.w = (rect.dim.w-2)
            set rect.dim.h = (rect.dim.h-2)
            await(:16:ms)
        }
    }    
}

spawn{
    var score = 0
    var score-text = "score:"
    var player :Rect = [[-10,5],[5,5]]
    var coin :Rect = [[-40,0],[5,5]]
    val yoyos = tasks(1)

    spawn {

        par{
            every :Pico.Draw{
                pico-state-set-color-draw([255, 255, 255, 255])
                pico-output-draw-rect(player)
                pico-output-draw-text([-15,25], score-text++to-string(score))
                pico-state-set-color-draw([255, 255, 0, 255])
                pico-output-draw-rect(coin)
                
            }
        } with{
            every :Pico.Frame{
                if ( pico-rect-vs-rect?(player, coin) ){
                set-rect-in-ramdom-position(coin)
                set score = score + 10
                spawn Yoyo(player) in yoyos
                }
            }
        }
    }

    loop{
            every :Pico.Key.Dn{
                ifs it.key{
                    :Key-Left  => if( (player.pos.x - 1) > (LOWER-X + (player.dim.w/2)) ) { set player.pos.x = player.pos.x - 1 }
                    :Key-Right => if( (player.pos.x + 1) < (UPPER-X - (player.dim.w/2)) ) { set player.pos.x = player.pos.x + 1 }
                    :Key-Down  => if( (player.pos.y - 1) > (LOWER-Y + (player.dim.h/2)) ) { set player.pos.y = player.pos.y - 1 }
                    :Key-Up    => if( (player.pos.y + 1) < (UPPER-Y - (player.dim.h/2)) ) { set player.pos.y = player.pos.y + 1 }
                }

            }
    }
}
pico-loop()