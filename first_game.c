
    #include <stdio.h>
    #include <stdlib.h>
    #include <stddef.h>
    #include <stdint.h>
    #include <string.h>
    #include <assert.h>
    #include <stdarg.h>
    #include <time.h>
    #include <math.h>
    
    #define CEU_DEBUG
    #define CEU 99
    #define CEU_MULTI -1
    
    #undef MAX
    #undef MIN
    #define MAX(a,b) ({ __typeof__ (a) _a = (a); __typeof__ (b) _b = (b); _a > _b ? _a : _b; })
    #define MIN(a,b) ({ __typeof__ (a) _a = (a); __typeof__ (b) _b = (b); _a < _b ? _a : _b; })

    #define COMMA ,
    #if CEU >= 2
    #define CEU2(x) x
    #else
    #define CEU2(x)
    #endif
    #if CEU >= 3
    #define CEU3(x) x
    #else
    #define CEU3(x)
    #endif
    #if CEU >= 4
    #define CEU4(x) x
    #else
    #define CEU4(x)
    #endif
    #if CEU >= 5
    #define CEU5(x) x
    #else
    #define CEU5(x)
    #endif
    
    #if CEU >= 3
    typedef enum CEU_ACTION {
        CEU_ACTION_INVALID = -1,    // default to force set
        CEU_ACTION_CALL,
        CEU_ACTION_RESUME,
        CEU_ACTION_ABORT,           // awake exe to finalize defers and release memory
    #if CEU >= 4
        //CEU_ACTION_TOGGLE,          // restore time to CEU_TIME_MIN after toggle
        CEU_ACTION_ERROR,           // awake task to catch error from nested task
    #endif
    } CEU_ACTION;
    #endif

    typedef enum CEU_VALUE {
        CEU_VALUE_BLOCK = -1,
        CEU_VALUE_NIL = 0,
        CEU_VALUE_ERROR,
        CEU_VALUE_TAG,
        CEU_VALUE_BOOL,
        CEU_VALUE_CHAR,
        CEU_VALUE_NUMBER,
        CEU_VALUE_POINTER,
        CEU_VALUE_DYNAMIC,    // all below are dynamic
        CEU_VALUE_CLO_FUNC,
        #if CEU >= 3
        CEU_VALUE_CLO_CORO,
        #endif
        #if CEU >= 4
        CEU_VALUE_CLO_TASK,
        #endif
        CEU_VALUE_TUPLE,
        CEU_VALUE_VECTOR,
        CEU_VALUE_DICT,
        #if CEU >= 3
        CEU_VALUE_EXE_CORO,
        #endif
        #if CEU >= 4
        CEU_VALUE_EXE_TASK,
        #endif
        #if CEU >= 5
        CEU_VALUE_TASKS,
        CEU_VALUE_TRACK,
        #endif
        CEU_VALUE_MAX
    } __attribute__ ((__packed__)) CEU_VALUE;
    _Static_assert(sizeof(CEU_VALUE) == 1, "bug found");

    #if CEU >= 3
    typedef enum CEU_EXE_STATUS {
        CEU_EXE_STATUS_YIELDED = 1,
        #if CEU >= 4
        CEU_EXE_STATUS_TOGGLED,
        #endif
        CEU_EXE_STATUS_RESUMED,
        CEU_EXE_STATUS_TERMINATED,
    } CEU_EXE_STATUS;
    #endif
    
    #if CEU >= 4
    struct CEU_Exe_Task;
    typedef union CEU_Dyn* CEU_Block;
    #endif
    #if CEU >= 5
    struct CEU_Tasks;
    #endif
    
    typedef struct CEU_Value {
        CEU_VALUE type;
        union {
            //void nil;
            CEU4(CEU_Block Block;)
            char* Error;            // NULL=value on stack, !NULL=value is this string
            unsigned int Tag;
            int Bool;
            char Char;
            double Number;
            void* Pointer;
            union CEU_Dyn* Dyn;    // Func/Task/Tuple/Dict/Coro/Tasks: allocates memory
        };
    } CEU_Value;

    #define _CEU_Dyn_                   \
        CEU_VALUE type;                 \
        uint8_t refs;                   \
        struct CEU_Tags_List* tags;
        
    #if 0
        struct {                        \
            void* block;   /* block/tasks */ \
            union CEU_Dyn* prev;        \
            union CEU_Dyn* next;        \
        } hld;
    #endif
        
    typedef struct CEU_Any {
        _CEU_Dyn_
    } CEU_Any;

    typedef struct CEU_Tuple {
        _CEU_Dyn_
        int its;                // number of items
        CEU_Value buf[0];       // beginning of CEU_Value[n]
    } CEU_Tuple;

    typedef struct CEU_Vector {
        _CEU_Dyn_
        CEU_VALUE unit;         // type of each element
        int max;                // size of buf
        int its;                // number of items
        char* buf;              // resizable Unknown[n]
    } CEU_Vector;
    
    typedef struct CEU_Dict {
        _CEU_Dyn_
        int max;                // size of buf
        CEU_Value (*buf)[0][2]; // resizable CEU_Value[n][2]
    } CEU_Dict;

    struct CEUX;
    typedef int (*CEU_Proto) (struct CEUX* X);

    #define _CEU_Clo_                   \
        _CEU_Dyn_                       \
        CEU_Proto proto;                \
        int args;                       \
        int locs;                       \
        struct {                        \
            int its;                    \
            CEU_Value* buf;             \
        } upvs;

    typedef struct CEU_Clo {
        _CEU_Clo_
    } CEU_Clo;
    
    #if CEU >= 4
    typedef struct CEU_Clo_Task {
        _CEU_Clo_                       \
        struct CEU_Exe_Task* up_tsk;    \
    } CEU_Clo_Task;
    #endif
    
    #if CEU >= 2
    typedef struct CEU_Throw {
        _CEU_Dyn_
        CEU_Value val;
        CEU_Value stk;
    } CEU_Throw;
    #endif
    
    #if CEU >= 3
    #define _CEU_Exe_                   \
        _CEU_Dyn_                       \
        CEU_EXE_STATUS status;          \
        CEU_Value clo;                  \
        /*struct CEU_Frame frame;*/     \
        int pc;                         \
        struct CEUX* X;
        
    typedef struct CEU_Exe {
        _CEU_Exe_
    } CEU_Exe;
    #endif
    
    #if CEU >= 4
    typedef struct CEU_Links {
        struct {
            union CEU_Dyn* dyn;
            CEU_Block* blk;
        } up;
        struct {
            union CEU_Dyn* prv;
            union CEU_Dyn* nxt;
        } sd;
        struct {
            union CEU_Dyn* fst;
            union CEU_Dyn* lst;
        } dn;
    } CEU_Links;
    #endif
    
    #if CEU >= 5
        #define CEU_LNKS(dyn) ((dyn)->Any.type==CEU_VALUE_TASKS ? &(dyn)->Tasks.lnks : &(dyn)->Exe_Task.lnks)
    #else
        #define CEU_LNKS(dyn) (&((CEU_Exe_Task*) dyn)->lnks)
    #endif

    #if CEU >= 4
    typedef struct CEU_Exe_Task {
        _CEU_Exe_
        uint32_t time;      // last sleep time, only awakes if CEU_TIME>time 
        CEU_Value pub;
        CEU_Links lnks;
    } CEU_Exe_Task;
    #endif
    
    #if CEU >= 5
    typedef struct CEU_Tasks {
        _CEU_Dyn_
        int max;
        CEU_Links lnks;
    } CEU_Tasks;
    typedef struct CEU_Track {
        _CEU_Dyn_
        CEU_Exe_Task* task;
    } CEU_Track;
    #endif

    typedef union CEU_Dyn {                                                                 
        struct CEU_Any      Any;
        struct CEU_Tuple    Tuple;
        struct CEU_Vector   Vector;
        struct CEU_Dict     Dict;
        struct CEU_Clo      Clo;
    #if CEU >= 2
        struct CEU_Throw    Throw;
    #endif
    #if CEU >= 4
        struct CEU_Clo_Task Clo_Task;
    #endif
    #if CEU >= 3
        struct CEU_Exe      Exe;
    #endif
    #if CEU >= 4
        struct CEU_Exe_Task Exe_Task;
    #endif
    #if CEU >= 5
        struct CEU_Tasks    Tasks;
        struct CEU_Track    Track;
    #endif
    } CEU_Dyn;        
    
    typedef struct CEU_Tags_Names {
        int tag;
        char* name;
        struct CEU_Tags_Names* next;
    } CEU_Tags_Names;
    
    typedef struct CEU_Tags_List {
        int tag;
        struct CEU_Tags_List* next;
    } CEU_Tags_List;
    
    #define CEU_STACK_MAX 256
    typedef struct CEU_Stack {
        int n;
        CEU_Value buf[CEU_STACK_MAX];
    } CEU_Stack;
    
    typedef struct CEUX {
        CEU_Stack* S;
        int base;   // index above args
        int args;   // number of args
    #if CEU >= 3
        CEU_ACTION action;
        union {
            struct CEU_Exe* exe;
    #if CEU >= 4
            struct CEU_Exe_Task* exe_task;
    #endif
        };
    #if CEU >= 4
        uint32_t now;
        struct CEUX* up;
    #endif
    #endif
    } CEUX;
    
    /*
     *  CLO
     *  args
     *  ----    <-- base
     *  upvs
     *  locs    <-- [b1,n1[ [b2,n2[ [...[
     *  block
     *  tmps
     *  block
     *  tmps
     */
    
    #define ceux_arg(X,i) (X->base - X->args + i)
    #define XX(v)  ({ assert(v<=0); X->S->n+v; })
    #define XX1(v) ({ assert(v<=0); X1->S->n+v; })
    #define XX2(v) ({ assert(v<=0); X2->S->n+v; })
    #define SS(v)  ({ assert(v<=0); S->n+v;    })
    int ceux_n_get (CEU_Stack* S);
    void ceux_n_set (CEU_Stack* S, int base);
    CEU_Value ceux_pop (CEU_Stack* S, int dec);
    int ceux_push (CEU_Stack* S, int inc, CEU_Value v);
    CEU_Value ceux_peek (CEU_Stack* S, int i);
    void ceux_repl (CEU_Stack* S, int i, CEU_Value v);
    void ceux_ins (CEU_Stack* S, int i, CEU_Value v);
    void ceux_rem (CEU_Stack* S, int i);
    void ceux_drop (CEU_Stack* S, int n);
    #if CEU >= 3
    int ceux_resume (CEUX* X1, int inp, int out, CEU_ACTION act CEU4(COMMA uint32_t now));
    #endif
    
    CEUX* CEU_GLOBAL_X = NULL;
    #if CEU >= 4
    uint32_t CEU_TIME = 0;
    CEU_Exe_Task CEU_GLOBAL_TASK = {
        CEU_VALUE_EXE_TASK, 1, NULL,
        CEU_EXE_STATUS_YIELDED, {}, 0, NULL,
        0, {}, { {NULL,NULL}, {NULL,NULL}, {NULL,NULL} }
    };
    #endif
    int CEU_BREAK = 0;
    
    int ceu_type_f (CEUX* X);
    int ceu_as_bool (CEU_Value v);
    CEU_Value ceu_dyn_to_val (CEU_Dyn* dyn);

    int ceu_tags_f (CEUX* X);
    int ceu_type_to_size (int type);

    void ceu_gc_inc_val (CEU_Value v);

    CEU_Value ceu_create_tuple   (int n);
    CEU_Value ceu_create_vector  (void);
    CEU_Value ceu_create_dict    (void);
    CEU_Value ceu_create_clo     (CEU_VALUE type, CEU_Proto proto, int args, int locs, int upvs);
    #if CEU >= 4
    CEU_Value ceu_create_exe_task (CEU_Value clo, CEU_Dyn* up_dyn, CEU_Block* up_blk);
    CEU_Value ceu_create_track   (CEU_Exe_Task* task);
    #endif

    void ceu_tuple_set (CEU_Tuple* tup, int i, CEU_Value v);

    CEU_Value ceu_vector_get (CEU_Vector* vec, int i);
    void ceu_vector_set (CEU_Vector* vec, int i, CEU_Value v);
    CEU_Value ceu_vector_from_c_string (const char* str);
    
    int ceu_dict_key_to_index (CEU_Dict* col, CEU_Value key, int* idx);
    CEU_Value ceu_dict_get (CEU_Dict* col, CEU_Value key);
    CEU_Value ceu_dict_set (CEU_Dict* col, CEU_Value key, CEU_Value val);
    CEU_Value ceu_col_check (CEU_Value col, CEU_Value idx);

    void ceu_print1 (CEU_Value v);
    CEU_Value _ceu_equals_equals_ (CEU_Value e1, CEU_Value e2);

    char* ceu_to_dash_string_dash_tag (int tag);
    #if CEU >= 3
    int ceu_isexe_dyn (CEU_Dyn* dyn);
    int ceu_isexe_val (CEU_Value val);
    void ceu_abort_exe (CEU_Exe* exe);
    #endif
    #if CEU >= 4
    #define ceu_abort_dyn(a) ceu_abort_exe((CEU_Exe*)a)
    #define ceu_bcast_dyn(a,b,c,d) ceu_bcast_task(a,b,c,(CEU_Exe_Task*)d)
    int ceu_bcast_task (CEUX* X1, CEU_ACTION act, uint32_t now, CEU_Exe_Task* tsk2);
    int ceu_bcast_tasks (CEUX* X1, CEU_ACTION act, uint32_t now, CEU_Dyn* dyn2);
    int ceu_istask_dyn (CEU_Dyn* dyn);
    int ceu_istask_val (CEU_Value val);
    void ceu_dyn_unlink (CEU_Dyn* dyn);
    #endif
    #if CEU >= 5
    #undef ceu_abort_dyn
    #define ceu_abort_dyn(a) (a->Any.type==CEU_VALUE_TASKS ? ceu_abort_tasks((CEU_Tasks*)a) : ceu_abort_exe((CEU_Exe*)a))
    #undef ceu_bcast_dyn
    #define ceu_bcast_dyn(a,b,c,d) (d->Any.type==CEU_VALUE_TASKS ? ceu_bcast_tasks(a,b,c,d) : ceu_bcast_task(a,b,c,(CEU_Exe_Task*)d))
    void ceu_abort_tasks (CEU_Tasks* tsks);
    #endif
    
#ifdef CEU_DEBUG
    struct {
        int alloc;
        int free;
    } CEU_GC = { 0, 0 };
    
    void ceu_dump_gc (void) {
        printf(">>> GC: %d\n", CEU_GC.alloc - CEU_GC.free);
        printf("    alloc = %d\n", CEU_GC.alloc);
        printf("    free  = %d\n", CEU_GC.free);
    }
    #if 0
    void ceu_dump_frame (CEU_Frame* frame) {
        printf(">>> FRAME: %p\n", frame);
        printf("    up_block = %p\n", frame->up_block);
        printf("    clo      = %p\n", frame->clo);
    #if CEU >= 4
        printf("    exe      = %p\n", frame->exe);
    #endif
    }
    #endif
    void ceu_dump_val (CEU_Value v) {
        puts(">>>>>>>>>>>");
        ceu_print1(v);
        puts(" <<<");
        if (v.type > CEU_VALUE_DYNAMIC) {
            printf("    dyn   = %p\n", v.Dyn);
            printf("    type  = %d\n", v.type);
            printf("    refs  = %d\n", v.Dyn->Any.refs);
            //printf("    next  = %p\n", v.Dyn->Any.hld.next);
            printf("    ----\n");
            switch (v.type) {
        #if CEU >= 4
                case CEU_VALUE_EXE_TASK:
                    printf("    status = %d\n", v.Dyn->Exe_Task.status);
                    printf("    pc     = %d\n", v.Dyn->Exe_Task.pc);
                    printf("    pub    = %d\n", v.Dyn->Exe_Task.pub.type);
                    break;
        #endif
        #if CEU >= 5
                case CEU_VALUE_TASKS:
                    //printf("    up_blk = %p\n", v.Dyn->Tasks.up_blk);
                    //printf("    dn_tsk = %p\n", v.Dyn->Tasks.dn_tsk);
                    break;
                case CEU_VALUE_TRACK:
                    printf("    task   = %p\n", v.Dyn->Track.task);
                    break;
        #endif
                default:
                    puts("TODO");
            }
        }
        puts("<<<<<<<<<<<");
    }
    void ceu_dump_dyn (CEU_Dyn* dyn) {
        ceu_dump_val(ceu_dyn_to_val(dyn));
    }
    #if 0
    void ceu_dump_block (CEU_Block* blk) {
        printf(">>> BLOCK: %p\n", blk);
        printf("    istop = %d\n", blk->istop);
        //printf("    up    = %p\n", blk->up.frame);
        CEU_Dyn* cur = blk->dn.dyns.first;
        while (cur != NULL) {
            ceu_dump_dyn(cur);
            CEU_Dyn* old = cur;
            //cur = old->Any.hld.next;
        }
    }
    #endif
#endif
    
    #define CEU_ERROR_IS(S) ((S)->n>0 && ceux_peek((S),(S)->n-1).type==CEU_VALUE_ERROR)
    #define CEU_ERROR_CHK_VAL(cmd,v,pre) ({     \
        if (v.type == CEU_VALUE_ERROR) {        \
            ceu_error_e(X->S,v);                \
            CEU_ERROR_CHK_STK(cmd,pre);         \
        };                                      \
        v;                                      \
    })
    #define CEU_ERROR_THR_S(cmd,msg,pre) {      \
        ceu_error_s(X->S, msg);                 \
        CEU_ERROR_CHK_STK(cmd,pre);             \
    }

    #if CEU <= 1
    #define CEU_ERROR_CHK_STK(cmd,pre) {                                            \
        if (CEU_ERROR_IS(X->S)) {                                                   \
            CEU_Value msg = ceux_peek(X->S, XX(-2));                                \
            assert(msg.type==CEU_VALUE_POINTER && msg.Pointer!=NULL);               \
            fprintf(stderr, " |  %s\n v  error : %s\n", pre, (char*) msg.Pointer);  \
            ceux_n_set(X->S, 0);                                                    \
            exit(0);                                                                \
        }                                                                           \
    }
    #else
    #define CEU_ERROR_CHK_STK(cmd,pre)      \
        if (ceu_error_chk_stk(X->S, pre)) { \
            cmd;                            \
        }
    int ceu_error_chk_stk (CEU_Stack* S, char* pre) {
        if (!CEU_ERROR_IS(S)) {
            return 0;
        } else {
            if (pre != NULL) {      // blocks check but do not add a message
                // [...,n,pay,err]
                CEU_Value n = ceux_peek(S, SS(-3));
                assert(n.type == CEU_VALUE_NUMBER);
                ceux_repl(S, SS(-3), (CEU_Value) { CEU_VALUE_NUMBER, {.Number=n.Number+1} });
                ceux_ins(S, SS(-3), (CEU_Value) { CEU_VALUE_POINTER, {.Pointer=pre} });
                // [...,pre,n+1,pay,err]
            }
            return 1;
        }
    }
    #endif

    int ceu_error_e (CEU_Stack* S, CEU_Value e) {
        assert(e.type==CEU_VALUE_ERROR && e.Error!=NULL);
        ceux_push(S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
        ceux_push(S, 1, (CEU_Value) { CEU_VALUE_POINTER, {.Pointer=e.Error} });
        ceux_push(S, 1, (CEU_Value) { CEU_VALUE_ERROR, {.Error=NULL} });
        return 3;
    }
    int ceu_error_s (CEU_Stack* S, char* s) {
        assert(s != NULL);
        ceux_push(S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
        ceux_push(S, 1, (CEU_Value) { CEU_VALUE_POINTER, {.Pointer=s} });
        ceux_push(S, 1, (CEU_Value) { CEU_VALUE_ERROR });
        return 3;
    }
    int ceu_error_v (CEU_Stack* S, CEU_Value v) {
        ceux_push(S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
        ceux_push(S, 1, v);
        ceux_push(S, 1, (CEU_Value) { CEU_VALUE_ERROR, {.Error=NULL} });
        return 3;
    }

    int ceu_error_f (CEUX* X) {
        assert(X->args == 1);
    #if CEU < 2
        CEU_Value arg = ceux_peek(X->S, ceux_arg(X,0));
        assert(arg.type == CEU_VALUE_TAG);
        return ceu_error_s(X->S, ceu_to_dash_string_dash_tag(arg.Tag));
    #else
        return ceu_error_v(X->S, ceux_peek(X->S, ceux_arg(X,0)));
    #endif
    }        
    
#ifdef CEU_DEBUG
    int CEU_DEBUG_TYPE[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    void ceu_debug_add (int type) {
    #ifdef CEU_DEBUG
        CEU_GC.alloc++;
    #endif
        CEU_DEBUG_TYPE[type]++;
        //printf(">>> type = %d | count = %d\n", type, CEU_DEBUG_TYPE[type]);
    }
    void ceu_debug_rem (int type) {
    #ifdef CEU_DEBUG
        CEU_GC.free++;
    #endif
        CEU_DEBUG_TYPE[type]--;
        //printf(">>> type = %d | count = %d\n", type, CEU_DEBUG_TYPE[type]);
    }
#else
    #define ceu_debug_add(x)
    #define ceu_debug_rem(x)
#endif

    void ceu_gc_free (CEU_Dyn* dyn);
    
    void ceu_gc_dec_dyn (CEU_Dyn* dyn) {
        assert(dyn->Any.refs > 0);
        dyn->Any.refs--;
        if (dyn->Any.refs == 0) {
            ceu_gc_free(dyn);
        }
    }
    void ceu_gc_dec_val (CEU_Value val) {
        if (val.type < CEU_VALUE_DYNAMIC)
            return;
        ceu_gc_dec_dyn(val.Dyn);
    }

    void ceu_gc_inc_dyn (CEU_Dyn* dyn) {
        assert(dyn->Any.refs < 255);
        dyn->Any.refs++;
    }
    void ceu_gc_inc_val (CEU_Value val) {
        if (val.type < CEU_VALUE_DYNAMIC)
            return;
        ceu_gc_inc_dyn(val.Dyn);
    }

    void ceu_gc_free (CEU_Dyn* dyn) {
        while (dyn->Any.tags != NULL) {
            CEU_Tags_List* tag = dyn->Any.tags;
            dyn->Any.tags = tag->next;
            free(tag);
        }
        switch (dyn->Any.type) {
            case CEU_VALUE_CLO_FUNC:
#if CEU >= 3
            case CEU_VALUE_CLO_CORO:
#endif
#if CEU >= 4
            case CEU_VALUE_CLO_TASK:
#endif
                for (int i=0; i<dyn->Clo.upvs.its; i++) {
                    ceu_gc_dec_val(dyn->Clo.upvs.buf[i]);
                }
                free(dyn->Clo.upvs.buf);
                break;
            case CEU_VALUE_TUPLE:       // buf w/ dyn
                for (int i=0; i<dyn->Tuple.its; i++) {
                    ceu_gc_dec_val(dyn->Tuple.buf[i]);
                }
                break;
            case CEU_VALUE_VECTOR:
                for (int i=0; i<dyn->Vector.its; i++) {
                    CEU_Value ret = ceu_vector_get(&dyn->Vector, i);
                    assert(ret.type != CEU_VALUE_ERROR);
                    ceu_gc_dec_val(ret);
                }
                free(dyn->Vector.buf);
                break;
            case CEU_VALUE_DICT:
                for (int i=0; i<dyn->Dict.max; i++) {
                    ceu_gc_dec_val((*dyn->Dict.buf)[i][0]);
                    ceu_gc_dec_val((*dyn->Dict.buf)[i][1]);
                }
                free(dyn->Dict.buf);
                break;
#if CEU >= 3
            case CEU_VALUE_EXE_CORO: {
#if CEU >= 4
            case CEU_VALUE_EXE_TASK:
#endif
                if (dyn->Exe.status != CEU_EXE_STATUS_TERMINATED) {
                    dyn->Any.refs++;            // currently 0->1: needs ->2 to prevent double gc
                    ceu_abort_exe((CEU_Exe*)dyn);
                    dyn->Any.refs--;
                }
                ceux_n_set(dyn->Exe.X->S, 0);
                ceu_gc_dec_val(dyn->Exe.clo);
#if CEU >= 4
                if (dyn->Any.type == CEU_VALUE_EXE_TASK) {
                    ceu_gc_dec_val(((CEU_Exe_Task*)dyn)->pub);
                    ceu_dyn_unlink(dyn);
                }
#endif
                free(dyn->Exe.X->S);
                free(dyn->Exe.X);
                break;
            }
#endif
#if CEU >= 5
            case CEU_VALUE_TASKS: {
                ceu_abort_tasks(&dyn->Tasks);
                ceu_dyn_unlink(dyn);
                break;
            }
            case CEU_VALUE_TRACK:
                break;
#endif
            default:
                assert(0 && "bug found");
        }
        ceu_debug_rem(dyn->Any.type);
        free(dyn);
    }        
    
                #define CEU_TAG_nil (0)
                CEU_Tags_Names ceu_tag_nil = { CEU_TAG_nil, ":nil", NULL };
                
                #define CEU_TAG_error (1)
                CEU_Tags_Names ceu_tag_error = { CEU_TAG_error, ":error", &ceu_tag_nil };
                
                #define CEU_TAG_tag (2)
                CEU_Tags_Names ceu_tag_tag = { CEU_TAG_tag, ":tag", &ceu_tag_error };
                
                #define CEU_TAG_bool (3)
                CEU_Tags_Names ceu_tag_bool = { CEU_TAG_bool, ":bool", &ceu_tag_tag };
                
                #define CEU_TAG_char (4)
                CEU_Tags_Names ceu_tag_char = { CEU_TAG_char, ":char", &ceu_tag_bool };
                
                #define CEU_TAG_number (5)
                CEU_Tags_Names ceu_tag_number = { CEU_TAG_number, ":number", &ceu_tag_char };
                
                #define CEU_TAG_pointer (6)
                CEU_Tags_Names ceu_tag_pointer = { CEU_TAG_pointer, ":pointer", &ceu_tag_number };
                
                #define CEU_TAG_dynamic (7)
                CEU_Tags_Names ceu_tag_dynamic = { CEU_TAG_dynamic, ":dynamic", &ceu_tag_pointer };
                
                #define CEU_TAG_func (8)
                CEU_Tags_Names ceu_tag_func = { CEU_TAG_func, ":func", &ceu_tag_dynamic };
                
                #define CEU_TAG_coro (9)
                CEU_Tags_Names ceu_tag_coro = { CEU_TAG_coro, ":coro", &ceu_tag_func };
                
                #define CEU_TAG_task (10)
                CEU_Tags_Names ceu_tag_task = { CEU_TAG_task, ":task", &ceu_tag_coro };
                
                #define CEU_TAG_tuple (11)
                CEU_Tags_Names ceu_tag_tuple = { CEU_TAG_tuple, ":tuple", &ceu_tag_task };
                
                #define CEU_TAG_vector (12)
                CEU_Tags_Names ceu_tag_vector = { CEU_TAG_vector, ":vector", &ceu_tag_tuple };
                
                #define CEU_TAG_dict (13)
                CEU_Tags_Names ceu_tag_dict = { CEU_TAG_dict, ":dict", &ceu_tag_vector };
                
                #define CEU_TAG_exe_coro (14)
                CEU_Tags_Names ceu_tag_exe_coro = { CEU_TAG_exe_coro, ":exe-coro", &ceu_tag_dict };
                
                #define CEU_TAG_exe_task (15)
                CEU_Tags_Names ceu_tag_exe_task = { CEU_TAG_exe_task, ":exe-task", &ceu_tag_exe_coro };
                
                #define CEU_TAG_tasks (16)
                CEU_Tags_Names ceu_tag_tasks = { CEU_TAG_tasks, ":tasks", &ceu_tag_exe_task };
                
                #define CEU_TAG_yielded (17)
                CEU_Tags_Names ceu_tag_yielded = { CEU_TAG_yielded, ":yielded", &ceu_tag_tasks };
                
                #define CEU_TAG_toggled (18)
                CEU_Tags_Names ceu_tag_toggled = { CEU_TAG_toggled, ":toggled", &ceu_tag_yielded };
                
                #define CEU_TAG_resumed (19)
                CEU_Tags_Names ceu_tag_resumed = { CEU_TAG_resumed, ":resumed", &ceu_tag_toggled };
                
                #define CEU_TAG_terminated (20)
                CEU_Tags_Names ceu_tag_terminated = { CEU_TAG_terminated, ":terminated", &ceu_tag_resumed };
                
                #define CEU_TAG_global (21)
                CEU_Tags_Names ceu_tag_global = { CEU_TAG_global, ":global", &ceu_tag_terminated };
                
                #define CEU_TAG_nested (22)
                CEU_Tags_Names ceu_tag_nested = { CEU_TAG_nested, ":nested", &ceu_tag_global };
                
                #define CEU_TAG_ceu (23)
                CEU_Tags_Names ceu_tag_ceu = { CEU_TAG_ceu, ":ceu", &ceu_tag_nested };
                
                #define CEU_TAG_pre (24)
                CEU_Tags_Names ceu_tag_pre = { CEU_TAG_pre, ":pre", &ceu_tag_ceu };
                
                #define CEU_TAG_rec (25)
                CEU_Tags_Names ceu_tag_rec = { CEU_TAG_rec, ":rec", &ceu_tag_pre };
                
                #define CEU_TAG_h (26)
                CEU_Tags_Names ceu_tag_h = { CEU_TAG_h, ":h", &ceu_tag_rec };
                
                #define CEU_TAG_min (27)
                CEU_Tags_Names ceu_tag_min = { CEU_TAG_min, ":min", &ceu_tag_h };
                
                #define CEU_TAG_s (28)
                CEU_Tags_Names ceu_tag_s = { CEU_TAG_s, ":s", &ceu_tag_min };
                
                #define CEU_TAG_ms (29)
                CEU_Tags_Names ceu_tag_ms = { CEU_TAG_ms, ":ms", &ceu_tag_s };
                
                #define CEU_TAG_Clock (30)
                CEU_Tags_Names ceu_tag_Clock = { CEU_TAG_Clock, ":Clock", &ceu_tag_ms };
                
                #define CEU_TAG_assert (31)
                CEU_Tags_Names ceu_tag_assert = { CEU_TAG_assert, ":assert", &ceu_tag_Clock };
                
                #define CEU_TAG_Iterator (32)
                CEU_Tags_Names ceu_tag_Iterator = { CEU_TAG_Iterator, ":Iterator", &ceu_tag_assert };
                
                #define CEU_TAG_i (33)
                CEU_Tags_Names ceu_tag_i = { CEU_TAG_i, ":i", &ceu_tag_Iterator };
                
                #define CEU_TAG_tp (34)
                CEU_Tags_Names ceu_tag_tp = { CEU_TAG_tp, ":tp", &ceu_tag_i };
                
                #define CEU_TAG_all (35)
                CEU_Tags_Names ceu_tag_all = { CEU_TAG_all, ":all", &ceu_tag_tp };
                
                #define CEU_TAG_idx (36)
                CEU_Tags_Names ceu_tag_idx = { CEU_TAG_idx, ":idx", &ceu_tag_all };
                
                #define CEU_TAG_val (37)
                CEU_Tags_Names ceu_tag_val = { CEU_TAG_val, ":val", &ceu_tag_idx };
                
                #define CEU_TAG_key (38)
                CEU_Tags_Names ceu_tag_key = { CEU_TAG_key, ":key", &ceu_tag_val };
                
                #define CEU_TAG_f (39)
                CEU_Tags_Names ceu_tag_f = { CEU_TAG_f, ":f", &ceu_tag_key };
                
                #define CEU_TAG_TODO (40)
                CEU_Tags_Names ceu_tag_TODO = { CEU_TAG_TODO, ":TODO", &ceu_tag_f };
                
                #define CEU_TAG_PICO (41)
                CEU_Tags_Names ceu_tag_PICO = { CEU_TAG_PICO, ":PICO", &ceu_tag_TODO };
                
                #define CEU_TAG_RGBA (42)
                CEU_Tags_Names ceu_tag_RGBA = { CEU_TAG_RGBA, ":RGBA", &ceu_tag_PICO };
                
                #define CEU_TAG_XY (43)
                CEU_Tags_Names ceu_tag_XY = { CEU_TAG_XY, ":XY", &ceu_tag_RGBA };
                
                #define CEU_TAG_WH (44)
                CEU_Tags_Names ceu_tag_WH = { CEU_TAG_WH, ":WH", &ceu_tag_XY };
                
                #define CEU_TAG_Rect (45)
                CEU_Tags_Names ceu_tag_Rect = { CEU_TAG_Rect, ":Rect", &ceu_tag_WH };
                
                #define CEU_TAG_Pico (46)
                CEU_Tags_Names ceu_tag_Pico = { CEU_TAG_Pico, ":Pico", &ceu_tag_Rect };
                
                    #define CEU_TAG_Pico_Any ((1 << 8) | 46)
                    CEU_Tags_Names ceu_tag_Pico_Any = { CEU_TAG_Pico_Any, ":Pico.Any", &ceu_tag_Pico };
                    
                    #define CEU_TAG_Pico_Quit ((2 << 8) | 46)
                    CEU_Tags_Names ceu_tag_Pico_Quit = { CEU_TAG_Pico_Quit, ":Pico.Quit", &ceu_tag_Pico_Any };
                    
                    #define CEU_TAG_Pico_Frame ((3 << 8) | 46)
                    CEU_Tags_Names ceu_tag_Pico_Frame = { CEU_TAG_Pico_Frame, ":Pico.Frame", &ceu_tag_Pico_Quit };
                    
                    #define CEU_TAG_Pico_Draw ((4 << 8) | 46)
                    CEU_Tags_Names ceu_tag_Pico_Draw = { CEU_TAG_Pico_Draw, ":Pico.Draw", &ceu_tag_Pico_Frame };
                    
                    #define CEU_TAG_Pico_Key ((5 << 8) | 46)
                    CEU_Tags_Names ceu_tag_Pico_Key = { CEU_TAG_Pico_Key, ":Pico.Key", &ceu_tag_Pico_Draw };
                    
                        #define CEU_TAG_Pico_Key_Dn ((1 << 16) | (5 << 8) | 46)
                        CEU_Tags_Names ceu_tag_Pico_Key_Dn = { CEU_TAG_Pico_Key_Dn, ":Pico.Key.Dn", &ceu_tag_Pico_Key };
                        
                        #define CEU_TAG_Pico_Key_Up ((2 << 16) | (5 << 8) | 46)
                        CEU_Tags_Names ceu_tag_Pico_Key_Up = { CEU_TAG_Pico_Key_Up, ":Pico.Key.Up", &ceu_tag_Pico_Key_Dn };
                        
                    #define CEU_TAG_Pico_Mouse ((6 << 8) | 46)
                    CEU_Tags_Names ceu_tag_Pico_Mouse = { CEU_TAG_Pico_Mouse, ":Pico.Mouse", &ceu_tag_Pico_Key_Up };
                    
                        #define CEU_TAG_Pico_Mouse_Motion ((1 << 16) | (6 << 8) | 46)
                        CEU_Tags_Names ceu_tag_Pico_Mouse_Motion = { CEU_TAG_Pico_Mouse_Motion, ":Pico.Mouse.Motion", &ceu_tag_Pico_Mouse };
                        
                        #define CEU_TAG_Pico_Mouse_Button ((2 << 16) | (6 << 8) | 46)
                        CEU_Tags_Names ceu_tag_Pico_Mouse_Button = { CEU_TAG_Pico_Mouse_Button, ":Pico.Mouse.Button", &ceu_tag_Pico_Mouse_Motion };
                        
                            #define CEU_TAG_Pico_Mouse_Button_Dn ((1 << 24) | (2 << 16) | (6 << 8) | 46)
                            CEU_Tags_Names ceu_tag_Pico_Mouse_Button_Dn = { CEU_TAG_Pico_Mouse_Button_Dn, ":Pico.Mouse.Button.Dn", &ceu_tag_Pico_Mouse_Button };
                            
                            #define CEU_TAG_Pico_Mouse_Button_Up ((2 << 24) | (2 << 16) | (6 << 8) | 46)
                            CEU_Tags_Names ceu_tag_Pico_Mouse_Button_Up = { CEU_TAG_Pico_Mouse_Button_Up, ":Pico.Mouse.Button.Up", &ceu_tag_Pico_Mouse_Button_Dn };
                            
                #define CEU_TAG_HAnchor_Left (Left)
                CEU_Tags_Names ceu_tag_HAnchor_Left = { CEU_TAG_HAnchor_Left, ":HAnchor-Left", &ceu_tag_Pico_Mouse_Button_Up };
                
                #define CEU_TAG_HAnchor_Center ((Left) + 1)
                CEU_Tags_Names ceu_tag_HAnchor_Center = { CEU_TAG_HAnchor_Center, ":HAnchor-Center", &ceu_tag_HAnchor_Left };
                
                #define CEU_TAG_HAnchor_Right ((Left) + 2)
                CEU_Tags_Names ceu_tag_HAnchor_Right = { CEU_TAG_HAnchor_Right, ":HAnchor-Right", &ceu_tag_HAnchor_Center };
                
                #define CEU_TAG_VAnchor_Bottom (Bottom)
                CEU_Tags_Names ceu_tag_VAnchor_Bottom = { CEU_TAG_VAnchor_Bottom, ":VAnchor-Bottom", &ceu_tag_HAnchor_Right };
                
                #define CEU_TAG_VAnchor_Middle ((Bottom) + 1)
                CEU_Tags_Names ceu_tag_VAnchor_Middle = { CEU_TAG_VAnchor_Middle, ":VAnchor-Middle", &ceu_tag_VAnchor_Bottom };
                
                #define CEU_TAG_VAnchor_Top ((Bottom) + 2)
                CEU_Tags_Names ceu_tag_VAnchor_Top = { CEU_TAG_VAnchor_Top, ":VAnchor-Top", &ceu_tag_VAnchor_Middle };
                
                #define CEU_TAG_Mouse_Button_Left (SDL_BUTTON_LEFT)
                CEU_Tags_Names ceu_tag_Mouse_Button_Left = { CEU_TAG_Mouse_Button_Left, ":Mouse-Button-Left", &ceu_tag_VAnchor_Top };
                
                #define CEU_TAG_Mouse_Button_Middle ((SDL_BUTTON_LEFT) + 1)
                CEU_Tags_Names ceu_tag_Mouse_Button_Middle = { CEU_TAG_Mouse_Button_Middle, ":Mouse-Button-Middle", &ceu_tag_Mouse_Button_Left };
                
                #define CEU_TAG_Mouse_Button_Right ((SDL_BUTTON_LEFT) + 2)
                CEU_Tags_Names ceu_tag_Mouse_Button_Right = { CEU_TAG_Mouse_Button_Right, ":Mouse-Button-Right", &ceu_tag_Mouse_Button_Middle };
                
                #define CEU_TAG_Key_A (SDLK_a)
                CEU_Tags_Names ceu_tag_Key_A = { CEU_TAG_Key_A, ":Key-A", &ceu_tag_Mouse_Button_Right };
                
                #define CEU_TAG_Key_B ((SDLK_a) + 1)
                CEU_Tags_Names ceu_tag_Key_B = { CEU_TAG_Key_B, ":Key-B", &ceu_tag_Key_A };
                
                #define CEU_TAG_Key_C ((SDLK_a) + 2)
                CEU_Tags_Names ceu_tag_Key_C = { CEU_TAG_Key_C, ":Key-C", &ceu_tag_Key_B };
                
                #define CEU_TAG_Key_D ((SDLK_a) + 3)
                CEU_Tags_Names ceu_tag_Key_D = { CEU_TAG_Key_D, ":Key-D", &ceu_tag_Key_C };
                
                #define CEU_TAG_Key_E ((SDLK_a) + 4)
                CEU_Tags_Names ceu_tag_Key_E = { CEU_TAG_Key_E, ":Key-E", &ceu_tag_Key_D };
                
                #define CEU_TAG_Key_F ((SDLK_a) + 5)
                CEU_Tags_Names ceu_tag_Key_F = { CEU_TAG_Key_F, ":Key-F", &ceu_tag_Key_E };
                
                #define CEU_TAG_Key_G ((SDLK_a) + 6)
                CEU_Tags_Names ceu_tag_Key_G = { CEU_TAG_Key_G, ":Key-G", &ceu_tag_Key_F };
                
                #define CEU_TAG_Key_H ((SDLK_a) + 7)
                CEU_Tags_Names ceu_tag_Key_H = { CEU_TAG_Key_H, ":Key-H", &ceu_tag_Key_G };
                
                #define CEU_TAG_Key_I ((SDLK_a) + 8)
                CEU_Tags_Names ceu_tag_Key_I = { CEU_TAG_Key_I, ":Key-I", &ceu_tag_Key_H };
                
                #define CEU_TAG_Key_J ((SDLK_a) + 9)
                CEU_Tags_Names ceu_tag_Key_J = { CEU_TAG_Key_J, ":Key-J", &ceu_tag_Key_I };
                
                #define CEU_TAG_Key_K ((SDLK_a) + 10)
                CEU_Tags_Names ceu_tag_Key_K = { CEU_TAG_Key_K, ":Key-K", &ceu_tag_Key_J };
                
                #define CEU_TAG_Key_L ((SDLK_a) + 11)
                CEU_Tags_Names ceu_tag_Key_L = { CEU_TAG_Key_L, ":Key-L", &ceu_tag_Key_K };
                
                #define CEU_TAG_Key_M ((SDLK_a) + 12)
                CEU_Tags_Names ceu_tag_Key_M = { CEU_TAG_Key_M, ":Key-M", &ceu_tag_Key_L };
                
                #define CEU_TAG_Key_N ((SDLK_a) + 13)
                CEU_Tags_Names ceu_tag_Key_N = { CEU_TAG_Key_N, ":Key-N", &ceu_tag_Key_M };
                
                #define CEU_TAG_Key_O ((SDLK_a) + 14)
                CEU_Tags_Names ceu_tag_Key_O = { CEU_TAG_Key_O, ":Key-O", &ceu_tag_Key_N };
                
                #define CEU_TAG_Key_P ((SDLK_a) + 15)
                CEU_Tags_Names ceu_tag_Key_P = { CEU_TAG_Key_P, ":Key-P", &ceu_tag_Key_O };
                
                #define CEU_TAG_Key_Q ((SDLK_a) + 16)
                CEU_Tags_Names ceu_tag_Key_Q = { CEU_TAG_Key_Q, ":Key-Q", &ceu_tag_Key_P };
                
                #define CEU_TAG_Key_R ((SDLK_a) + 17)
                CEU_Tags_Names ceu_tag_Key_R = { CEU_TAG_Key_R, ":Key-R", &ceu_tag_Key_Q };
                
                #define CEU_TAG_Key_S ((SDLK_a) + 18)
                CEU_Tags_Names ceu_tag_Key_S = { CEU_TAG_Key_S, ":Key-S", &ceu_tag_Key_R };
                
                #define CEU_TAG_Key_T ((SDLK_a) + 19)
                CEU_Tags_Names ceu_tag_Key_T = { CEU_TAG_Key_T, ":Key-T", &ceu_tag_Key_S };
                
                #define CEU_TAG_Key_U ((SDLK_a) + 20)
                CEU_Tags_Names ceu_tag_Key_U = { CEU_TAG_Key_U, ":Key-U", &ceu_tag_Key_T };
                
                #define CEU_TAG_Key_V ((SDLK_a) + 21)
                CEU_Tags_Names ceu_tag_Key_V = { CEU_TAG_Key_V, ":Key-V", &ceu_tag_Key_U };
                
                #define CEU_TAG_Key_W ((SDLK_a) + 22)
                CEU_Tags_Names ceu_tag_Key_W = { CEU_TAG_Key_W, ":Key-W", &ceu_tag_Key_V };
                
                #define CEU_TAG_Key_X ((SDLK_a) + 23)
                CEU_Tags_Names ceu_tag_Key_X = { CEU_TAG_Key_X, ":Key-X", &ceu_tag_Key_W };
                
                #define CEU_TAG_Key_Y ((SDLK_a) + 24)
                CEU_Tags_Names ceu_tag_Key_Y = { CEU_TAG_Key_Y, ":Key-Y", &ceu_tag_Key_X };
                
                #define CEU_TAG_Key_Z ((SDLK_a) + 25)
                CEU_Tags_Names ceu_tag_Key_Z = { CEU_TAG_Key_Z, ":Key-Z", &ceu_tag_Key_Y };
                
                #define CEU_TAG_Key_Right (SDLK_RIGHT)
                CEU_Tags_Names ceu_tag_Key_Right = { CEU_TAG_Key_Right, ":Key-Right", &ceu_tag_Key_Z };
                
                #define CEU_TAG_Key_Left ((SDLK_RIGHT) + 1)
                CEU_Tags_Names ceu_tag_Key_Left = { CEU_TAG_Key_Left, ":Key-Left", &ceu_tag_Key_Right };
                
                #define CEU_TAG_Key_Down ((SDLK_RIGHT) + 2)
                CEU_Tags_Names ceu_tag_Key_Down = { CEU_TAG_Key_Down, ":Key-Down", &ceu_tag_Key_Left };
                
                #define CEU_TAG_Key_Up ((SDLK_RIGHT) + 3)
                CEU_Tags_Names ceu_tag_Key_Up = { CEU_TAG_Key_Up, ":Key-Up", &ceu_tag_Key_Down };
                
                #define CEU_TAG_Key_Shift_Right (SDLK_RSHIFT)
                CEU_Tags_Names ceu_tag_Key_Shift_Right = { CEU_TAG_Key_Shift_Right, ":Key-Shift-Right", &ceu_tag_Key_Up };
                
                #define CEU_TAG_Key_Shift_Left (SDLK_LSHIFT)
                CEU_Tags_Names ceu_tag_Key_Shift_Left = { CEU_TAG_Key_Shift_Left, ":Key-Shift-Left", &ceu_tag_Key_Shift_Right };
                
                #define CEU_TAG_Key_Escape (SDLK_ESCAPE)
                CEU_Tags_Names ceu_tag_Key_Escape = { CEU_TAG_Key_Escape, ":Key-Escape", &ceu_tag_Key_Shift_Left };
                
                #define CEU_TAG_x (47)
                CEU_Tags_Names ceu_tag_x = { CEU_TAG_x, ":x", &ceu_tag_Key_Escape };
                
                #define CEU_TAG_y (48)
                CEU_Tags_Names ceu_tag_y = { CEU_TAG_y, ":y", &ceu_tag_x };
                
                #define CEU_TAG_pos (49)
                CEU_Tags_Names ceu_tag_pos = { CEU_TAG_pos, ":pos", &ceu_tag_y };
                
                #define CEU_TAG_dim (50)
                CEU_Tags_Names ceu_tag_dim = { CEU_TAG_dim, ":dim", &ceu_tag_pos };
                
                #define CEU_TAG_w (51)
                CEU_Tags_Names ceu_tag_w = { CEU_TAG_w, ":w", &ceu_tag_dim };
                
                #define CEU_TAG_mpf (52)
                CEU_Tags_Names ceu_tag_mpf = { CEU_TAG_mpf, ":mpf", &ceu_tag_w };
                
                #define CEU_TAG_r (53)
                CEU_Tags_Names ceu_tag_r = { CEU_TAG_r, ":r", &ceu_tag_mpf };
                
                #define CEU_TAG_g (54)
                CEU_Tags_Names ceu_tag_g = { CEU_TAG_g, ":g", &ceu_tag_r };
                
                #define CEU_TAG_b (55)
                CEU_Tags_Names ceu_tag_b = { CEU_TAG_b, ":b", &ceu_tag_g };
                
                #define CEU_TAG_a (56)
                CEU_Tags_Names ceu_tag_a = { CEU_TAG_a, ":a", &ceu_tag_b };
                
                #define CEU_TAG_quit (57)
                CEU_Tags_Names ceu_tag_quit = { CEU_TAG_quit, ":quit", &ceu_tag_a };
                
                CEU_Tags_Names* CEU_TAGS = &ceu_tag_quit;
            
    void ceux_dump (CEU_Stack* S, int n) {
        printf(">>> DUMP | n=%d | S=%p\n", S->n, S);
        for (int i=n; i<S->n; i++) {
            printf(">>> [%d]: [%d] ", i, ceux_peek(S,i).type);
            ceu_print1(ceux_peek(S,i));
            puts("");
        }
    }
    int ceux_n_get (CEU_Stack* S) {
        return S->n;
    }
    int ceux_push (CEU_Stack* S, int inc, CEU_Value v) {
        assert(S->n<CEU_STACK_MAX && "TODO: stack error");
        if (inc) {
            ceu_gc_inc_val(v);
        }
        S->buf[S->n++] = v;
        return S->n-1;
    }
    CEU_Value ceux_pop (CEU_Stack* S, int dec) {
        assert(S->n>0 && "TODO: stack error");
        CEU_Value v = S->buf[--S->n];
        if (dec) {
            ceu_gc_dec_val(v);
        }
        return v;
    }
    void ceux_pop_n (CEU_Stack* S, int n) {
        for (int i=0; i<n; i++) {
            ceux_pop(S, 1);
        }
    }
    CEU_Value ceux_peek (CEU_Stack* S, int i) {
        assert(i>=0 && i<S->n && "TODO: stack error");
        return S->buf[i];
    }
    void ceux_drop (CEU_Stack* S, int n) {
        assert(n<=S->n && "BUG: index out of range");
        for (int i=0; i<n; i++) {
            ceu_gc_dec_val(S->buf[--S->n]);
        }
    }
    void ceux_n_set (CEU_Stack* S, int n) {
        assert(n>=0 && n<=S->n && "TODO: stack error");
        for (int i=S->n; i>n; i--) {
            ceu_gc_dec_val(S->buf[--S->n]);
        }
    }
    void ceux_repl (CEU_Stack* S, int i, CEU_Value v) {
        assert(i>=0 && i<S->n && "TODO: stack error");
        ceu_gc_inc_val(v);
        ceu_gc_dec_val(S->buf[i]);
        S->buf[i] = v;
    }
    void ceux_dup (CEU_Stack* S, int i) {
        ceux_push(S, 1, ceux_peek(S,i));
    }
    void ceux_dup_n (CEU_Stack* S, int i, int n) {
        for (int x=i; x<i+n; x++) {
            ceux_dup(S, x);
        }
    }
    void ceux_copy (CEU_Stack* S, int i, int j) {
        assert(i>=0 && i<S->n && "TODO: stack error");
        assert(j>=0 && j<S->n && "TODO: stack error");
        assert(i!=j && "TODO: invalid move");
        ceu_gc_dec_val(S->buf[i]);
        S->buf[i] = S->buf[j];
        ceu_gc_inc_val(S->buf[i]);
    }
    void ceux_move (CEU_Stack* S, int i, int j) {
        assert(i>=0 && i<S->n && "TODO: stack error");
        assert(j>=0 && j<S->n && "TODO: stack error");
        if (i == j) {
            // nothing to change
        } else {
            ceu_gc_dec_val(S->buf[i]);
            S->buf[i] = S->buf[j];
            S->buf[j] = (CEU_Value) { CEU_VALUE_NIL };
        }
    }

    void ceux_ins (CEU_Stack* S, int i, CEU_Value v) {
        // [...,x,...]
        //      ^ i
        assert(i>=0 && i<=S->n && "TODO: stack error");
        for (int j=S->n; j>i; j--) {
            S->buf[j] = S->buf[j-1];
        }
        ceu_gc_inc_val(v);
        S->buf[i] = v;
        S->n++;
        // [...,nil,x,...]
        //       ^ i
    }
    
    void ceux_rem (CEU_Stack* S, int i) {
        // [pre,x,pos]
        //      ^ i
        assert(i>=0 && i<S->n && "TODO: stack error");
        ceu_gc_dec_val(S->buf[i]);
        for (int j=i; j<S->n-1; j++) {
            S->buf[j] = S->buf[j+1];
        }
        S->n--;
        // [pre,pos]
    }
    
    // ceux_block_*
    //  - needs to clear locals on enter and leave
    //  - enter: initialize all vars to nil (prevents garbage)
    //  - leave: gc locals
    
    void ceux_block_enter (CEU_Stack* S, int base, int n CEU4(COMMA CEU_Exe* exe)) {
        // clear locals
        // TODO: use memset=0
        for (int i=0; i<n; i++) {
            ceux_repl(S, base+i, (CEU_Value) { CEU_VALUE_NIL });
        }
    #if CEU >= 4
        ceux_push(S, 1, (CEU_Value) { CEU_VALUE_BLOCK, {.Block=NULL} });
    #else
        ceux_push(S, 1, (CEU_Value) { CEU_VALUE_BLOCK });
    #endif
    }
    
    void ceux_block_leave (CEU_Stack* S, int base, int n, int out) {
        int I = -1;
        for (int i=S->n-1; i>=0; i--) {
            CEU_Value blk = ceux_peek(S,i);
            if (blk.type == CEU_VALUE_BLOCK) {
    #if CEU >= 4
                if (blk.Block != NULL) {
                    CEU_LNKS(blk.Block)->up.blk = NULL; // also on ceu_task_unlink (if unlinked before leave)
                }

                {
                    CEU_Block cur = blk.Block;
                    while (cur != NULL) {
                        int term = (CEU5(cur->Any.type==CEU_VALUE_EXE_TASK &&) cur->Exe_Task.status==CEU_EXE_STATUS_TERMINATED);
                        ceu_abort_dyn(cur);
                        CEU_Dyn* nxt = CEU_LNKS(cur)->sd.nxt;
                        if (!term) {
                            ceu_gc_dec_dyn(cur); // TODO: could affect nxt?
                        }
                        cur = nxt;
                    }
                }
    #endif
                I = i;
                break;
            }
        }
        assert(I >= 0);
        
        // clear locals after clear block
        // TODO: use memset=0
        for (int i=n-1; i>=0; i--) {
            ceux_repl(S, base+i, (CEU_Value) { CEU_VALUE_NIL });
        }

    #if CEU >= 2
        // in case of error, out must be readjusted to the error stack:
        // [BLOCK,...,n,pay,err]
        //  - ... - error messages
        //  - n   - number of error messages
        //  - pay - error payload
        //  - err - error value
        if (CEU_ERROR_IS(S)) {
            CEU_Value n = ceux_peek(S,SS(-3));
            assert(n.type == CEU_VALUE_NUMBER);
            out = n.Number + 1 + 1 + 1;
        }
    #endif

        for (int i=0; i<out; i++) {
            ceux_move(S, I+i, SS(-out+i));
        }
        ceux_n_set(S, I+out);
    }
    
    int ceux_call_pre (CEU_Stack* S, CEU_Clo* clo, int* inp) {
        // fill missing args with nils
        {
            int N = clo->args - *inp;
            for (int i=0; i<N; i++) {
                ceux_push(S, 1, (CEU_Value) { CEU_VALUE_NIL });
                (*inp)++;
            }
        }
        
        int base = S->n;

        // [clo,args,?]
        //           ^ base

        // place upvs+locs
        {
            for (int i=0; i<clo->upvs.its; i++) {
                ceux_push(S, 1, clo->upvs.buf[i]);
            }
            for (int i=0; i<clo->locs; i++) {
                ceux_push(S, 1, (CEU_Value) { CEU_VALUE_NIL });
            }
        }
        // [clo,args,upvs,locs]
        //           ^ base

        return base;
    }
    
    int ceux_call_pos (CEU_Stack* S, int ret, int* out) {
        // in case of error, out must be readjusted to the error stack:
        // [clo,args,upvs,locs,...,n,pay,err]
        //  - ... - error messages
        //  - n   - number of error messages
        //  - pay - error payload
        //  - err - error value
        if (ret>0 && CEU_ERROR_IS(S)) {
            CEU_Value n = ceux_peek(S,SS(-3));
            assert(n.type == CEU_VALUE_NUMBER);
            *out = n.Number + 1 + 1 + 1;
            return 1;
        }
         
        if (*out == CEU_MULTI) {     // any rets is ok
            *out = ret;
        } else if (ret < *out) {     // less rets than requested
           // fill rets up to outs
            for (int i=0; i<*out-ret; i++) {
                ceux_push(S, 1, (CEU_Value) { CEU_VALUE_NIL });
            }
        } else if (ret > *out) {     // more rets than requested
            ceux_pop_n(S, ret-*out);
        } else { // ret == out      // exact rets requested
            // ok
        }
        return 0;
    }
    
    int ceux_call (CEUX* X1, int inp, int out) {
        // [clo,inps]
        CEU_Value clo = ceux_peek(X1->S, XX1(-inp-1));
        if (clo.type != CEU_VALUE_CLO_FUNC) {
            return ceu_error_s(X1->S, "call error : expected function");
        }

        int base = ceux_call_pre(X1->S, &clo.Dyn->Clo, &inp);

        // [clo,args,upvs,locs]
        //           ^ base

        CEUX X2 = { X1->S, base, inp CEU3(COMMA CEU_ACTION_CALL COMMA {.exe=X1->exe}) CEU4(COMMA X1->now COMMA X1) };
        int ret = clo.Dyn->Clo.proto(&X2);
        
        // [clo,args,upvs,locs,rets]
        //           ^ base
        
        ceux_call_pos(X1->S, ret, &out);        
        
        // [clo,args,upvs,locs,out]
        //           ^ base
        
        // move rets to begin, replacing [clo,args,upvs,locs]
        {
            for (int i=0; i<out; i++) {
                ceux_move(X1->S, base-inp-1+i, X1->S->n-out+i);
            }

            // [outs,x,x,x,x]
            //           ^ base
            ceux_n_set(X1->S, base-inp-1+out);
        }
        // [outs]
        //      ^ base
        
        return out;
    }
    
#if CEU >= 3
    int ceux_resume (CEUX* X1, int inp, int out, CEU_ACTION act CEU4(COMMA uint32_t now)) {
        // X1: [exe,inps]
        //assert((inp<=1 || CEU_ERROR_IS(X1->S)) && "TODO: varargs resume");

        CEU_Value exe = ceux_peek(X1->S, XX1(-inp-1));
        if (!(ceu_isexe_val(exe) && (exe.Dyn->Exe.status==CEU_EXE_STATUS_YIELDED || act==CEU_ACTION_ABORT))) {
            return ceu_error_s(X1->S, "resume error : expected yielded coro");
        }
        assert(exe.Dyn->Exe.clo.type==CEU_VALUE_CLO_CORO CEU4(|| exe.Dyn->Exe_Task.clo.type==CEU_VALUE_CLO_TASK));
        CEU_Clo* clo = &exe.Dyn->Exe.clo.Dyn->Clo;
        
        // X1: [exe,inps]
        // X2: [...]
        CEUX* X2 = exe.Dyn->Exe.X;
        
    #if CEU >= 4
        X2->up = X1;
    #endif
        
        {
            int n = XX1(-inp);
            for (int i=n; i<n+inp; i++) {
                ceux_push(X2->S, 1, ceux_peek(X1->S,i));
            }
        }
        
        ceu_gc_inc_val(exe);
        ceux_n_set(X1->S, XX1(-inp-1));
        // X1: []
        // X2: [...,inps]
        
        // first resume: place upvs+locs
        if (exe.Dyn->Exe.pc == 0) {
            X2->base = ceux_call_pre(X2->S, clo, &inp);
            X2->args = inp;
            // X2: [args,upvs,locs]
            //           ^ base
        } else {
            //X2->base = <already set>
            // X2: [args,upvs,locs,...,inps]
            //           ^ base
        }
        X2->action = act;
    #if CEU >= 4
        X2->now = now;
    #endif

        int ret = clo->proto(X2);
        
        // X2: [args,upvs,locs,...,rets]
        
        int err = ceux_call_pos(X2->S, ret, &out);        
        
        // X1: []
        // X2: [args,upvs,locs,...,outs]

        for (int i=0; i<out; i++) {
            ceux_push(X1->S, 1, ceux_peek(X2->S,XX2(-out)+i));                               
        }
        if (err) {
            ceux_n_set(X2->S, 0);
        } else {
            ceux_n_set(X2->S, XX2(-out));
        }
        
        // X1: [outs]
        // X2: []
        
        ceu_gc_dec_val(exe);
        return out;
    }
#endif

#if CEU >= 4
    CEU_Block* ceu_up_blk (CEU_Stack* S) {
        for (int i = S->n-1; i>=0; i--) {
            CEU_Value v = ceux_peek(S, i);
            if (v.type == CEU_VALUE_BLOCK) {
                return &S->buf[i].Block;
            }
        }
        return NULL; //assert(0 && "bug found: no block found");
    }

    CEU_Exe_Task* ceu_up_tsk (CEUX* X) {
        if (X->exe!=NULL && X->exe->type==CEU_VALUE_EXE_TASK) {
            return (CEU_Exe_Task*) X->exe;
        } else if (X->up == NULL) {
            return &CEU_GLOBAL_TASK;
        } else {
            return ceu_up_tsk(X->up);
        }
    }

    int ceux_spawn (CEUX* X1, int inp, uint8_t now) {
        // X1: [tsks,clo,inps]

        #if CEU >= 5
        CEU_Value up_tsks = ceux_peek(X1->S, XX1(-inp-2));
        if (up_tsks.type!=CEU_VALUE_NIL && up_tsks.type!=CEU_VALUE_TASKS) {
            return ceu_error_s(X1->S, "spawn error : invalid pool");
        }
        CEU_Tasks* xup_tsks = (up_tsks.type == CEU_VALUE_NIL) ? NULL : &up_tsks.Dyn->Tasks;
        #endif

        CEU_Value clo = ceux_peek(X1->S, XX1(-inp-1));
        if (clo.type != CEU_VALUE_CLO_TASK) {
            return ceu_error_s(X1->S, "spawn error : expected task");
        }
        
        CEU_Value exe; {
        #if CEU >= 5
            if (xup_tsks != NULL) {
                exe = ceu_create_exe_task(clo, (CEU_Dyn*) xup_tsks, NULL);
            } else {
                exe = ceu_create_exe_task(clo, (CEU_Dyn*) ceu_up_tsk(X1), ceu_up_blk(X1->S));
            }
        #else
            exe = ceu_create_exe_task(clo, (CEU_Dyn*) ceu_up_tsk(X1), ceu_up_blk(X1->S));
        #endif
        }
        if (exe.type == CEU_VALUE_ERROR) {
            return ceu_error_e(X1->S, exe);
        }
    #if CEU >= 5
        else if (exe.type == CEU_VALUE_NIL) {
            // X1: [tsks,clo,inps]
            ceux_pop_n(X1->S, 2+inp);
            ceux_push(X1->S, 1, (CEU_Value) { CEU_VALUE_NIL });
            // X1: [nil]
            return 1;
        }
    #endif
        assert(exe.Dyn->Exe_Task.clo.type == CEU_VALUE_CLO_TASK);
        
        ceux_repl(X1->S, XX1(-inp-1), exe);
        // X1: [tsks,exe,inps]
        
        ceu_gc_inc_val(exe);    // keep exe alive to return it  
        int ret = ceux_resume(X1, inp, 0, CEU_ACTION_RESUME CEU4(COMMA now));
        // X1: [tsks]
        
        if (ret > 0) {
            // error
        } else {
            ret = 1;
    #if CEU >= 5
            ceux_pop(X1->S, 1); // [tsks]
    #endif
            ceux_push(X1->S, 1, exe);        // returns exe to caller
            // X1: [exe]
        }
        ceu_gc_dec_val(exe);    // dec after push above
        
        return ret;
    }
#endif
    
    CEU_Value ceu_dyn_to_val (CEU_Dyn* dyn) {
        return (CEU_Value) { dyn->Any.type, {.Dyn=dyn} };
    }
    
    int ceu_dump_f (CEUX* X) {
        assert(X->args == 1);
    #ifdef CEU_DEBUG
        ceu_dump_val(ceux_peek(X->S, ceux_arg(X,0)));
        return 0;
    #else
        return ceu_error_s(X->S, "debug is off");
    #endif
    }

    int ceu_as_bool (CEU_Value v) {
        return !(v.type==CEU_VALUE_NIL || (v.type==CEU_VALUE_BOOL && !v.Bool));
    }
    int ceu_type_f (CEUX* X) {
        assert(X->args==1 && "bug found");
        int type = ceux_peek(X->S, ceux_arg(X,0)).type;
        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=type} });
        return 1;
    }
    
    CEU_Value _ceu_sup_ (CEU_Value sup, CEU_Value sub) {
        assert(sup.type == CEU_VALUE_TAG);
        assert(sub.type == CEU_VALUE_TAG);
        
        //printf("sup=0x%08X vs sub=0x%08X\n", sup->Tag, sub->Tag);
        int sup0 = sup.Tag & 0x000000FF;
        int sup1 = sup.Tag & 0x0000FF00;
        int sup2 = sup.Tag & 0x00FF0000;
        int sup3 = sup.Tag & 0xFF000000;
        int sub0 = sub.Tag & 0x000000FF;
        int sub1 = sub.Tag & 0x0000FF00;
        int sub2 = sub.Tag & 0x00FF0000;
        int sub3 = sub.Tag & 0xFF000000;

        return (CEU_Value) { CEU_VALUE_BOOL, { .Bool =
            (sup0 == sub0) && ((sup1 == 0) || (
                (sup1 == sub1) && ((sup2 == 0) || (
                    (sup2 == sub2) && ((sup3 == 0) || (
                        (sup3 == sub3)
                    ))
                ))
            ))
        } };
    }
    int ceu_sup_question__f (CEUX* X) {
        assert(X->args >= 2);
        CEU_Value sup = ceux_peek(X->S, ceux_arg(X,0));
        CEU_Value sub = ceux_peek(X->S, ceux_arg(X,1));
        CEU_Value ret = _ceu_sup_(sup, sub);
        ceux_push(X->S, 1, ret);
        return 1;
    }
    
    CEU_Value _ceu_tags_all_ (CEU_Value dyn) {
        int len = 0; {
            CEU_Tags_List* cur = dyn.Dyn->Any.tags;
            while (cur != NULL) {
                len++;
                cur = cur->next;
            }
        }
        CEU_Value tup = ceu_create_tuple(len);
        {
            CEU_Tags_List* cur = dyn.Dyn->Any.tags;
            int i = 0;
            while (cur != NULL) {
                ceu_tuple_set(&tup.Dyn->Tuple, i++, (CEU_Value) { CEU_VALUE_TAG, {.Tag=cur->tag} });
                cur = cur->next;
            }
        }
        return tup;
    }
    
    CEU_Value ceu_tags_chk (CEU_Value dyn, CEU_Value tag) {
        CEU_Value ret = { CEU_VALUE_BOOL, {.Bool=0} };
        CEU_Tags_List* cur = (dyn.type < CEU_VALUE_DYNAMIC) ? NULL : dyn.Dyn->Any.tags;
        while (cur != NULL) {
            CEU_Value sub = { CEU_VALUE_TAG, {.Tag=cur->tag} };
            ret = _ceu_sup_(tag, sub);
            if (ret.Bool) {
                break;
            }
            cur = cur->next;
        }
        return ret;
    }
        
    void ceu_tags_set (CEU_Value dyn, CEU_Value tag, int on) {
        assert(dyn.type > CEU_VALUE_DYNAMIC);
        if (on) {   // add
            CEU_Value has = ceu_tags_chk(dyn, tag);
            if (!has.Bool) {
                CEU_Tags_List* v = malloc(sizeof(CEU_Tags_List));
                assert(v != NULL);
                v->tag = tag.Tag;
                v->next = dyn.Dyn->Any.tags;
                dyn.Dyn->Any.tags = v;
            }
        } else {            // rem
            CEU_Tags_List** cur = &dyn.Dyn->Any.tags;
            while (*cur != NULL) {
                if ((*cur)->tag == tag.Tag) {
                    CEU_Tags_List* v = *cur;
                    *cur = v->next;
                    free(v);
                    break;
                }
                cur = &(*cur)->next;
            }
        }
    }
        
    int ceu_tags_f (CEUX* X) {
        assert(X->args >= 1);
        CEU_Value dyn = ceux_peek(X->S, ceux_arg(X,0));
        CEU_Value tag; // = (CEU_Value) { CEU_VALUE_NIL };
        if (X->args >= 2) {
            tag = ceux_peek(X->S, ceux_arg(X,1));
            assert(tag.type == CEU_VALUE_TAG);
        }
        
        switch (X->args) {
            case 1: {   // all tags
                CEU_Value ret = _ceu_tags_all_(dyn);
                ceux_push(X->S, 1, ret);
                break;
            }
            case 2: {   // check tag
                CEU_Value ret = ceu_tags_chk(dyn, tag);
                ceux_push(X->S, 1, ret);
                break;
            }
            default: {   // add/rem tag
                CEU_Value bool = ceux_peek(X->S, ceux_arg(X,2));
                assert(bool.type == CEU_VALUE_BOOL);
                ceu_tags_set(dyn, tag, bool.Bool);
                ceux_dup(X->S, ceux_arg(X,0));  // keep dyn
                break;
            }
        }
        return 1;
    }
    
    // TO-TAG-*

    int ceu_to_dash_tag_dash_string_f (CEUX* X) {
        assert(X->args == 1);
        CEU_Value str = ceux_peek(X->S, ceux_arg(X,0));
        assert(str.type==CEU_VALUE_VECTOR && str.Dyn->Vector.unit==CEU_VALUE_CHAR);
        CEU_Tags_Names* cur = CEU_TAGS;
        CEU_Value ret = (CEU_Value) { CEU_VALUE_NIL };
        while (cur != NULL) {
            if (!strcmp(cur->name,str.Dyn->Vector.buf)) {
                ret = (CEU_Value) { CEU_VALUE_TAG, {.Tag=cur->tag} };
                break;
            }
            cur = cur->next;
        }
        ceux_push(X->S, 1, ret);
        return 1;
    }
    
    // TO-STRING-*

    char* ceu_to_dash_string_dash_tag (int tag) {
        CEU_Tags_Names* cur = CEU_TAGS;
        while (cur != NULL) {
            if (cur->tag == tag) {
                return cur->name;
            }
            cur = cur->next;
        }
        assert(0 && "bug found");
    }
    
    CEU_Value ceu_to_dash_string_dash_pointer (const char* ptr) {
        assert(ptr != NULL);
        CEU_Value str = ceu_create_vector();
        int len = strlen(ptr);
        for (int i=0; i<len; i++) {
            CEU_Value chr = { CEU_VALUE_CHAR, {.Char=ptr[i]} };
            ceu_vector_set(&str.Dyn->Vector, i, chr);
        }
        return str;
    }
    
    int ceu_to_dash_string_dash_pointer_f (CEUX* X) {
        assert(X->args == 1);
        CEU_Value ptr = ceux_peek(X->S, ceux_arg(X,0));
        assert(ptr.type==CEU_VALUE_POINTER && ptr.Pointer!=NULL);
        ceux_push(X->S, 1, ceu_to_dash_string_dash_pointer(ptr.Pointer));
        return 1;
    }

    int ceu_to_dash_string_dash_tag_f (CEUX* X) {
        assert(X->args == 1);
        CEU_Value t = ceux_peek(X->S, ceux_arg(X,0));
        assert(t.type == CEU_VALUE_TAG);        
        ceux_push(X->S, 1, ceu_to_dash_string_dash_pointer(ceu_to_dash_string_dash_tag(t.Tag)));
        return 1;
    }

    int ceu_to_dash_string_dash_number_f (CEUX* X) {
        assert(X->args == 1);
        CEU_Value n = ceux_peek(X->S, ceux_arg(X,0));
        assert(n.type == CEU_VALUE_NUMBER);
        
        char str[255];
        snprintf(str, 255, "%g", n.Number);
        assert(strlen(str) < 255);

        ceux_push(X->S, 1, ceu_to_dash_string_dash_pointer(str));
        return 1;
    }
    
    #define ceu_sizeof(type, member) sizeof(((type *)0)->member)
    int ceu_type_to_size (int type) {
        switch (type) {
            case CEU_VALUE_NIL:
            case CEU_VALUE_ERROR:
                return 0;
            case CEU_VALUE_TAG:
                return ceu_sizeof(CEU_Value, Tag);
            case CEU_VALUE_BOOL:
                return ceu_sizeof(CEU_Value, Bool);
            case CEU_VALUE_CHAR:
                return ceu_sizeof(CEU_Value, Char);
            case CEU_VALUE_NUMBER:
                return ceu_sizeof(CEU_Value, Number);
            case CEU_VALUE_POINTER:
                return ceu_sizeof(CEU_Value, Pointer);
            default:
                return ceu_sizeof(CEU_Value, Dyn);
        }
    }
    
    CEU_Value ceu_col_get (CEU_Value col, CEU_Value key) {
        CEU_Value err = ceu_col_check(col,key);
        if (err.type == CEU_VALUE_ERROR) {
            return err;
        }
        switch (col.type) {
            case CEU_VALUE_TUPLE:
                return col.Dyn->Tuple.buf[(int) key.Number];
            case CEU_VALUE_VECTOR:
                return ceu_vector_get(&col.Dyn->Vector, key.Number);
                break;
            case CEU_VALUE_DICT:
                return ceu_dict_get(&col.Dyn->Dict, key);
            default:
                assert(0 && "bug found");
        }
    }
    
    CEU_Value ceu_col_set (CEU_Value col, CEU_Value key, CEU_Value val) {
        CEU_Value ok = { CEU_VALUE_NIL };
        switch (col.type) {
            case CEU_VALUE_TUPLE:
                ceu_tuple_set(&col.Dyn->Tuple, key.Number, val);
                break;
            case CEU_VALUE_VECTOR:
                ceu_vector_set(&col.Dyn->Vector, key.Number, val);
                break;
            case CEU_VALUE_DICT: {
                ok = ceu_dict_set(&col.Dyn->Dict, key, val);
                break;
            }
            default:
                assert(0 && "bug found");
        }
        return ok;
    }
    
    void ceu_tuple_set (CEU_Tuple* tup, int i, CEU_Value v) {
        ceu_gc_inc_val(v);
        ceu_gc_dec_val(tup->buf[i]);
        tup->buf[i] = v;
    }
    
    CEU_Value ceu_vector_get (CEU_Vector* vec, int i) {
        if (i<0 || i>=vec->its) {
            return (CEU_Value) { CEU_VALUE_ERROR, {.Error="index error : out of bounds"} };
        }
        int sz = ceu_type_to_size(vec->unit);
        CEU_Value ret = (CEU_Value) { vec->unit };
        memcpy(&ret.Number, vec->buf+i*sz, sz);
        return ret;
    }
    
    void ceu_vector_set (CEU_Vector* vec, int i, CEU_Value v) {
        if (v.type == CEU_VALUE_NIL) {           // pop
            assert(i == vec->its-1);
            CEU_Value ret = ceu_vector_get(vec, i);
            assert(ret.type != CEU_VALUE_ERROR);
            ceu_gc_dec_val(ret);
            vec->its--;
        } else {
            if (vec->its == 0) {
                vec->unit = v.type;
            } else {
                assert(v.type == vec->unit);
            }
            int sz = ceu_type_to_size(vec->unit);
            if (i == vec->its) {           // push
                if (i == vec->max) {
                    vec->max = vec->max*2 + 1;    // +1 if max=0
                    vec->buf = realloc(vec->buf, vec->max*sz + 1);
                    assert(vec->buf != NULL);
                }
                ceu_gc_inc_val(v);
                vec->its++;
                vec->buf[sz*vec->its] = '\0';
            } else {                            // set
                CEU_Value ret = ceu_vector_get(vec, i);
                assert(ret.type != CEU_VALUE_ERROR);
                ceu_gc_inc_val(v);
                ceu_gc_dec_val(ret);
                assert(i < vec->its);
            }
            memcpy(vec->buf + i*sz, (char*)&v.Number, sz);
        }
    }
    
    CEU_Value ceu_vector_from_c_string (const char* str) {
        CEU_Value vec = ceu_create_vector();
        int N = strlen(str);
        for (int i=0; i<N; i++) {
            ceu_vector_set(&vec.Dyn->Vector, vec.Dyn->Vector.its, (CEU_Value) { CEU_VALUE_CHAR, {.Char=str[i]} });
        }
        return vec;
    }

    int ceu_next_dash_dict_f (CEUX* X) {
        assert(X->args==1 || X->args==2);
        CEU_Value dict = ceux_peek(X->S, ceux_arg(X,0));
        CEU_Value ret;
        if (dict.type != CEU_VALUE_DICT) {
            return ceu_error_s(X->S, "next-dict error : expected dict");
        } else {
            CEU_Value key = (X->args == 1) ? ((CEU_Value) { CEU_VALUE_NIL }) : ceux_peek(X->S, ceux_arg(X,1));
            if (key.type == CEU_VALUE_NIL) {
                ret = (*dict.Dyn->Dict.buf)[0][0];
            } else {
                ret = (CEU_Value) { CEU_VALUE_NIL };
                for (int i=0; i<dict.Dyn->Dict.max-1; i++) {     // -1: last element has no next
                    CEU_Value ok = _ceu_equals_equals_(key, (*dict.Dyn->Dict.buf)[i][0]);
                    assert(ok.type != CEU_VALUE_ERROR);
                    if (ok.Bool) {
                        ret = (*dict.Dyn->Dict.buf)[i+1][0];
                        break;
                    }
                }
            }
        }
        ceux_push(X->S, 1, ret);
        return 1;
    }
    
    int ceu_dict_key_to_index (CEU_Dict* col, CEU_Value key, int* idx) {
        *idx = -1;
        for (int i=0; i<col->max; i++) {
            CEU_Value cur = (*col->buf)[i][0];
            CEU_Value ret = _ceu_equals_equals_(key, cur);
            assert(ret.type != CEU_VALUE_ERROR);
            if (ret.Bool) {
                *idx = i;
                return 1;
            } else {
                if (*idx==-1 && cur.type==CEU_VALUE_NIL) {
                    *idx = i;
                }
            }
        }
        return 0;
    }        
    CEU_Value ceu_dict_get (CEU_Dict* col, CEU_Value key) {
        int i;
        int ok = ceu_dict_key_to_index(col, key, &i);
        if (ok) {
            return (*col->buf)[i][1];
        } else {
            return (CEU_Value) { CEU_VALUE_NIL };
        }
    }        
    CEU_Value ceu_dict_set (CEU_Dict* col, CEU_Value key, CEU_Value val) {
        if (key.type == CEU_VALUE_NIL) {
            return (CEU_Value) { CEU_VALUE_ERROR, {.Error="dict error : index cannot be nil"} };
        }
        int old;
        ceu_dict_key_to_index(col, key, &old);
        if (old == -1) {
            old = col->max;
            int new = MAX(5, old * 2);
            col->max = new;
            col->buf = realloc(col->buf, new*2*sizeof(CEU_Value));
            assert(col->buf != NULL);
            memset(&(*col->buf)[old], 0, (new-old)*2*sizeof(CEU_Value));  // x[i]=nil
        }
        assert(old != -1);
        
        CEU_Value vv = ceu_dict_get(col, key);
        
        if (val.type == CEU_VALUE_NIL) {
            ceu_gc_dec_val(vv);
            ceu_gc_dec_val(key);
            (*col->buf)[old][0] = (CEU_Value) { CEU_VALUE_NIL };
        } else {
            ceu_gc_inc_val(val);
            ceu_gc_dec_val(vv);
            if (vv.type == CEU_VALUE_NIL) {
                ceu_gc_inc_val(key);
            }
            (*col->buf)[old][0] = key;
            (*col->buf)[old][1] = val;
        }
        return (CEU_Value) { CEU_VALUE_NIL };
    }        
    
    CEU_Value ceu_col_check (CEU_Value col, CEU_Value idx) {
        if (col.type<CEU_VALUE_TUPLE || col.type>CEU_VALUE_DICT) {                
            return (CEU_Value) { CEU_VALUE_ERROR, {.Error="index error : expected collection"} };
        }
        if (col.type != CEU_VALUE_DICT) {
            if (idx.type != CEU_VALUE_NUMBER) {
                return (CEU_Value) { CEU_VALUE_ERROR, {.Error="index error : expected number"} };
            }
            if (col.type==CEU_VALUE_TUPLE && (idx.Number<0 || idx.Number>=col.Dyn->Tuple.its)) {                
                return (CEU_Value) { CEU_VALUE_ERROR, {.Error="index error : out of bounds"} };
            }
            if (col.type==CEU_VALUE_VECTOR && (idx.Number<0 || idx.Number>col.Dyn->Vector.its)) {                
                return (CEU_Value) { CEU_VALUE_ERROR, {.Error="index error : out of bounds"} };
            }
        }
        return (CEU_Value) { CEU_VALUE_NIL };
    }
    
    CEU_Value ceu_create_tuple (int n) {
        ceu_debug_add(CEU_VALUE_TUPLE);
        CEU_Tuple* ret = malloc(sizeof(CEU_Tuple) + n*sizeof(CEU_Value));
        assert(ret != NULL);
        *ret = (CEU_Tuple) {
            CEU_VALUE_TUPLE, 0, NULL,
            n, {}
        };
        memset(ret->buf, 0, n*sizeof(CEU_Value));
        return (CEU_Value) { CEU_VALUE_TUPLE, {.Dyn=(CEU_Dyn*)ret} };
    }
    
    int ceu_tuple_f (CEUX* X) {
        assert(X->args == 1);
        CEU_Value arg = ceux_peek(X->S, ceux_arg(X,0));
        assert(arg.type == CEU_VALUE_NUMBER);
        CEU_Value ret = ceu_create_tuple(arg.Number);
        ceux_push(X->S, 1, ret);
        return 1;
    }
    
    CEU_Value ceu_create_vector (void) {
        ceu_debug_add(CEU_VALUE_VECTOR);
        CEU_Vector* ret = malloc(sizeof(CEU_Vector));
        assert(ret != NULL);
        char* buf = malloc(1);  // because of '\0' in empty strings
        assert(buf != NULL);
        buf[0] = '\0';
        *ret = (CEU_Vector) {
            CEU_VALUE_VECTOR, 0,  NULL,
            0, 0, CEU_VALUE_NIL, buf
        };
        return (CEU_Value) { CEU_VALUE_VECTOR, {.Dyn=(CEU_Dyn*)ret} };
    }
    
    CEU_Value ceu_create_dict (void) {
        ceu_debug_add(CEU_VALUE_DICT);
        CEU_Dict* ret = malloc(sizeof(CEU_Dict));
        assert(ret != NULL);
        *ret = (CEU_Dict) {
            CEU_VALUE_DICT, 0, NULL,
            0, NULL
        };
        return (CEU_Value) { CEU_VALUE_DICT, {.Dyn=(CEU_Dyn*)ret} };
    }
    
    CEU_Value ceu_create_clo (CEU_VALUE type, CEU_Proto proto, int args, int locs, int upvs) {
        ceu_debug_add(type);
        CEU_Clo* ret = malloc(CEU4(type==CEU_VALUE_CLO_TASK ? sizeof(CEU_Clo_Task) :) sizeof(CEU_Clo));
        assert(ret != NULL);
        CEU_Value* buf = malloc(upvs * sizeof(CEU_Value));
        assert(buf != NULL);
        for (int i=0; i<upvs; i++) {
            buf[i] = (CEU_Value) { CEU_VALUE_NIL };
        }
        *ret = (CEU_Clo) {
            type, 0, NULL,
            proto,
            args, locs, { upvs, buf }
        };
        return (CEU_Value) { type, {.Dyn=(CEU_Dyn*)ret } };
    }

    #if CEU >= 4
    CEU_Value ceu_create_clo_task (CEU_Proto proto, int args, int locs, int upvs, CEU_Exe_Task* up_tsk) {
        CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_TASK, proto, args, locs, upvs);
        assert(clo.type == CEU_VALUE_CLO_TASK);
        clo.Dyn->Clo_Task.up_tsk = up_tsk;
        return clo;
    }
    #endif
    
    #if CEU >= 3
    CEU_Value ceu_create_exe (int type, int sz, CEU_Value clo) {
        ceu_debug_add(type);
        assert(clo.type==CEU_VALUE_CLO_CORO CEU4(|| clo.type==CEU_VALUE_CLO_TASK));
        ceu_gc_inc_val(clo);
        
        CEU_Exe* ret = malloc(sz);
        assert(ret != NULL);
        CEUX* X = malloc(sizeof(CEUX));
        CEU_Stack* S = malloc(sizeof(CEU_Stack));
        assert(X!=NULL && S!=NULL);
        S->n = 0;
        //S->buf = <dynamic>    // TODO
        *X = (CEUX) { S, -1, -1, CEU_ACTION_INVALID, {.exe=ret} CEU4(COMMA CEU_TIME-1 COMMA NULL) };
            // X->up is set on resume, not here on creation

        *ret = (CEU_Exe) {
            type, 0, NULL,
            CEU_EXE_STATUS_YIELDED, clo, 0, X
        };
        
        return (CEU_Value) { type, {.Dyn=(CEU_Dyn*)ret } };
    }
    #endif
    
    #if CEU >= 4
    CEU_Value ceu_create_exe_task (CEU_Value clo, CEU_Dyn* up_dyn, CEU_Block* up_blk) {
    #if CEU >= 5
        int ceu_tasks_n (CEU_Tasks* tsks) {
            int n = 0;
            CEU_Exe_Task* cur = (CEU_Exe_Task*) tsks->lnks.dn.fst;
            while (cur != NULL) {
                n++;
                cur = (CEU_Exe_Task*) cur->lnks.sd.nxt;
            }
            return n;
        }
        if (!ceu_isexe_dyn(up_dyn)) {
            CEU_Tasks* tsks = (CEU_Tasks*) up_dyn;
            if (tsks->max!=0 && ceu_tasks_n(tsks)>=tsks->max) {
                return (CEU_Value) { CEU_VALUE_NIL };
            }
        }
    #endif
        
        if (clo.type != CEU_VALUE_CLO_TASK) {
            return (CEU_Value) { CEU_VALUE_ERROR, {.Error="spawn error : expected task"} };
        }

        CEU_Value ret = ceu_create_exe(CEU_VALUE_EXE_TASK, sizeof(CEU_Exe_Task), clo);
        CEU_Exe_Task* dyn = &ret.Dyn->Exe_Task;
        
        ceu_gc_inc_dyn((CEU_Dyn*) dyn);    // up_blk/tsks holds a strong reference

        dyn->time = CEU_TIME;
        dyn->pub = (CEU_Value) { CEU_VALUE_NIL };

        dyn->lnks = (CEU_Links) { {up_dyn,NULL}, {NULL,NULL}, {NULL,NULL} };

        if (CEU5(dyn!=NULL && ceu_isexe_dyn(up_dyn) &&) *up_blk==NULL) {
            dyn->lnks.up.blk = up_blk;    // only the first task points up
            *up_blk = (CEU_Dyn*) dyn;
        }
        
        if (up_dyn != NULL) {
            CEU_Links* up_lnks = CEU_LNKS(up_dyn);        
            if (up_lnks->dn.fst == NULL) {
                assert(up_lnks->dn.lst == NULL);
                up_lnks->dn.fst = (CEU_Dyn*) dyn;
            } else if (up_lnks->dn.lst != NULL) {
                CEU_LNKS(up_lnks->dn.lst)->sd.nxt = (CEU_Dyn*) dyn;
                dyn->lnks.sd.prv = up_lnks->dn.lst;
            }
            up_lnks->dn.lst = (CEU_Dyn*) dyn;
        }

        return ret;
    }
    #endif
    
    #if CEU >= 5
    CEU_Value ceu_create_tasks (int max, CEU_Exe_Task* up_tsk, CEU_Block* up_blk) {
        CEU_Tasks* ret = malloc(sizeof(CEU_Tasks));
        assert(ret != NULL);

        *ret = (CEU_Tasks) {
            CEU_VALUE_TASKS, 0, NULL,
            max, { {(CEU_Dyn*)up_tsk,NULL}, {NULL,NULL}, {NULL,NULL} }
        };
        
        ceu_gc_inc_dyn((CEU_Dyn*) ret);    // up_blk/tsks holds a strong reference

        {
            if (*up_blk == NULL) {
                ret->lnks.up.blk = up_blk;    // only the first task points up
                *up_blk = (CEU_Dyn*) ret;
            }
            if (up_tsk->lnks.dn.fst == NULL) {
                assert(up_tsk->lnks.dn.lst == NULL);
                up_tsk->lnks.dn.fst = (CEU_Dyn*) ret;
            } else if (up_tsk->lnks.dn.lst != NULL) {
                CEU_LNKS(up_tsk->lnks.dn.lst)->sd.nxt = (CEU_Dyn*) ret;
                ret->lnks.sd.prv = up_tsk->lnks.dn.lst;
            }
            up_tsk->lnks.dn.lst = (CEU_Dyn*) ret;
        }
        
        return (CEU_Value) { CEU_VALUE_TASKS, {.Dyn=(CEU_Dyn*)ret} };
    }
    #if 0
    CEU_Value ceu_create_track (CEU_Exe_Task* task) {
        ceu_debug_add(CEU_VALUE_TRACK);
        CEU_Track* ret = malloc(sizeof(CEU_Track));
        assert(ret != NULL);
        *ret = (CEU_Track) {
            CEU_VALUE_TRACK, 0, NULL,
            task
        };
        ceu_hold_add((CEU_Dyn*)ret, blk, &blk->dn.dyns);
        return (CEU_Value) { CEU_VALUE_TRACK, {.Dyn=(CEU_Dyn*)ret} };
    }
    #endif
    #endif
    
    void ceu_print1 (CEU_Value v) {
        if (v.type > CEU_VALUE_DYNAMIC) {  // TAGS
            CEU_Value tup = _ceu_tags_all_(v);
            assert(tup.type == CEU_VALUE_TUPLE);
            int N = tup.Dyn->Tuple.its;
            if (N > 0) {
                if (N > 1) {
                    printf("[");
                }
                for (int i=0; i<N; i++) {
                    ceu_print1(tup.Dyn->Tuple.buf[i]);
                    if (i < N-1) {
                        printf(",");
                    }
                }
                if (N > 1) {
                    printf("]");
                }
                printf(" ");
            }
            ceu_gc_free(tup.Dyn);
        }
        switch (v.type) {
            case CEU_VALUE_BLOCK:
    #if CEU >= 4
                printf("block: %p", v.Block);
    #else
                printf("(block sentinel)");
    #endif
                break;
            case CEU_VALUE_NIL:
                printf("nil");
                break;
            case CEU_VALUE_ERROR:
                printf("error: %s", (v.Error==NULL ? "(null)" : v.Error));
                break;
            case CEU_VALUE_TAG:
                printf("%s", ceu_to_dash_string_dash_tag(v.Tag));
                break;
            case CEU_VALUE_BOOL:
                if (v.Bool) {
                    printf("true");
                } else {
                    printf("false");
                }
                break;
            case CEU_VALUE_CHAR:
                putchar(v.Char);
                break;
            case CEU_VALUE_NUMBER:
                printf("%g", v.Number);
                break;
            case CEU_VALUE_POINTER:
                printf("pointer: %p", v.Pointer);
                break;
            case CEU_VALUE_TUPLE:
                printf("[");
                for (int i=0; i<v.Dyn->Tuple.its; i++) {
                    if (i > 0) {
                        printf(",");
                    }
                    ceu_print1(v.Dyn->Tuple.buf[i]);
                }                    
                printf("]");
                break;
            case CEU_VALUE_VECTOR:
                if (v.Dyn->Vector.unit == CEU_VALUE_CHAR) {
                    printf("%s", v.Dyn->Vector.buf);
                } else {
                    printf("#[");
                    for (int i=0; i<v.Dyn->Vector.its; i++) {
                        if (i > 0) {
                            printf(",");
                        }
                        CEU_Value ret = ceu_vector_get(&v.Dyn->Vector, i);
                        assert(ret.type != CEU_VALUE_ERROR);
                        ceu_print1(ret);
                    }                    
                    printf("]");
                }
                break;
            case CEU_VALUE_DICT:
                printf("@[");
                int comma = 0;
                for (int i=0; i<v.Dyn->Dict.max; i++) {
                    if ((*v.Dyn->Dict.buf)[i][0].type != CEU_VALUE_NIL) {
                        if (comma != 0) {
                            printf(",");
                        }
                        comma = 1;
                        printf("(");
                        ceu_print1((*v.Dyn->Dict.buf)[i][0]);
                        printf(",");
                        ceu_print1((*v.Dyn->Dict.buf)[i][1]);
                        printf(")");
                    }
                }                    
                printf("]");
                break;
            case CEU_VALUE_CLO_FUNC:
                printf("func: %p", v.Dyn);
                if (v.Dyn->Clo.upvs.its > 0) {
                    printf(" | [");
                    for (int i=0; i<v.Dyn->Clo.upvs.its; i++) {
                        if (i > 0) {
                            printf(",");
                        }
                        ceu_print1(v.Dyn->Clo.upvs.buf[i]);
                    }
                    printf("]");
                }
                break;
    #if CEU >= 3
            case CEU_VALUE_CLO_CORO:
                printf("coro: %p", v.Dyn);
                break;
    #endif
    #if CEU >= 4
            case CEU_VALUE_CLO_TASK:
                printf("task: %p", v.Dyn);
                break;
    #endif
    #if CEU >= 3
            case CEU_VALUE_EXE_CORO:
                printf("exe-coro: %p", v.Dyn);
                break;
    #endif
    #if CEU >= 4
            case CEU_VALUE_EXE_TASK:
                printf("exe-task: %p", v.Dyn);
                break;
    #endif
    #if CEU >= 5
            case CEU_VALUE_TASKS:
                printf("tasks: %p", v.Dyn);
                break;
            case CEU_VALUE_TRACK:
                printf("track: %p", v.Dyn);
                break;
    #endif
            default:
                assert(0 && "bug found");
        }
    }
    int ceu_print_f (CEUX* X) {
        for (int i=0; i<X->args; i++) {
            if (i > 0) {
                printf("\t");
            }
            ceu_print1(ceux_peek(X->S, ceux_arg(X,i)));
        }
        return 0;
    }
    int ceu_println_f (CEUX* X) {
        assert(0 == ceu_print_f(X));
        printf("\n");
        return 0;
    }
    
    CEU_Value _ceu_equals_equals_ (CEU_Value e1, CEU_Value e2) {
        int v = (e1.type == e2.type);
        if (v) {
            switch (e1.type) {
                case CEU_VALUE_NIL:
                    v = 1;
                    break;
                case CEU_VALUE_TAG:
                    v = (e1.Tag == e2.Tag);
                    break;
                case CEU_VALUE_BOOL:
                    v = (e1.Bool == e2.Bool);
                    break;
                case CEU_VALUE_CHAR:
                    v = (e1.Char == e2.Char);
                    break;
                case CEU_VALUE_NUMBER:
                    v = (e1.Number == e2.Number);
                    break;
                case CEU_VALUE_POINTER:
                    v = (e1.Pointer == e2.Pointer);
                    break;
                case CEU_VALUE_TUPLE:
                case CEU_VALUE_VECTOR:
                case CEU_VALUE_DICT:
                case CEU_VALUE_CLO_FUNC:
        #if CEU >= 3
                case CEU_VALUE_CLO_CORO:
        #endif
        #if CEU >= 4
                case CEU_VALUE_CLO_TASK:
        #endif
        #if CEU >= 3
                case CEU_VALUE_EXE_CORO:
        #endif
        #if CEU >= 4
                case CEU_VALUE_EXE_TASK:
        #endif
        #if CEU >= 5
                case CEU_VALUE_TRACK:
        #endif
                    v = (e1.Dyn == e2.Dyn);
                    break;
                default:
                    assert(0 && "bug found");
            }
        }
        return (CEU_Value) { CEU_VALUE_BOOL, {.Bool=v} };
    }
    int ceu_equals_equals_f (CEUX* X) {
        assert(X->args == 2);
        CEU_Value ret = _ceu_equals_equals_(ceux_peek(X->S, ceux_arg(X,0)), ceux_peek(X->S, ceux_arg(X,1)));
        ceux_push(X->S, 1, ret);
        return 1;
    }
    int ceu_slash_equals_f (CEUX* X) {
        ceu_equals_equals_f(X);
        CEU_Value ret = ceux_pop(X->S, 0);
        assert(ret.type == CEU_VALUE_BOOL);
        ret.Bool = !ret.Bool;
        ceux_push(X->S, 1, ret);
        return 1;
    }
    
    int ceu_hash_f (CEUX* X) {
        assert(X->args == 1);
        CEU_Value v = ceux_peek(X->S, ceux_arg(X,0));
        CEU_Value ret;
        if (v.type == CEU_VALUE_VECTOR) {
            ret = (CEU_Value) { CEU_VALUE_NUMBER, {.Number=v.Dyn->Vector.its} };
        } else if (v.type == CEU_VALUE_TUPLE) {
            ret = (CEU_Value) { CEU_VALUE_NUMBER, {.Number=v.Dyn->Tuple.its} };
        } else {
            return ceu_error_s(X->S, "length error : not a vector");
        }
        ceux_push(X->S, 1, ret);
        return 1;
    }
    
        #if CEU >= 3
        int ceu_isexe_val (CEU_Value val) {
            return (val.type==CEU_VALUE_EXE_CORO CEU4(|| ceu_istask_val(val)));
        }
        int ceu_isexe_dyn (CEU_Dyn* dyn) {
            return (dyn->Any.type==CEU_VALUE_EXE_CORO CEU4(|| ceu_istask_dyn(dyn)));
        }
        int ceu_coroutine_f (CEUX* X) {
            assert(X->args == 1);
            CEU_Value coro = ceux_peek(X->S, ceux_arg(X,0));
            CEU_Value ret;
            if (coro.type != CEU_VALUE_CLO_CORO) {
                return ceu_error_s(X->S, "coroutine error : expected coro");
            } else {
                ret = ceu_create_exe(CEU_VALUE_EXE_CORO, sizeof(CEU_Exe), coro);
            }
            ceux_push(X->S, 1, ret);
            return 1;
        }        

        int ceu_status_f (CEUX* X) {
            assert(X->args == 1);
            CEU_Value exe = ceux_peek(X->S, ceux_arg(X,0));
            CEU_Value ret;
            if (exe.type!=CEU_VALUE_EXE_CORO CEU4(&& !ceu_istask_val(exe))) {
        #if CEU < 4
                return ceu_error_s(X->S, "status error : expected running coroutine");
        #else
                return ceu_error_s(X->S, "status error : expected running coroutine or task");
        #endif
            } else {
                ret = (CEU_Value) { CEU_VALUE_TAG, {.Tag=exe.Dyn->Exe.status + CEU_TAG_yielded - 1} };
            }
            ceux_push(X->S, 1, ret);
            return 1;
        }
        
        int ceu_exe_term (CEUX* X) {
            if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                // leave -> outer ref -> gc_dec -> term
                return 0;
            }
            X->exe->status = CEU_EXE_STATUS_TERMINATED;
            int ret = 0;
    #if CEU >= 4
            if (X->exe->type == CEU_VALUE_EXE_TASK) {
                // do not bcast aborted task b/c
                // it would awake parents that actually need to
                // respond/catch the error (thus not awake)
                if (X->action != CEU_ACTION_ABORT) {
                    CEU_Exe_Task* tsk = ((CEU_Exe_Task*) X->exe);
                    CEU_Dyn* up;
    #if CEU >= 5
                    if (tsk->lnks.up.dyn!=NULL && tsk->lnks.up.dyn->Any.type==CEU_VALUE_TASKS) {
                        // tsk <- pool <- tsk
                        up = CEU_LNKS(tsk->lnks.up.dyn)->up.dyn;
                    } else
    #endif
                    {
                        // tsk <- tsk
                        up = tsk->lnks.up.dyn;
                    }
                    if (up!=NULL && !CEU_ERROR_IS(X->S)) {
                        assert(CEU_TIME < UINT32_MAX);
                        CEU_TIME++;
                        int i = ceux_push(X->S, 1, ceu_dyn_to_val((CEU_Dyn*) X->exe));   // bcast myself
                        ret = ceu_bcast_dyn(X, CEU_ACTION_RESUME, CEU_TIME, up);
                        //assert(ret == 0);
                        assert(X->exe->refs >= 2);  // ensures that the unlink below is safe (otherwise call gc_inc)
                        ceux_rem(X->S, i);
                    }
                    ceu_gc_dec_dyn((CEU_Dyn*) X->exe);  // only if natural termination
                }
            }
    #endif
            return ret;
        }

        #if CEU >= 5
        void ceu_abort_tasks (CEU_Tasks* tsks) {
            if (tsks->lnks.up.dyn == NULL) {
                return;     // already unlinked/killed
            }
            CEU_Dyn* cur = tsks->lnks.dn.fst;
            while (cur != NULL) {
                int term = (cur->Exe_Task.status == CEU_EXE_STATUS_TERMINATED);
                if (!term) {
                    ceu_abort_exe((CEU_Exe*) cur);
                }
                CEU_Dyn* nxt = CEU_LNKS(cur)->sd.nxt;
                if (!term) {
                    ceu_gc_dec_dyn(cur); // remove strong ref // TODO: could affect nxt?
                }
                cur = nxt;
            }
        }
        #endif

        void ceu_abort_exe (CEU_Exe* exe) {
            assert(ceu_isexe_dyn((CEU_Dyn*) exe));
            switch (exe->status) {
                case CEU_EXE_STATUS_TERMINATED:
                    // do nothing;
                    break;
                case CEU_EXE_STATUS_RESUMED:
                    exe->status = CEU_EXE_STATUS_TERMINATED;
                    break;
        #if CEU >= 4
                case CEU_EXE_STATUS_TOGGLED:
        #endif
                case CEU_EXE_STATUS_YIELDED:
                {
                    // TODO - fake S/X - should propagate up to calling stack
                    // TODO - fake now - should receive as arg (not CEU_TIME)
                    CEU_Stack S = { 0, {} };
                    CEUX _X = { &S, -1, -1, CEU_ACTION_INVALID, {.exe=NULL} CEU4(COMMA CEU_TIME COMMA NULL) };
                    CEUX* X = &_X;
                    ceux_push(&S, 1, ceu_dyn_to_val((CEU_Dyn*) exe));
                    // S: [co]
                    int ret = ceux_resume(X, 0, 0, CEU_ACTION_ABORT CEU4(COMMA CEU_TIME));
                    if (ret != 0) {
                        assert(CEU_ERROR_IS(&S) && "TODO: abort should not return");
                        assert(0 && "TODO: error in ceu_exe_kill");
                    }
                }
            }
        }
        #endif
     // TASK
        #if CEU >= 4
        void ceu_dyn_unlink (CEU_Dyn* dyn) {
            CEU_Links* me_lnks = CEU_LNKS(dyn);
            {   // UP-DYN-DN
                if (me_lnks->up.dyn != NULL) {
                    CEU_Links* up_lnks = CEU_LNKS(me_lnks->up.dyn);
                    me_lnks->up.dyn = NULL;
                    if (up_lnks->dn.fst == dyn) {
                        assert(me_lnks->sd.prv == NULL);
                        up_lnks->dn.fst = me_lnks->sd.nxt;
                    }
                    if (up_lnks->dn.lst == dyn) {
                        assert(me_lnks->sd.nxt == NULL);
                        up_lnks->dn.lst = me_lnks->sd.prv;
                    }
                }
            }
            {   // UP-BLK-DN
                if (me_lnks->up.blk != NULL) {
                    *me_lnks->up.blk = me_lnks->sd.nxt;
                    if (me_lnks->sd.nxt != NULL) {
                        CEU_LNKS(me_lnks->sd.nxt)->up.blk = me_lnks->up.blk;
                    }
                    me_lnks->up.blk = NULL; // also on ceux_block_leave (to prevent dangling pointer)
                }
            }
            {   // SD
                if (me_lnks->sd.prv != NULL) {
                    CEU_LNKS(me_lnks->sd.prv)->sd.nxt = me_lnks->sd.nxt;
                }
                if (me_lnks->sd.nxt != NULL) {
                    CEU_LNKS(me_lnks->sd.nxt)->sd.prv = me_lnks->sd.prv;
                }
                //me_lnks->sd.prv = me_lnks->sd.nxt = NULL;
                    // prv/nxt are never reached again:
                    //  - it is not a problem to keep the dangling pointers
                    // but we actually should not set them NULL:
                    //  - tsk might be in bcast_tasks which must call nxt
            }
            {   // DN
                CEU_Dyn* cur = me_lnks->dn.fst;
                if (me_lnks->dn.fst == NULL) {
                    assert(me_lnks->dn.lst == NULL);
                }
                while (cur != NULL) {
                    CEU_Links* dn_lnks = CEU_LNKS(cur);
                    dn_lnks->up.dyn = NULL;
                    cur = dn_lnks->sd.nxt;
                }
                me_lnks->dn.fst = me_lnks->dn.lst = NULL;
            }
        }
        
        int ceu_istask_dyn (CEU_Dyn* dyn) {
            return (dyn->Any.type == CEU_VALUE_EXE_TASK);
        }
        int ceu_istask_val (CEU_Value val) {
            return (val.type>CEU_VALUE_DYNAMIC) && ceu_istask_dyn(val.Dyn);
        }
        #endif
    
        #if CEU >= 4
        int ceu_bcast_tasks (CEUX* X1, CEU_ACTION act, uint32_t now, CEU_Dyn* dyn2) {
            //assert(dyn2!=NULL && (dyn2->type==CEU_VALUE_EXE_TASK CEU5(|| dyn2->type==CEU_VALUE_TASKS)));
            int ret = 0;
            CEU_Links* lnks = CEU_LNKS(dyn2);
            CEU_Dyn* cur = lnks->dn.fst;
            while (cur != NULL) {
                ceu_gc_inc_dyn(cur);
                ret = ceu_bcast_dyn(X1, act, now, cur);
                CEU_Dyn* nxt = CEU_LNKS(cur)->sd.nxt;
                ceu_gc_dec_dyn(cur); // TODO: could affect nxt?
                if (ret != 0) {
                    break;
                }
                cur = nxt;
            }
            return ret;
        }
        int ceu_bcast_task (CEUX* X1, CEU_ACTION act, uint32_t now, CEU_Exe_Task* tsk2) {            
            // bcast order: DN -> ME
            //  - DN:  nested tasks
            //  - ME:  my yield point
            
            // X1: [evt]    // must keep as is at the end bc outer bcast pops it
            
            assert(tsk2!=NULL && tsk2->type==CEU_VALUE_EXE_TASK);
            assert(act == CEU_ACTION_RESUME);
            
            if (tsk2->status == CEU_EXE_STATUS_TERMINATED) {
                return 0;
            }
            
            ceu_gc_inc_dyn((CEU_Dyn*) tsk2);
            int ret = 0; // !=0 means error

            // DN
            if (act==CEU_ACTION_RESUME && tsk2->status==CEU_EXE_STATUS_TOGGLED) {
                // do nothing
            } else {
                ret = ceu_bcast_tasks(X1, act, now, (CEU_Dyn*) tsk2);
            }

            // ME
            if (tsk2->status != CEU_EXE_STATUS_YIELDED) {
                // do nothing
            } else if (tsk2 == &CEU_GLOBAL_TASK) {
                // do nothing
            } else {
                // either handle error or event
                // never both
                // even if error is caught, should not awake from past event
                if (ret != 0) {
                    // catch error from blocks above
                    assert(CEU_ERROR_IS(X1->S));
                    // [evt, (ret,err)]
                    ceux_push(X1->S, 1, ceu_dyn_to_val((CEU_Dyn*)tsk2));
                    int err = XX1(-ret-1);
                    ceux_dup_n(X1->S, err, ret);
                    // [evt, (ret,err), tsk, (ret,err)]
                    int ret2 = ceux_resume(X1, ret, 0, CEU_ACTION_ERROR, now);
                    if (ret2 == 0) {
                        ceux_pop_n(X1->S, ret);
                        // [evt]
                    } else {
                        // [evt, (ret,err)]
                    }
                    ret = ret2;
                } else if (tsk2->pc==0 || now>tsk2->time) {
                    // [evt]
                    ceux_push(X1->S, 1, ceu_dyn_to_val((CEU_Dyn*)tsk2));
                    ceux_dup(X1->S, XX1(-2));
                    // [evt,tsk,evt]
                    ret = ceux_resume(X1, 1 /* TODO-MULTI */, 0, CEU_ACTION_RESUME, now);
                    // [evt]
                }
            }
            
            ceu_gc_dec_dyn((CEU_Dyn*) tsk2);
            return ret;
        }

        int ceu_broadcast_global (void) {
            assert(CEU_TIME < UINT32_MAX);
            CEU_TIME++;
            int ret = ceu_bcast_tasks(CEU_GLOBAL_X, CEU_ACTION_RESUME, CEU_TIME, (CEU_Dyn*) &CEU_GLOBAL_TASK);
            return ret;
        }
        
        int ceu_broadcast_plic__f (CEUX* X) {
            assert(X->args == 2);
            //ceu_bstk_assert(bstk);

            assert(CEU_TIME < UINT32_MAX);
            CEU_TIME++;

            CEU_Value xin = ceux_peek(X->S, ceux_arg(X,0));
            int ret;
            if (xin.type == CEU_VALUE_TAG) {
                if (xin.Tag == CEU_TAG_global) {
                    ret = ceu_bcast_tasks(X, CEU_ACTION_RESUME, CEU_TIME, (CEU_Dyn*) &CEU_GLOBAL_TASK);
                } else if (xin.Tag == CEU_TAG_task) {
                    if (X->exe_task == NULL) {
                        ret = ceu_bcast_tasks(X, CEU_ACTION_RESUME, CEU_TIME, (CEU_Dyn*) &CEU_GLOBAL_TASK);
                    } else {
                        ret = ceu_bcast_task(X, CEU_ACTION_RESUME, CEU_TIME, X->exe_task);
                    }
                } else {
                    ret = ceu_error_s(X->S, "broadcast error : invalid target");
                }
            } else {
                if (ceu_istask_val(xin)) {
                    if (xin.Dyn->Exe_Task.status == CEU_EXE_STATUS_TERMINATED) {
                        ret = 0;
                    } else {
                        ret = ceu_bcast_task(X, CEU_ACTION_RESUME, CEU_TIME, &xin.Dyn->Exe_Task);
                    }
                } else {
                    ret = ceu_error_s(X->S, "broadcast error : invalid target");
                }
            }

            return ret;
        }
        #endif
    
        #if CEU >= 5
        int ceu_next_dash_tasks_f (CEUX* X) {
            assert(X->args==1 || X->args==2);
            CEU_Value tsks = ceux_peek(X->S, ceux_arg(X,0));
            if (tsks.type != CEU_VALUE_TASKS) {
                return ceu_error_s(X->S, "next-tasks error : expected tasks");
            }
            CEU_Value key = (X->args == 1) ? ((CEU_Value) { CEU_VALUE_NIL }) : ceux_peek(X->S,ceux_arg(X,1));
            CEU_Dyn* nxt = NULL;
            switch (key.type) {
                case CEU_VALUE_NIL:
                    nxt = tsks.Dyn->Tasks.lnks.dn.fst;
                    break;
                case CEU_VALUE_EXE_TASK:
                    nxt = key.Dyn->Exe_Task.lnks.sd.nxt;
                    break;
                default:
                    return ceu_error_s(X->S, "next-tasks error : expected task");
            }
            if (nxt == NULL) {
                ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
            } else {
                ceux_push(X->S, 1, ceu_dyn_to_val(nxt));
            }
            return 1;
        }
        int ceu_tasks_f (CEUX* X) {
            assert(X->args <= 1);
            int max = 0;
            if (X->args == 1) {
                CEU_Value xmax = ceux_peek(X->S, ceux_arg(X,0));
                if (xmax.type!=CEU_VALUE_NUMBER || xmax.Number<=0) {                
                    return ceu_error_s(X->S, "tasks error : expected positive number");
                }
                max = xmax.Number;
            }
            CEU_Value ret = ceu_create_tasks(max, ceu_up_tsk(X), ceu_up_blk(X->S));
            ceux_push(X->S, 1, ret);
            return 1;
        }
        #endif
    
    
                    // PROTO | (prelude.ceu : lin 3 : col 1) | (func (v) pri
                    int ceu_f_debug (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 3 : col 16) | println(v)v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 4 : col 5) | println(v)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 4) /* global println */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 4, col 5) : println(v)");
            
        
                } // CALL | (prelude.ceu : lin 4 : col 5) | println(v)
                ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 3 : col 16) | println(v)v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 12 : col 5) | (func (v1,v2) 
                    int ceu_f_plus (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 12 : col 25) | if do (val 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 13 : col 9) | if do (val ce
                    
                { // BLOCK | (prelude.ceu : lin 14 : col 21) | do (val ceu_7
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 15 : col 25) | (val ceu_77 = 
                
                    
                { // CALL | (prelude.ceu : lin 13 : col 22) | /=(type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 15) /* global {{/=}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 13 : col 13) | type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 13, col 13) : type(v1)");
            
        
                } // CALL | (prelude.ceu : lin 13 : col 13) | type(v1)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_number} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 13, col 22) : {{/=}}(type(v1),:number)");
            
        
                } // CALL | (prelude.ceu : lin 13 : col 22) | /=(type(v1)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_77 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 15 : col 25) | (val ceu_77 = )
        
            
                { // IF | (prelude.ceu : lin 14 : col 25) | if ceu_77 ceu
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_77 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 14 : col 35) | ceu_77
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_77 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 14 : col 35) | ceu_77
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 16 : col 32) | /=(type(v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 13 : col 47) | /=(type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 15) /* global {{/=}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 13 : col 38) | type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 13, col 38) : type(v2)");
            
        
                } // CALL | (prelude.ceu : lin 13 : col 38) | type(v2)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_number} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 13, col 47) : {{/=}}(type(v2),:number)");
            
        
                } // CALL | (prelude.ceu : lin 13 : col 47) | /=(type(v2)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 16 : col 32) | /=(type(v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 14 : col 21) | do (val ceu_7
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 13 : col 59) | error(:error)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 14 : col 13) | error(:error)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 1) /* global error */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_error} });
                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 14, col 13) : error(:error)");
            
        
                } // CALL | (prelude.ceu : lin 14 : col 13) | error(:error)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 13 : col 59) | error(:error)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 13 : col 9) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 13 : col 9) | nil)
        
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 13 : col 9) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(  ((ceux_peek(X->S,ceux_arg(X, 0) /* arg v1 */)).Number + (ceux_peek(X->S,ceux_arg(X, 1) /* arg v2 */)).Number))} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 12 : col 25) | if do (val 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 19 : col 5) | (func (v1,v2) 
                    int ceu_f_minus (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 19 : col 25) | do if do 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (prelude.ceu : lin 25 : col 21) | do if do (v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 29 : col 29) | if do (val ce
                    
                { // BLOCK | (prelude.ceu : lin 22 : col 21) | do (val ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 23 : col 25) | (val ceu_285 = 
                
                    
                { // CALL | (prelude.ceu : lin 21 : col 23) | ==(type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 21 : col 14) | type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 21, col 14) : type(v1)");
            
        
                } // CALL | (prelude.ceu : lin 21 : col 14) | type(v1)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_number} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 21, col 23) : {{==}}(type(v1),:number)");
            
        
                } // CALL | (prelude.ceu : lin 21 : col 23) | ==(type(v1)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_285 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 23 : col 25) | (val ceu_285 = )
        
            
                { // IF | (prelude.ceu : lin 22 : col 25) | if ceu_285 
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_285 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 22 : col 36) | ==(v2,nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 21 : col 43) | ==(v2,nil)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 21, col 43) : {{==}}(v2,nil)");
            
        
                } // CALL | (prelude.ceu : lin 21 : col 43) | ==(v2,nil)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 22 : col 36) | ==(v2,nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 22 : col 32) | ceu_285
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_285 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 22 : col 32) | ceu_285
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 22 : col 21) | do (val ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 25 : col 3) | ```:number   
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(   (- (ceux_peek(X->S,ceux_arg(X, 0) /* arg v1 */)).Number))} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 25 : col 3) | ```:number   
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 23 : col 36) | if do (val 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 26 : col 29) | if do (val ce
                    
                { // BLOCK | (prelude.ceu : lin 23 : col 21) | do (val ceu_3
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 24 : col 25) | (val ceu_365 = 
                
                    
                { // CALL | (prelude.ceu : lin 22 : col 23) | /=(type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 15) /* global {{/=}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 22 : col 14) | type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 22, col 14) : type(v1)");
            
        
                } // CALL | (prelude.ceu : lin 22 : col 14) | type(v1)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_number} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 22, col 23) : {{/=}}(type(v1),:number)");
            
        
                } // CALL | (prelude.ceu : lin 22 : col 23) | /=(type(v1)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_365 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 24 : col 25) | (val ceu_365 = )
        
            
                { // IF | (prelude.ceu : lin 23 : col 25) | if ceu_365 ce
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_365 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 23 : col 36) | ceu_365
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_365 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 23 : col 36) | ceu_365
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 25 : col 32) | /=(type(v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 22 : col 49) | /=(type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 15) /* global {{/=}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 22 : col 40) | type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 22, col 40) : type(v2)");
            
        
                } // CALL | (prelude.ceu : lin 22 : col 40) | type(v2)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_number} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 22, col 49) : {{/=}}(type(v2),:number)");
            
        
                } // CALL | (prelude.ceu : lin 22 : col 49) | /=(type(v2)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 25 : col 32) | /=(type(v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 23 : col 21) | do (val ceu_3
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 24 : col 3) | error(:error)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 22 : col 64) | error(:error)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 1) /* global error */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_error} });
                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 22, col 64) : error(:error)");
            
        
                } // CALL | (prelude.ceu : lin 22 : col 64) | error(:error)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 24 : col 3) | error(:error)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 24 : col 36) | if true ```
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 27 : col 29) | if true ```:n
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 23 : col 18) | ```:number   
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(   ((ceux_peek(X->S,ceux_arg(X, 0) /* arg v1 */)).Number - (ceux_peek(X->S,ceux_arg(X, 1) /* arg v2 */)).Number))} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 23 : col 18) | ```:number   
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 25 : col 36) | (do nil)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        // PASS | (prelude.ceu : lin 25 : col 36) | (do nil)
ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 25 : col 36) | (do nil)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 24 : col 36) | if true ```
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 23 : col 36) | if do (val 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 25 : col 21) | do if do (v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 19 : col 25) | do if do 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 27 : col 5) | (func (v1,v2) 
                    int ceu_f_asterisk (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 27 : col 25) | if do (val 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 28 : col 9) | if do (val ce
                    
                { // BLOCK | (prelude.ceu : lin 29 : col 21) | do (val ceu_8
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 30 : col 25) | (val ceu_807 = 
                
                    
                { // CALL | (prelude.ceu : lin 28 : col 22) | /=(type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 15) /* global {{/=}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 28 : col 13) | type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 28, col 13) : type(v1)");
            
        
                } // CALL | (prelude.ceu : lin 28 : col 13) | type(v1)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_number} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 28, col 22) : {{/=}}(type(v1),:number)");
            
        
                } // CALL | (prelude.ceu : lin 28 : col 22) | /=(type(v1)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_807 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 30 : col 25) | (val ceu_807 = )
        
            
                { // IF | (prelude.ceu : lin 29 : col 25) | if ceu_807 ce
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_807 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 29 : col 36) | ceu_807
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_807 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 29 : col 36) | ceu_807
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 31 : col 32) | /=(type(v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 28 : col 47) | /=(type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 15) /* global {{/=}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 28 : col 38) | type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 28, col 38) : type(v2)");
            
        
                } // CALL | (prelude.ceu : lin 28 : col 38) | type(v2)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_number} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 28, col 47) : {{/=}}(type(v2),:number)");
            
        
                } // CALL | (prelude.ceu : lin 28 : col 47) | /=(type(v2)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 31 : col 32) | /=(type(v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 29 : col 21) | do (val ceu_8
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 28 : col 59) | error(:error)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 29 : col 13) | error(:error)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 1) /* global error */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_error} });
                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 29, col 13) : error(:error)");
            
        
                } // CALL | (prelude.ceu : lin 29 : col 13) | error(:error)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 28 : col 59) | error(:error)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 28 : col 9) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 28 : col 9) | nil)
        
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 28 : col 9) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(  ((ceux_peek(X->S,ceux_arg(X, 0) /* arg v1 */)).Number * (ceux_peek(X->S,ceux_arg(X, 1) /* arg v2 */)).Number))} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 27 : col 25) | if do (val 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 34 : col 5) | (func (v1,v2) 
                    int ceu_f_asterisk_asterisk (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 34 : col 26) | if do (val 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 35 : col 9) | if do (val ce
                    
                { // BLOCK | (prelude.ceu : lin 36 : col 21) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 37 : col 25) | (val ceu_1014 =
                
                    
                { // CALL | (prelude.ceu : lin 35 : col 22) | /=(type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 15) /* global {{/=}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 35 : col 13) | type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 35, col 13) : type(v1)");
            
        
                } // CALL | (prelude.ceu : lin 35 : col 13) | type(v1)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_number} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 35, col 22) : {{/=}}(type(v1),:number)");
            
        
                } // CALL | (prelude.ceu : lin 35 : col 22) | /=(type(v1)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_1014 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 37 : col 25) | (val ceu_1014 =)
        
            
                { // IF | (prelude.ceu : lin 36 : col 25) | if ceu_1014 c
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_1014 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 36 : col 37) | ceu_1014
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_1014 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 36 : col 37) | ceu_1014
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 38 : col 32) | /=(type(v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 35 : col 47) | /=(type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 15) /* global {{/=}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 35 : col 38) | type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 35, col 38) : type(v2)");
            
        
                } // CALL | (prelude.ceu : lin 35 : col 38) | type(v2)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_number} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 35, col 47) : {{/=}}(type(v2),:number)");
            
        
                } // CALL | (prelude.ceu : lin 35 : col 47) | /=(type(v2)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 38 : col 32) | /=(type(v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 36 : col 21) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 35 : col 59) | error(:error)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 36 : col 13) | error(:error)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 1) /* global error */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_error} });
                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 36, col 13) : error(:error)");
            
        
                } // CALL | (prelude.ceu : lin 36 : col 13) | error(:error)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 35 : col 59) | error(:error)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 35 : col 9) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 35 : col 9) | nil)
        
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 35 : col 9) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(  powf((ceux_peek(X->S,ceux_arg(X, 0) /* arg v1 */)).Number, (ceux_peek(X->S,ceux_arg(X, 1) /* arg v2 */)).Number))} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 34 : col 26) | if do (val 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 41 : col 5) | (func (v1,v2) 
                    int ceu_f_slash (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 41 : col 25) | if do (val 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 42 : col 9) | if do (val ce
                    
                { // BLOCK | (prelude.ceu : lin 43 : col 21) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 44 : col 25) | (val ceu_1221 =
                
                    
                { // CALL | (prelude.ceu : lin 42 : col 22) | /=(type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 15) /* global {{/=}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 42 : col 13) | type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 42, col 13) : type(v1)");
            
        
                } // CALL | (prelude.ceu : lin 42 : col 13) | type(v1)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_number} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 42, col 22) : {{/=}}(type(v1),:number)");
            
        
                } // CALL | (prelude.ceu : lin 42 : col 22) | /=(type(v1)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_1221 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 44 : col 25) | (val ceu_1221 =)
        
            
                { // IF | (prelude.ceu : lin 43 : col 25) | if ceu_1221 c
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_1221 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 43 : col 37) | ceu_1221
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_1221 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 43 : col 37) | ceu_1221
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 45 : col 32) | /=(type(v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 42 : col 47) | /=(type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 15) /* global {{/=}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 42 : col 38) | type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 42, col 38) : type(v2)");
            
        
                } // CALL | (prelude.ceu : lin 42 : col 38) | type(v2)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_number} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 42, col 47) : {{/=}}(type(v2),:number)");
            
        
                } // CALL | (prelude.ceu : lin 42 : col 47) | /=(type(v2)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 45 : col 32) | /=(type(v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 43 : col 21) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 42 : col 59) | error(:error)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 43 : col 13) | error(:error)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 1) /* global error */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_error} });
                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 43, col 13) : error(:error)");
            
        
                } // CALL | (prelude.ceu : lin 43 : col 13) | error(:error)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 42 : col 59) | error(:error)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 42 : col 9) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 42 : col 9) | nil)
        
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 42 : col 9) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(  ((ceux_peek(X->S,ceux_arg(X, 0) /* arg v1 */)).Number / (ceux_peek(X->S,ceux_arg(X, 1) /* arg v2 */)).Number))} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 41 : col 25) | if do (val 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 48 : col 5) | (func (v1,v2) 
                    int ceu_f_slash_slash (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 48 : col 26) | if do (val 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 49 : col 9) | if do (val ce
                    
                { // BLOCK | (prelude.ceu : lin 50 : col 21) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 51 : col 25) | (val ceu_1428 =
                
                    
                { // CALL | (prelude.ceu : lin 49 : col 22) | /=(type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 15) /* global {{/=}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 49 : col 13) | type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 49, col 13) : type(v1)");
            
        
                } // CALL | (prelude.ceu : lin 49 : col 13) | type(v1)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_number} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 49, col 22) : {{/=}}(type(v1),:number)");
            
        
                } // CALL | (prelude.ceu : lin 49 : col 22) | /=(type(v1)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_1428 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 51 : col 25) | (val ceu_1428 =)
        
            
                { // IF | (prelude.ceu : lin 50 : col 25) | if ceu_1428 c
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_1428 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 50 : col 37) | ceu_1428
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_1428 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 50 : col 37) | ceu_1428
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 52 : col 32) | /=(type(v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 49 : col 47) | /=(type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 15) /* global {{/=}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 49 : col 38) | type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 49, col 38) : type(v2)");
            
        
                } // CALL | (prelude.ceu : lin 49 : col 38) | type(v2)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_number} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 49, col 47) : {{/=}}(type(v2),:number)");
            
        
                } // CALL | (prelude.ceu : lin 49 : col 47) | /=(type(v2)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 52 : col 32) | /=(type(v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 50 : col 21) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 49 : col 59) | error(:error)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 50 : col 13) | error(:error)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 1) /* global error */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_error} });
                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 50, col 13) : error(:error)");
            
        
                } // CALL | (prelude.ceu : lin 50 : col 13) | error(:error)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 49 : col 59) | error(:error)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 49 : col 9) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 49 : col 9) | nil)
        
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 49 : col 9) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(  powf((ceux_peek(X->S,ceux_arg(X, 0) /* arg v1 */)).Number, 1/(ceux_peek(X->S,ceux_arg(X, 1) /* arg v2 */)).Number))} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 48 : col 26) | if do (val 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 55 : col 5) | (func (v1,v2) 
                    int ceu_f_null (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 55 : col 25) | if do (val 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 56 : col 9) | if do (val ce
                    
                { // BLOCK | (prelude.ceu : lin 57 : col 21) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 58 : col 25) | (val ceu_1635 =
                
                    
                { // CALL | (prelude.ceu : lin 56 : col 22) | /=(type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 15) /* global {{/=}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 56 : col 13) | type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 56, col 13) : type(v1)");
            
        
                } // CALL | (prelude.ceu : lin 56 : col 13) | type(v1)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_number} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 56, col 22) : {{/=}}(type(v1),:number)");
            
        
                } // CALL | (prelude.ceu : lin 56 : col 22) | /=(type(v1)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_1635 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 58 : col 25) | (val ceu_1635 =)
        
            
                { // IF | (prelude.ceu : lin 57 : col 25) | if ceu_1635 c
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_1635 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 57 : col 37) | ceu_1635
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_1635 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 57 : col 37) | ceu_1635
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 59 : col 32) | /=(type(v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 56 : col 47) | /=(type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 15) /* global {{/=}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 56 : col 38) | type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 56, col 38) : type(v2)");
            
        
                } // CALL | (prelude.ceu : lin 56 : col 38) | type(v2)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_number} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 56, col 47) : {{/=}}(type(v2),:number)");
            
        
                } // CALL | (prelude.ceu : lin 56 : col 47) | /=(type(v2)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 59 : col 32) | /=(type(v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 57 : col 21) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 56 : col 59) | error(:error)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 57 : col 13) | error(:error)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 1) /* global error */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_error} });
                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 57, col 13) : error(:error)");
            
        
                } // CALL | (prelude.ceu : lin 57 : col 13) | error(:error)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 56 : col 59) | error(:error)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 56 : col 9) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 56 : col 9) | nil)
        
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 56 : col 9) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(  fmod((ceux_peek(X->S,ceux_arg(X, 0) /* arg v1 */)).Number, (ceux_peek(X->S,ceux_arg(X, 1) /* arg v2 */)).Number))} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 55 : col 25) | if do (val 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 66 : col 5) | (func (v1,v2) 
                    int ceu_f_greater (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 66 : col 24) | do if do 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (prelude.ceu : lin 72 : col 21) | do if do (v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 76 : col 29) | if do (val ce
                    
                { // BLOCK | (prelude.ceu : lin 69 : col 21) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 70 : col 25) | (val ceu_1843 =
                
                    
                { // CALL | (prelude.ceu : lin 68 : col 23) | ==(type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 68 : col 14) | type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 68, col 14) : type(v1)");
            
        
                } // CALL | (prelude.ceu : lin 68 : col 14) | type(v1)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_tag} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 68, col 23) : {{==}}(type(v1),:tag)");
            
        
                } // CALL | (prelude.ceu : lin 68 : col 23) | ==(type(v1)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_1843 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 70 : col 25) | (val ceu_1843 =)
        
            
                { // IF | (prelude.ceu : lin 69 : col 25) | if ceu_1843 
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_1843 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 69 : col 37) | ==(type(v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 68 : col 49) | ==(type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 68 : col 40) | type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 68, col 40) : type(v2)");
            
        
                } // CALL | (prelude.ceu : lin 68 : col 40) | type(v2)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_tag} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 68, col 49) : {{==}}(type(v2),:tag)");
            
        
                } // CALL | (prelude.ceu : lin 68 : col 49) | ==(type(v2)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 69 : col 37) | ==(type(v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 69 : col 32) | ceu_1843
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_1843 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 69 : col 32) | ceu_1843
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 69 : col 21) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 72 : col 3) | ```:bool    (
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_BOOL, {.Bool=(   ((ceux_peek(X->S,ceux_arg(X, 0) /* arg v1 */)).Tag    > (ceux_peek(X->S,ceux_arg(X, 1) /* arg v2 */)).Tag))} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 72 : col 3) | ```:bool    (
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 70 : col 36) | if do (val 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 73 : col 29) | if do (val ce
                    
                { // BLOCK | (prelude.ceu : lin 70 : col 21) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 71 : col 25) | (val ceu_1933 =
                
                    
                { // CALL | (prelude.ceu : lin 69 : col 23) | ==(type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 69 : col 14) | type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 69, col 14) : type(v1)");
            
        
                } // CALL | (prelude.ceu : lin 69 : col 14) | type(v1)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_number} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 69, col 23) : {{==}}(type(v1),:number)");
            
        
                } // CALL | (prelude.ceu : lin 69 : col 23) | ==(type(v1)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_1933 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 71 : col 25) | (val ceu_1933 =)
        
            
                { // IF | (prelude.ceu : lin 70 : col 25) | if ceu_1933 
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_1933 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 70 : col 37) | ==(type(v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 69 : col 49) | ==(type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 69 : col 40) | type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 69, col 40) : type(v2)");
            
        
                } // CALL | (prelude.ceu : lin 69 : col 40) | type(v2)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_number} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 69, col 49) : {{==}}(type(v2),:number)");
            
        
                } // CALL | (prelude.ceu : lin 69 : col 49) | ==(type(v2)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 70 : col 37) | ==(type(v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 70 : col 32) | ceu_1933
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_1933 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 70 : col 32) | ceu_1933
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 70 : col 21) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 73 : col 3) | ```:bool    (
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_BOOL, {.Bool=(   ((ceux_peek(X->S,ceux_arg(X, 0) /* arg v1 */)).Number > (ceux_peek(X->S,ceux_arg(X, 1) /* arg v2 */)).Number))} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 73 : col 3) | ```:bool    (
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 71 : col 36) | if true err
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 74 : col 29) | if true error
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 70 : col 18) | error(:error)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 70 : col 21) | error(:error)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 1) /* global error */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_error} });
                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 70, col 21) : error(:error)");
            
        
                } // CALL | (prelude.ceu : lin 70 : col 21) | error(:error)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 70 : col 18) | error(:error)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 72 : col 36) | (do nil)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        // PASS | (prelude.ceu : lin 72 : col 36) | (do nil)
ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 72 : col 36) | (do nil)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 71 : col 36) | if true err
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 70 : col 36) | if do (val 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 72 : col 21) | do if do (v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 66 : col 24) | do if do 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 74 : col 5) | (func (v1,v2) 
                    int ceu_f_less (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 74 : col 24) | if do (val 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 75 : col 10) | if do (val ce
                    
                { // BLOCK | (prelude.ceu : lin 76 : col 21) | do (val ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 77 : col 25) | (val ceu_2381 =
                
                    
                { // CALL | (prelude.ceu : lin 75 : col 18) | ==(v1,v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 75, col 18) : {{==}}(v1,v2)");
            
        
                } // CALL | (prelude.ceu : lin 75 : col 18) | ==(v1,v2)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_2381 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 77 : col 25) | (val ceu_2381 =)
        
            
                { // IF | (prelude.ceu : lin 76 : col 25) | if ceu_2381 c
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_2381 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 76 : col 37) | ceu_2381
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_2381 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 76 : col 37) | ceu_2381
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 78 : col 32) | >(v1,v2)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 75 : col 32) | >(v1,v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 29) /* global {{>}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 75, col 32) : {{>}}(v1,v2)");
            
        
                } // CALL | (prelude.ceu : lin 75 : col 32) | >(v1,v2)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 78 : col 32) | >(v1,v2)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 76 : col 21) | do (val ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 77 : col 3) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 77 : col 3) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 77 : col 18) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 77 : col 18) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 74 : col 24) | if do (val 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 78 : col 5) | (func (v1,v2) 
                    int ceu_f_greater_equals (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 78 : col 25) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (prelude.ceu : lin 80 : col 21) | do (val ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 81 : col 25) | (val ceu_2597 =
                
                    
                { // CALL | (prelude.ceu : lin 79 : col 13) | ==(v1,v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 79, col 13) : {{==}}(v1,v2)");
            
        
                } // CALL | (prelude.ceu : lin 79 : col 13) | ==(v1,v2)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_2597 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 81 : col 25) | (val ceu_2597 =)
        
            
                { // IF | (prelude.ceu : lin 80 : col 25) | if ceu_2597 c
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_2597 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 80 : col 37) | ceu_2597
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_2597 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 80 : col 37) | ceu_2597
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 82 : col 32) | >(v1,v2)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 79 : col 27) | >(v1,v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 29) /* global {{>}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 79, col 27) : {{>}}(v1,v2)");
            
        
                } // CALL | (prelude.ceu : lin 79 : col 27) | >(v1,v2)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 82 : col 32) | >(v1,v2)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 80 : col 21) | do (val ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 78 : col 25) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 82 : col 5) | (func (v1,v2) 
                    int ceu_f_less_equals (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 82 : col 25) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (prelude.ceu : lin 84 : col 21) | do (val ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 85 : col 25) | (val ceu_2737 =
                
                    
                { // CALL | (prelude.ceu : lin 83 : col 13) | ==(v1,v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 83, col 13) : {{==}}(v1,v2)");
            
        
                } // CALL | (prelude.ceu : lin 83 : col 13) | ==(v1,v2)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_2737 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 85 : col 25) | (val ceu_2737 =)
        
            
                { // IF | (prelude.ceu : lin 84 : col 25) | if ceu_2737 c
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_2737 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 84 : col 37) | ceu_2737
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_2737 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 84 : col 37) | ceu_2737
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 86 : col 32) | <(v1,v2)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 83 : col 27) | <(v1,v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 30) /* global {{<}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 83, col 27) : {{<}}(v1,v2)");
            
        
                } // CALL | (prelude.ceu : lin 83 : col 27) | <(v1,v2)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 86 : col 32) | <(v1,v2)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 84 : col 21) | do (val ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 82 : col 25) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 89 : col 1) | (func (v,msg) 
                    int ceu_f_assert (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 89 : col 22) | if if v fal
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 90 : col 5) | if if v false
                    
                { // IF | (prelude.ceu : lin 90 : col 9) | if v false 
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 90 : col 14) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 90 : col 14) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 90 : col 29) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 90 : col 29) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 90 : col 14) | if msg prin
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 91 : col 9) | if msg print(
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg msg */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 91 : col 16) | print(#['a','
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 92 : col 13) | print(#['a','s'
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 3) /* global print */));

                    
                        
                { // VECTOR | (prelude.ceu : lin 92 : col 19) | #['a','s','s','
                    ceux_push(X->S, 1, ceu_create_vector());
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='a'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='s'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='s'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 2, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='e'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 3, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='r'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 4, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='t'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 5, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='i'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 6, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='o'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 7, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='n'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 8, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char=' '} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 9, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='e'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 10, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='r'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 11, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='r'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 12, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='o'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 13, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='r'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 14, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char=' '} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 15, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char=':'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 16, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char=' '} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 17, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 92, col 13) : print(#['a','s','s','e','r','t','i','o','n','...)");
            
        
                } // CALL | (prelude.ceu : lin 92 : col 13) | print(#['a','s'
                
                { // CALL | (prelude.ceu : lin 93 : col 13) | println(msg)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 4) /* global println */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg msg */));

                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 93, col 13) : println(msg)");
            
        
                } // CALL | (prelude.ceu : lin 93 : col 13) | println(msg)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 91 : col 16) | print(#['a','
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 91 : col 9) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 91 : col 9) | nil)
        
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 91 : col 9) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                { // CALL | (prelude.ceu : lin 95 : col 9) | error(:assert)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 1) /* global error */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_assert} });
                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 95, col 9) : error(:assert)");
            
        
                } // CALL | (prelude.ceu : lin 95 : col 9) | error(:assert)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 90 : col 14) | if msg prin
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 90 : col 5) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 90 : col 5) | nil)
        
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 90 : col 5) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 89 : col 22) | if if v fal
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 102 : col 1) | (func (t1,t2) 
                    int ceu_f_tag_dash_or (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 102 : col 21) | assert(==
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 103 : col 5) | assert(==(t
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 33) /* global assert */));

                    
                        
                { // CALL | (prelude.ceu : lin 103 : col 21) | ==(type(t1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 103 : col 12) | type(t1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg t1 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 103, col 12) : type(t1)");
            
        
                } // CALL | (prelude.ceu : lin 103 : col 12) | type(t1)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_tag} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 103, col 21) : {{==}}(type(t1),:tag)");
            
        
                } // CALL | (prelude.ceu : lin 103 : col 21) | ==(type(t1)
                
                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 103, col 5) : assert({{==}}(type(t1),:tag))");
            
        
                } // CALL | (prelude.ceu : lin 103 : col 5) | assert(==(t
                
                { // CALL | (prelude.ceu : lin 104 : col 5) | assert(==(t
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 33) /* global assert */));

                    
                        
                { // CALL | (prelude.ceu : lin 104 : col 21) | ==(type(t2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 104 : col 12) | type(t2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg t2 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 104, col 12) : type(t2)");
            
        
                } // CALL | (prelude.ceu : lin 104 : col 12) | type(t2)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_tag} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 104, col 21) : {{==}}(type(t2),:tag)");
            
        
                } // CALL | (prelude.ceu : lin 104 : col 21) | ==(type(t2)
                
                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 104, col 5) : assert({{==}}(type(t2),:tag))");
            
        
                } // CALL | (prelude.ceu : lin 104 : col 5) | assert(==(t
                ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_TAG, {.Tag=(  (ceux_peek(X->S,ceux_arg(X, 0) /* arg t1 */)).Tag | (ceux_peek(X->S,ceux_arg(X, 1) /* arg t2 */)).Tag)} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 102 : col 21) | assert(==
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 112 : col 1) | (func (v1,v2) 
                    int ceu_f_min (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 112 : col 19) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (prelude.ceu : lin 114 : col 21) | do (val ceu_3
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 115 : col 25) | (val ceu_3293 =
                
                    
                { // BLOCK | (prelude.ceu : lin 114 : col 21) | do (val ceu_3
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 115 : col 25) | (val ceu_3252 =
                
                    
                { // CALL | (prelude.ceu : lin 113 : col 10) | <(v1,v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 30) /* global {{<}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 113, col 10) : {{<}}(v1,v2)");
            
        
                } // CALL | (prelude.ceu : lin 113 : col 10) | <(v1,v2)
                
                    ceux_copy(X->S, (X->base + 0 + 1 + 0) /* local ceu_3252 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 115 : col 25) | (val ceu_3252 =)
        
            
                { // IF | (prelude.ceu : lin 114 : col 25) | if ceu_3252 v
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_3252 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 114 : col 37) | v1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 114 : col 37) | v1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 114 : col 32) | ceu_3252
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_3252 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 114 : col 32) | ceu_3252
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 114 : col 21) | do (val ceu_3
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_3293 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 115 : col 25) | (val ceu_3293 =)
        
            
                { // IF | (prelude.ceu : lin 118 : col 25) | if ceu_3293 c
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_3293 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 118 : col 37) | ceu_3293
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_3293 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 118 : col 37) | ceu_3293
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 120 : col 32) | v2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 120 : col 32) | v2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 114 : col 21) | do (val ceu_3
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 112 : col 19) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 116 : col 1) | (func (v1,v2) 
                    int ceu_f_max (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 116 : col 19) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (prelude.ceu : lin 118 : col 21) | do (val ceu_3
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 119 : col 25) | (val ceu_3503 =
                
                    
                { // BLOCK | (prelude.ceu : lin 118 : col 21) | do (val ceu_3
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 119 : col 25) | (val ceu_3462 =
                
                    
                { // CALL | (prelude.ceu : lin 117 : col 10) | >(v1,v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 29) /* global {{>}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 117, col 10) : {{>}}(v1,v2)");
            
        
                } // CALL | (prelude.ceu : lin 117 : col 10) | >(v1,v2)
                
                    ceux_copy(X->S, (X->base + 0 + 1 + 0) /* local ceu_3462 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 119 : col 25) | (val ceu_3462 =)
        
            
                { // IF | (prelude.ceu : lin 118 : col 25) | if ceu_3462 v
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_3462 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 118 : col 37) | v1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 118 : col 37) | v1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 118 : col 32) | ceu_3462
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_3462 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 118 : col 32) | ceu_3462
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 118 : col 21) | do (val ceu_3
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_3503 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 119 : col 25) | (val ceu_3503 =)
        
            
                { // IF | (prelude.ceu : lin 122 : col 25) | if ceu_3503 c
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_3503 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 122 : col 37) | ceu_3503
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_3503 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 122 : col 37) | ceu_3503
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 124 : col 32) | v2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 124 : col 32) | v2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 118 : col 21) | do (val ceu_3
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 116 : col 19) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 120 : col 1) | (func (min_max,
                    int ceu_f_between (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 120 : col 27) | max(min_max[0
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 121 : col 5) | max(min_max[0],
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 36) /* global max */));

                    
                        
                { // INDEX | (prelude.ceu : lin 121 : col 9) | min_max[0]
                    // IDX
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg min_max */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 121, col 9) : min_max[0]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 121, col 9) : min_max[0]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        
                { // CALL | (prelude.ceu : lin 121 : col 21) | min(min_max[1],
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 35) /* global min */));

                    
                        
                { // INDEX | (prelude.ceu : lin 121 : col 25) | min_max[1]
                    // IDX
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg min_max */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 121, col 25) : min_max[1]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 121, col 25) : min_max[1]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 121, col 21) : min(min_max[1],v)");
            
        
                } // CALL | (prelude.ceu : lin 121 : col 21) | min(min_max[1],
                
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 121, col 5) : max(min_max[0],min(min_max[1],v))");
            
        
                } // CALL | (prelude.ceu : lin 121 : col 5) | max(min_max[0],
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 120 : col 27) | max(min_max[0
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 131 : col 5) | (func (itr :Ite
                    int ceu_f_iter_dash_tuple (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 131 : col 37) | (val i = itr[
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 132 : col 9) | (val i = itr[:i
                
                    
                { // INDEX | (prelude.ceu : lin 132 : col 17) | itr[:i]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=3} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 132, col 17) : itr[:i]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 132, col 17) : itr[:i]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local i */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 132 : col 9) | (val i = itr[:i)
        
            
                { // IF | (prelude.ceu : lin 133 : col 9) | if >=(i,#
                    
                { // CALL | (prelude.ceu : lin 133 : col 14) | >=(i,#(
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 31) /* global {{>=}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local i */));

                    
                        
                { // CALL | (prelude.ceu : lin 133 : col 17) | #(itr[:s])
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 13) /* global {{#}} */));

                    
                        
                { // INDEX | (prelude.ceu : lin 133 : col 18) | itr[:s]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 133, col 18) : itr[:s]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 133, col 18) : itr[:s]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 133, col 17) : {{#}}(itr[:s])");
            
        
                } // CALL | (prelude.ceu : lin 133 : col 17) | #(itr[:s])
                
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 133, col 14) : {{>=}}(i,{{#}}(itr[:s]))");
            
        
                } // CALL | (prelude.ceu : lin 133 : col 14) | >=(i,#(
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 133 : col 24) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 133 : col 24) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 135 : col 16) | (set itr[:i] 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // SET | (prelude.ceu : lin 136 : col 13) | (set itr[:i] = 
                    
                { // CALL | (prelude.ceu : lin 136 : col 27) | +(i,1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 22) /* global {{+}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local i */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 136, col 27) : {{+}}(i,1)");
            
        
                } // CALL | (prelude.ceu : lin 136 : col 27) | +(i,1)
                  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                { // INDEX | (prelude.ceu : lin 136 : col 17) | itr[:i]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=3} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 136, col 17) : itr[:i]"
                    );
                
                        {
                            CEU_Value v = ceu_col_set(ceux_peek(X->S,XX(-1)), ceux_peek(X->S,XX(-2)), ceux_peek(X->S,XX(-3)));
                            CEU_ERROR_CHK_VAL(continue, v, "prelude.ceu : (lin 136, col 17) : itr[:i]");
                            ceux_drop(X->S, 2);    // keep src
                        }
                        
                }
                  // dst should not pop src
                }
            
                // DCL | (prelude.ceu : lin 137 : col 13) | (val v = itr[:s
                
                    
                { // INDEX | (prelude.ceu : lin 137 : col 21) | itr[:s][i]
                    // IDX
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local i */));

                    
                    // COL
                    
                { // INDEX | (prelude.ceu : lin 137 : col 21) | itr[:s]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 137, col 21) : itr[:s]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 137, col 21) : itr[:s]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 137, col 21) : itr[:s][i]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 137, col 21) : itr[:s][i]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 1 + 0) /* local v */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 137 : col 13) | (val v = itr[:s)
        
            
                { // BLOCK | (prelude.ceu : lin 144 : col 21) | do (val ceu_3
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 145 : col 25) | (val ceu_3917 =
                
                    
                { // INDEX | (prelude.ceu : lin 138 : col 17) | itr[:tp]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=2} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 138, col 17) : itr[:tp]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 138, col 17) : itr[:tp]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 2 + 0) /* local ceu_3917 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 145 : col 25) | (val ceu_3917 =)
        
            
                // DCL | (prelude.ceu : lin 140 : col 29) | (val it = ceu_3
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local ceu_3917 */));

                    ceux_copy(X->S, (X->base + 0 + 2 + 1) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 140 : col 29) | (val it = ceu_3)
        
            
                { // IF | (prelude.ceu : lin 139 : col 29) | if ==(it,:a
                    
                { // CALL | (prelude.ceu : lin 139 : col 20) | ==(it,:all)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 1) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_all} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 139, col 20) : {{==}}(it,:all)");
            
        
                } // CALL | (prelude.ceu : lin 139 : col 20) | ==(it,:all)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 139 : col 26) | [i,v]
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // TUPLE | (prelude.ceu : lin 139 : col 28) | [i,v]
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local i */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local v */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 139 : col 26) | [i,v]
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 141 : col 36) | (val it = ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 143 : col 29) | (val it = ceu_3
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local ceu_3917 */));

                    ceux_copy(X->S, (X->base + 0 + 4 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 143 : col 29) | (val it = ceu_3)
        
            
                { // IF | (prelude.ceu : lin 140 : col 29) | if ==(it,:i
                    
                { // CALL | (prelude.ceu : lin 140 : col 20) | ==(it,:idx)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_idx} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 140, col 20) : {{==}}(it,:idx)");
            
        
                } // CALL | (prelude.ceu : lin 140 : col 20) | ==(it,:idx)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 140 : col 26) | i
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local i */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 140 : col 26) | i
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 142 : col 36) | (val it = ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 144 : col 29) | (val it = ceu_3
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local ceu_3917 */));

                    ceux_copy(X->S, (X->base + 0 + 5 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 144 : col 29) | (val it = ceu_3)
        
            
                { // IF | (prelude.ceu : lin 141 : col 29) | if ==(it,:v
                    
                { // CALL | (prelude.ceu : lin 141 : col 20) | ==(it,:val)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 5 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_val} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 141, col 20) : {{==}}(it,:val)");
            
        
                } // CALL | (prelude.ceu : lin 141 : col 20) | ==(it,:val)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 141 : col 26) | v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local v */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 141 : col 26) | v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 143 : col 36) | if true v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 146 : col 29) | if true v e
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 142 : col 22) | v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local v */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 142 : col 22) | v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 144 : col 36) | (do nil)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        // PASS | (prelude.ceu : lin 144 : col 36) | (do nil)
ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 144 : col 36) | (do nil)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 143 : col 36) | if true v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 142 : col 36) | (val it = ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 141 : col 36) | (val it = ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 144 : col 21) | do (val ceu_3
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 135 : col 16) | (set itr[:i] 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 131 : col 37) | (val i = itr[
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 147 : col 5) | (func (itr :Ite
                    int ceu_f_iter_dash_dict (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 147 : col 36) | (val k = next
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 148 : col 9) | (val k = next-d
                
                    
                { // CALL | (prelude.ceu : lin 148 : col 17) | next-dict(itr[:
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 2) /* global next-dict */));

                    
                        
                { // INDEX | (prelude.ceu : lin 148 : col 27) | itr[:s]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 148, col 27) : itr[:s]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 148, col 27) : itr[:s]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        
                { // INDEX | (prelude.ceu : lin 148 : col 33) | itr[:i]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=3} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 148, col 33) : itr[:i]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 148, col 33) : itr[:i]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 148, col 17) : next-dict(itr[:s],itr[:i])");
            
        
                } // CALL | (prelude.ceu : lin 148 : col 17) | next-dict(itr[:
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local k */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 148 : col 9) | (val k = next-d)
        
            
                { // IF | (prelude.ceu : lin 149 : col 9) | if ==(k,nil
                    
                { // CALL | (prelude.ceu : lin 149 : col 14) | ==(k,nil)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local k */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 149, col 14) : {{==}}(k,nil)");
            
        
                } // CALL | (prelude.ceu : lin 149 : col 14) | ==(k,nil)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 149 : col 21) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 149 : col 21) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 151 : col 16) | (set itr[:i] 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // SET | (prelude.ceu : lin 152 : col 13) | (set itr[:i] = 
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local k */));
  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                { // INDEX | (prelude.ceu : lin 152 : col 17) | itr[:i]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=3} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 152, col 17) : itr[:i]"
                    );
                
                        {
                            CEU_Value v = ceu_col_set(ceux_peek(X->S,XX(-1)), ceux_peek(X->S,XX(-2)), ceux_peek(X->S,XX(-3)));
                            CEU_ERROR_CHK_VAL(continue, v, "prelude.ceu : (lin 152, col 17) : itr[:i]");
                            ceux_drop(X->S, 2);    // keep src
                        }
                        
                }
                  // dst should not pop src
                }
            
                // DCL | (prelude.ceu : lin 153 : col 13) | (val v = itr[:s
                
                    
                { // INDEX | (prelude.ceu : lin 153 : col 21) | itr[:s][k]
                    // IDX
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local k */));

                    
                    // COL
                    
                { // INDEX | (prelude.ceu : lin 153 : col 21) | itr[:s]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 153, col 21) : itr[:s]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 153, col 21) : itr[:s]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 153, col 21) : itr[:s][k]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 153, col 21) : itr[:s][k]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 1 + 0) /* local v */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 153 : col 13) | (val v = itr[:s)
        
            
                { // BLOCK | (prelude.ceu : lin 160 : col 21) | do (val ceu_4
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 161 : col 25) | (val ceu_4438 =
                
                    
                { // INDEX | (prelude.ceu : lin 154 : col 17) | itr[:tp]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=2} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 154, col 17) : itr[:tp]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 154, col 17) : itr[:tp]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 2 + 0) /* local ceu_4438 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 161 : col 25) | (val ceu_4438 =)
        
            
                // DCL | (prelude.ceu : lin 156 : col 29) | (val it = ceu_4
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local ceu_4438 */));

                    ceux_copy(X->S, (X->base + 0 + 2 + 1) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 156 : col 29) | (val it = ceu_4)
        
            
                { // IF | (prelude.ceu : lin 155 : col 29) | if ==(it,:a
                    
                { // CALL | (prelude.ceu : lin 155 : col 20) | ==(it,:all)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 1) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_all} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 155, col 20) : {{==}}(it,:all)");
            
        
                } // CALL | (prelude.ceu : lin 155 : col 20) | ==(it,:all)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 155 : col 26) | [k,v]
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // TUPLE | (prelude.ceu : lin 155 : col 28) | [k,v]
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local k */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local v */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 155 : col 26) | [k,v]
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 157 : col 36) | (val it = ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 159 : col 29) | (val it = ceu_4
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local ceu_4438 */));

                    ceux_copy(X->S, (X->base + 0 + 4 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 159 : col 29) | (val it = ceu_4)
        
            
                { // IF | (prelude.ceu : lin 156 : col 29) | if ==(it,:k
                    
                { // CALL | (prelude.ceu : lin 156 : col 20) | ==(it,:key)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_key} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 156, col 20) : {{==}}(it,:key)");
            
        
                } // CALL | (prelude.ceu : lin 156 : col 20) | ==(it,:key)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 156 : col 26) | k
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local k */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 156 : col 26) | k
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 158 : col 36) | (val it = ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 160 : col 29) | (val it = ceu_4
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local ceu_4438 */));

                    ceux_copy(X->S, (X->base + 0 + 5 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 160 : col 29) | (val it = ceu_4)
        
            
                { // IF | (prelude.ceu : lin 157 : col 29) | if ==(it,:v
                    
                { // CALL | (prelude.ceu : lin 157 : col 20) | ==(it,:val)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 5 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_val} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 157, col 20) : {{==}}(it,:val)");
            
        
                } // CALL | (prelude.ceu : lin 157 : col 20) | ==(it,:val)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 157 : col 26) | v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local v */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 157 : col 26) | v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 159 : col 36) | if true k
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 162 : col 29) | if true k e
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 158 : col 22) | k
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local k */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 158 : col 22) | k
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 160 : col 36) | (do nil)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        // PASS | (prelude.ceu : lin 160 : col 36) | (do nil)
ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 160 : col 36) | (do nil)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 159 : col 36) | if true k
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 158 : col 36) | (val it = ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 157 : col 36) | (val it = ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 160 : col 21) | do (val ceu_4
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 151 : col 16) | (set itr[:i] 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 147 : col 36) | (val k = next
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 163 : col 5) | (func (itr :Ite
                    int ceu_f_iter_dash_xcoro (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 163 : col 37) | (val co = itr
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 164 : col 9) | (val co = itr[:
                
                    
                { // INDEX | (prelude.ceu : lin 164 : col 18) | itr[:s]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 164, col 18) : itr[:s]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 164, col 18) : itr[:s]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local co */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 164 : col 9) | (val co = itr[:)
        
            
                { // BLOCK | (prelude.ceu : lin 170 : col 25) | do (val it = 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 165 : col 28) | (val it = (resu
                
                    
                ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local co */));

                ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                ceux_resume(X, 1 /* TODO: MULTI */, 1, CEU_ACTION_RESUME CEU4(COMMA X->now));
                
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 165, col 10) : (resume (co)(nil))");
            
        
            
                    ceux_copy(X->S, (X->base + 0 + 1 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 165 : col 28) | (val it = (resu)
        
            
                { // IF | (prelude.ceu : lin 166 : col 13) | if ==(statu
                    
                { // CALL | (prelude.ceu : lin 166 : col 28) | ==(status(c
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 166 : col 17) | status(co)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 17) /* global status */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local co */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 166, col 17) : status(co)");
            
        
                } // CALL | (prelude.ceu : lin 166 : col 17) | status(co)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_terminated} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 166, col 28) : {{==}}(status(co),:terminated)");
            
        
                } // CALL | (prelude.ceu : lin 166 : col 28) | ==(status(c
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 167 : col 17) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 167 : col 17) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 168 : col 17) | it
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local it */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 168 : col 17) | it
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 170 : col 25) | do (val it = 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 163 : col 37) | (val co = itr
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 172 : col 5) | (func (itr :Ite
                    int ceu_f_iter_dash_coro (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 172 : col 36) | (set itr[:s] 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // SET | (prelude.ceu : lin 173 : col 9) | (set itr[:s] = 
                    
                { // CALL | (prelude.ceu : lin 173 : col 21) | coroutine(itr[:
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 16) /* global coroutine */));

                    
                        
                { // INDEX | (prelude.ceu : lin 173 : col 31) | itr[:s]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 173, col 31) : itr[:s]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 173, col 31) : itr[:s]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 173, col 21) : coroutine(itr[:s])");
            
        
                } // CALL | (prelude.ceu : lin 173 : col 21) | coroutine(itr[:
                  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                { // INDEX | (prelude.ceu : lin 173 : col 13) | itr[:s]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 173, col 13) : itr[:s]"
                    );
                
                        {
                            CEU_Value v = ceu_col_set(ceux_peek(X->S,XX(-1)), ceux_peek(X->S,XX(-2)), ceux_peek(X->S,XX(-3)));
                            CEU_ERROR_CHK_VAL(continue, v, "prelude.ceu : (lin 173, col 13) : itr[:s]");
                            ceux_drop(X->S, 2);    // keep src
                        }
                        
                }
                  // dst should not pop src
                }
            
                { // SET | (prelude.ceu : lin 174 : col 9) | (set itr[:f] = 
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 40) /* global iter-xcoro */));
  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                { // INDEX | (prelude.ceu : lin 174 : col 13) | itr[:f]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 174, col 13) : itr[:f]"
                    );
                
                        {
                            CEU_Value v = ceu_col_set(ceux_peek(X->S,XX(-1)), ceux_peek(X->S,XX(-2)), ceux_peek(X->S,XX(-3)));
                            CEU_ERROR_CHK_VAL(continue, v, "prelude.ceu : (lin 174, col 13) : itr[:f]");
                            ceux_drop(X->S, 2);    // keep src
                        }
                        
                }
                  // dst should not pop src
                }
            
                { // CALL | (prelude.ceu : lin 175 : col 9) | itr[:f](itr)
                    
                { // INDEX | (prelude.ceu : lin 175 : col 9) | itr[:f]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 175, col 9) : itr[:f]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 175, col 9) : itr[:f]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 175, col 9) : itr[:f](itr)");
            
        
                } // CALL | (prelude.ceu : lin 175 : col 9) | itr[:f](itr)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 172 : col 36) | (set itr[:s] 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 178 : col 5) | (func (itr :Ite
                    int ceu_f_iter_dash_tasks (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 178 : col 37) | (set itr[:i] 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // SET | (prelude.ceu : lin 180 : col 9) | (set itr[:i] = 
                    
                { // CALL | (prelude.ceu : lin 180 : col 21) | next-tasks(itr[
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 19) /* global next-tasks */));

                    
                        
                { // INDEX | (prelude.ceu : lin 180 : col 32) | itr[:s]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 180, col 32) : itr[:s]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 180, col 32) : itr[:s]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        
                { // INDEX | (prelude.ceu : lin 180 : col 38) | itr[:i]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=3} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 180, col 38) : itr[:i]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 180, col 38) : itr[:i]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 180, col 21) : next-tasks(itr[:s],itr[:i])");
            
        
                } // CALL | (prelude.ceu : lin 180 : col 21) | next-tasks(itr[
                  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                { // INDEX | (prelude.ceu : lin 180 : col 13) | itr[:i]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=3} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 180, col 13) : itr[:i]"
                    );
                
                        {
                            CEU_Value v = ceu_col_set(ceux_peek(X->S,XX(-1)), ceux_peek(X->S,XX(-2)), ceux_peek(X->S,XX(-3)));
                            CEU_ERROR_CHK_VAL(continue, v, "prelude.ceu : (lin 180, col 13) : itr[:i]");
                            ceux_drop(X->S, 2);    // keep src
                        }
                        
                }
                  // dst should not pop src
                }
            
                { // INDEX | (prelude.ceu : lin 181 : col 9) | itr[:i]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=3} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg itr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 181, col 9) : itr[:i]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 181, col 9) : itr[:i]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 178 : col 37) | (set itr[:i] 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 184 : col 5) | (func (v,tp) 
                    int ceu_f_to_dash_iter (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 184 : col 26) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (prelude.ceu : lin 196 : col 21) | do (val ceu_5
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 197 : col 25) | (val ceu_5651 =
                
                    
                { // CALL | (prelude.ceu : lin 185 : col 13) | type(v)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 185, col 13) : type(v)");
            
        
                } // CALL | (prelude.ceu : lin 185 : col 13) | type(v)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_5651 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 197 : col 25) | (val ceu_5651 =)
        
            
                // DCL | (prelude.ceu : lin 187 : col 29) | (val it = ceu_5
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_5651 */));

                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 187 : col 29) | (val it = ceu_5)
        
            
                { // IF | (prelude.ceu : lin 186 : col 29) | if tags(v,:Iter
                    
                { // CALL | (prelude.ceu : lin 186 : col 14) | tags(v,:Iterato
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 6) /* global tags */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Iterator} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 186, col 14) : tags(v,:Iterator)");
            
        
                } // CALL | (prelude.ceu : lin 186 : col 14) | tags(v,:Iterato
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 186 : col 33) | v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 186 : col 33) | v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 188 : col 36) | (val it = ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 190 : col 29) | (val it = ceu_5
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_5651 */));

                    ceux_copy(X->S, (X->base + 0 + 2 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 190 : col 29) | (val it = ceu_5)
        
            
                { // IF | (prelude.ceu : lin 187 : col 29) | if ==(it,:t
                    
                { // CALL | (prelude.ceu : lin 187 : col 15) | ==(it,:tupl
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_tuple} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 187, col 15) : {{==}}(it,:tuple)");
            
        
                } // CALL | (prelude.ceu : lin 187 : col 15) | ==(it,:tupl
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 187 : col 23) | tags([iter-tu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 187 : col 28) | tags([iter-tupl
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 6) /* global tags */));

                    
                        
                { // TUPLE | (prelude.ceu : lin 187 : col 38) | [iter-tuple,v,t
                    ceux_push(X->S, 1, ceu_create_tuple(4));
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 38) /* global iter-tuple */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg tp */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 2, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 3, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Iterator} });
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                                        
                    

                    ceux_call(X, 3, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 187, col 28) : tags([iter-tuple,v,tp,0],:Iterator,true)");
            
        
                } // CALL | (prelude.ceu : lin 187 : col 28) | tags([iter-tupl
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 187 : col 23) | tags([iter-tu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 189 : col 36) | (val it = ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 191 : col 29) | (val it = ceu_5
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_5651 */));

                    ceux_copy(X->S, (X->base + 0 + 3 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 191 : col 29) | (val it = ceu_5)
        
            
                { // IF | (prelude.ceu : lin 188 : col 29) | if ==(it,:v
                    
                { // CALL | (prelude.ceu : lin 188 : col 15) | ==(it,:vect
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 3 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_vector} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 188, col 15) : {{==}}(it,:vector)");
            
        
                } // CALL | (prelude.ceu : lin 188 : col 15) | ==(it,:vect
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 188 : col 24) | tags([iter-tu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 188 : col 28) | tags([iter-tupl
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 6) /* global tags */));

                    
                        
                { // TUPLE | (prelude.ceu : lin 188 : col 38) | [iter-tuple,v,t
                    ceux_push(X->S, 1, ceu_create_tuple(4));
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 38) /* global iter-tuple */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg tp */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 2, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 3, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Iterator} });
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                                        
                    

                    ceux_call(X, 3, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 188, col 28) : tags([iter-tuple,v,tp,0],:Iterator,true)");
            
        
                } // CALL | (prelude.ceu : lin 188 : col 28) | tags([iter-tupl
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 188 : col 24) | tags([iter-tu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 190 : col 36) | (val it = ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 192 : col 29) | (val it = ceu_5
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_5651 */));

                    ceux_copy(X->S, (X->base + 0 + 4 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 192 : col 29) | (val it = ceu_5)
        
            
                { // IF | (prelude.ceu : lin 189 : col 29) | if ==(it,:d
                    
                { // CALL | (prelude.ceu : lin 189 : col 15) | ==(it,:dict
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_dict} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 189, col 15) : {{==}}(it,:dict)");
            
        
                } // CALL | (prelude.ceu : lin 189 : col 15) | ==(it,:dict
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 189 : col 22) | tags([iter-di
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 189 : col 28) | tags([iter-dict
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 6) /* global tags */));

                    
                        
                { // TUPLE | (prelude.ceu : lin 189 : col 38) | [iter-dict,v,tp
                    ceux_push(X->S, 1, ceu_create_tuple(4));
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 39) /* global iter-dict */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg tp */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 2, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 3, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Iterator} });
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                                        
                    

                    ceux_call(X, 3, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 189, col 28) : tags([iter-dict,v,tp,nil],:Iterator,true)");
            
        
                } // CALL | (prelude.ceu : lin 189 : col 28) | tags([iter-dict
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 189 : col 22) | tags([iter-di
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 191 : col 36) | (val it = ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 193 : col 29) | (val it = ceu_5
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_5651 */));

                    ceux_copy(X->S, (X->base + 0 + 5 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 193 : col 29) | (val it = ceu_5)
        
            
                { // IF | (prelude.ceu : lin 190 : col 29) | if ==(it,:f
                    
                { // CALL | (prelude.ceu : lin 190 : col 15) | ==(it,:func
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 5 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_func} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 190, col 15) : {{==}}(it,:func)");
            
        
                } // CALL | (prelude.ceu : lin 190 : col 15) | ==(it,:func
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 190 : col 22) | tags([v],:Ite
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 190 : col 28) | tags([v],:Itera
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 6) /* global tags */));

                    
                        
                { // TUPLE | (prelude.ceu : lin 190 : col 38) | [v]
                    ceux_push(X->S, 1, ceu_create_tuple(1));
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Iterator} });
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                                        
                    

                    ceux_call(X, 3, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 190, col 28) : tags([v],:Iterator,true)");
            
        
                } // CALL | (prelude.ceu : lin 190 : col 28) | tags([v],:Itera
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 190 : col 22) | tags([v],:Ite
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 192 : col 36) | (val it = ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 194 : col 29) | (val it = ceu_5
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_5651 */));

                    ceux_copy(X->S, (X->base + 0 + 6 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 194 : col 29) | (val it = ceu_5)
        
            
                { // IF | (prelude.ceu : lin 191 : col 29) | if ==(it,:c
                    
                { // CALL | (prelude.ceu : lin 191 : col 15) | ==(it,:coro
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 6 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_coro} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 191, col 15) : {{==}}(it,:coro)");
            
        
                } // CALL | (prelude.ceu : lin 191 : col 15) | ==(it,:coro
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 191 : col 22) | tags([iter-co
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+7, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 191 : col 28) | tags([iter-coro
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 6) /* global tags */));

                    
                        
                { // TUPLE | (prelude.ceu : lin 191 : col 38) | [iter-coro,v]
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 41) /* global iter-coro */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Iterator} });
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                                        
                    

                    ceux_call(X, 3, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 191, col 28) : tags([iter-coro,v],:Iterator,true)");
            
        
                } // CALL | (prelude.ceu : lin 191 : col 28) | tags([iter-coro
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 191 : col 22) | tags([iter-co
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+7, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 193 : col 36) | (val it = ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+7, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 195 : col 29) | (val it = ceu_5
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_5651 */));

                    ceux_copy(X->S, (X->base + 0 + 7 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 195 : col 29) | (val it = ceu_5)
        
            
                { // IF | (prelude.ceu : lin 192 : col 29) | if ==(it,:e
                    
                { // CALL | (prelude.ceu : lin 192 : col 15) | ==(it,:exe-
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 7 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_exe_coro} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 192, col 15) : {{==}}(it,:exe-coro)");
            
        
                } // CALL | (prelude.ceu : lin 192 : col 15) | ==(it,:exe-
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 192 : col 26) | tags([iter-xc
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+8, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 192 : col 28) | tags([iter-xcor
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 6) /* global tags */));

                    
                        
                { // TUPLE | (prelude.ceu : lin 192 : col 38) | [iter-xcoro,v]
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 40) /* global iter-xcoro */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Iterator} });
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                                        
                    

                    ceux_call(X, 3, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 192, col 28) : tags([iter-xcoro,v],:Iterator,true)");
            
        
                } // CALL | (prelude.ceu : lin 192 : col 28) | tags([iter-xcor
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 192 : col 26) | tags([iter-xc
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+8, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 194 : col 36) | (val it = ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+8, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 196 : col 29) | (val it = ceu_5
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_5651 */));

                    ceux_copy(X->S, (X->base + 0 + 8 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 196 : col 29) | (val it = ceu_5)
        
            
                { // IF | (prelude.ceu : lin 193 : col 29) | if ==(it,:t
                    
                { // CALL | (prelude.ceu : lin 193 : col 15) | ==(it,:task
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 8 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_tasks} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 193, col 15) : {{==}}(it,:tasks)");
            
        
                } // CALL | (prelude.ceu : lin 193 : col 15) | ==(it,:task
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 193 : col 23) | tags([iter-ta
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+9, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 193 : col 28) | tags([iter-task
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 6) /* global tags */));

                    
                        
                { // TUPLE | (prelude.ceu : lin 193 : col 38) | [iter-tasks,v,n
                    ceux_push(X->S, 1, ceu_create_tuple(4));
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 42) /* global iter-tasks */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 2, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 3, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Iterator} });
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                                        
                    

                    ceux_call(X, 3, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 193, col 28) : tags([iter-tasks,v,nil,nil],:Iterator,true)");
            
        
                } // CALL | (prelude.ceu : lin 193 : col 28) | tags([iter-task
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 193 : col 23) | tags([iter-ta
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+9, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 195 : col 36) | if true nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+9, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 198 : col 29) | if true nil
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 194 : col 18) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+9, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 194 : col 18) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+9, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 196 : col 36) | (do nil)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+9, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        // PASS | (prelude.ceu : lin 196 : col 36) | (do nil)
ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 196 : col 36) | (do nil)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+9, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 195 : col 36) | if true nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+9, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 194 : col 36) | (val it = ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+8, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 193 : col 36) | (val it = ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+7, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 192 : col 36) | (val it = ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 191 : col 36) | (val it = ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 190 : col 36) | (val it = ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 189 : col 36) | (val it = ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 188 : col 36) | (val it = ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 196 : col 21) | do (val ceu_5
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 184 : col 26) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 223 : col 9) | (func (v1',v2')
                    int ceu_f_equals_dash_tuple_dash_vector (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 223 : col 45) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (prelude.ceu : lin 229 : col 21) | do (val ceu_6
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 230 : col 25) | (val ceu_6910 =
                
                    
                { // CALL | (prelude.ceu : lin 224 : col 19) | ==(#(v1
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 224 : col 14) | #(v1')
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 13) /* global {{#}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1' */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 224, col 14) : {{#}}(v1')");
            
        
                } // CALL | (prelude.ceu : lin 224 : col 14) | #(v1')
                
                    
                        
                { // CALL | (prelude.ceu : lin 224 : col 22) | #(v2')
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 13) /* global {{#}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2' */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 224, col 22) : {{#}}(v2')");
            
        
                } // CALL | (prelude.ceu : lin 224 : col 22) | #(v2')
                
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 224, col 19) : {{==}}({{#}}(v1'),{{#}}(v2'))");
            
        
                } // CALL | (prelude.ceu : lin 224 : col 19) | ==(#(v1
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_6910 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 230 : col 25) | (val ceu_6910 =)
        
            
                { // IF | (prelude.ceu : lin 225 : col 25) | if ceu_6910 i
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_6910 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 225 : col 37) | if do (val 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 224 : col 33) | if do (val ce
                    
                { // BLOCK | (prelude.ceu : lin 228 : col 29) | do (val ceu_7
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 229 : col 33) | (val ceu_7030 =
                
                    
                { // CALL | (prelude.ceu : lin 229 : col 48) | to-iter(to-iter
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 43) /* global to-iter */));

                    
                        
                { // CALL | (prelude.ceu : lin 225 : col 27) | to-iter(v1',:al
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 43) /* global to-iter */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1' */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_all} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 225, col 27) : to-iter(v1',:all)");
            
        
                } // CALL | (prelude.ceu : lin 225 : col 27) | to-iter(v1',:al
                
                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 229, col 48) : to-iter(to-iter(v1',:all))");
            
        
                } // CALL | (prelude.ceu : lin 229 : col 48) | to-iter(to-iter
                
                    ceux_copy(X->S, (X->base + 0 + 1 + 0) /* local ceu_7030 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 229 : col 33) | (val ceu_7030 =)
        
            
                // LOOP | (prelude.ceu : lin 226 : col 33) | loop (val x =
                CEU_LOOP_START_8874:
                    
                { // BLOCK | (prelude.ceu : lin 226 : col 33) | (val x = ceu_
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 227 : col 37) | (val x = ceu_70
                
                    
                { // CALL | (prelude.ceu : lin 225 : col 26) | ceu_7030[0](ceu
                    
                { // INDEX | (prelude.ceu : lin 225 : col 26) | ceu_7030[0]
                    // IDX
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_7030 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 225, col 26) : ceu_7030[0]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 225, col 26) : ceu_7030[0]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_7030 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 225, col 26) : ceu_7030[0](ceu_7030)");
            
        
                } // CALL | (prelude.ceu : lin 225 : col 26) | ceu_7030[0](ceu
                
                    ceux_copy(X->S, (X->base + 0 + 2 + 0) /* local x */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 227 : col 37) | (val x = ceu_70)
        
             // BREAK | (prelude.ceu : lin 226 : col 37) | (break(false) i
                
                { // CALL | (prelude.ceu : lin 226 : col 56) | ==(x,nil)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local x */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 226, col 56) : {{==}}(x,nil)");
            
        
                } // CALL | (prelude.ceu : lin 226 : col 56) | ==(x,nil)
                
                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            ceux_pop(X->S, 1);        // (2)
                            ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_8874;
                    }
                }
             // BREAK | (prelude.ceu : lin 226 : col 21) | (break if if 
                
                { // IF | (prelude.ceu : lin 226 : col 47) | if ===(v2'[
                    
                { // CALL | (prelude.ceu : lin 226 : col 38) | ===(v2'[x[0
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 44) /* global {{===}} */));

                    
                        
                { // INDEX | (prelude.ceu : lin 226 : col 28) | v2'[x[0]]
                    // IDX
                    
                { // INDEX | (prelude.ceu : lin 226 : col 32) | x[0]
                    // IDX
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local x */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 226, col 32) : x[0]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 226, col 32) : x[0]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2' */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 226, col 28) : v2'[x[0]]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 226, col 28) : v2'[x[0]]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        
                { // INDEX | (prelude.ceu : lin 226 : col 42) | x[1]
                    // IDX
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local x */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 226, col 42) : x[1]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 226, col 42) : x[1]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 226, col 38) : {{===}}(v2'[x[0]],x[1])");
            
        
                } // CALL | (prelude.ceu : lin 226 : col 38) | ===(v2'[x[0
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 226 : col 48) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 226 : col 48) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 226 : col 63) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 226 : col 63) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_8874;
                    }
                }
            
                        
                            CEU_LOOP_STOP_8874:
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 226 : col 33) | (val x = ceu_
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : ) !CEU_BREAK ? 0 :  1;
                        ceux_block_leave(X->S, X->base+2, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    if (CEU_BREAK) {
                        CEU_BREAK = 0;
                    } else {
                        //ceux_pop(X->S, 1);
                        goto CEU_LOOP_START_8874;
                    }
            
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 228 : col 29) | do (val ceu_7
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 229 : col 3) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 229 : col 3) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 229 : col 18) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 229 : col 18) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 225 : col 37) | if do (val 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 231 : col 32) | ceu_6910
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_6910 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 231 : col 32) | ceu_6910
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 229 : col 21) | do (val ceu_6
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 223 : col 45) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 230 : col 9) | (func (v1',v2')
                    int ceu_f_contains_dash_dict_question_ (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 230 : col 40) | if do (val 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 231 : col 14) | if do (val ce
                    
                { // BLOCK | (prelude.ceu : lin 235 : col 29) | do (val ceu_7
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 236 : col 33) | (val ceu_7756 =
                
                    
                { // CALL | (prelude.ceu : lin 236 : col 48) | to-iter(to-iter
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 43) /* global to-iter */));

                    
                        
                { // CALL | (prelude.ceu : lin 232 : col 27) | to-iter(v1',:al
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 43) /* global to-iter */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1' */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_all} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 232, col 27) : to-iter(v1',:all)");
            
        
                } // CALL | (prelude.ceu : lin 232 : col 27) | to-iter(v1',:al
                
                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 236, col 48) : to-iter(to-iter(v1',:all))");
            
        
                } // CALL | (prelude.ceu : lin 236 : col 48) | to-iter(to-iter
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_7756 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 236 : col 33) | (val ceu_7756 =)
        
            
                // LOOP | (prelude.ceu : lin 233 : col 33) | loop (val x =
                CEU_LOOP_START_9029:
                    
                { // BLOCK | (prelude.ceu : lin 233 : col 33) | (val x = ceu_
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 234 : col 37) | (val x = ceu_77
                
                    
                { // CALL | (prelude.ceu : lin 232 : col 26) | ceu_7756[0](ceu
                    
                { // INDEX | (prelude.ceu : lin 232 : col 26) | ceu_7756[0]
                    // IDX
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_7756 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 232, col 26) : ceu_7756[0]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 232, col 26) : ceu_7756[0]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_7756 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 232, col 26) : ceu_7756[0](ceu_7756)");
            
        
                } // CALL | (prelude.ceu : lin 232 : col 26) | ceu_7756[0](ceu
                
                    ceux_copy(X->S, (X->base + 0 + 1 + 0) /* local x */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 234 : col 37) | (val x = ceu_77)
        
             // BREAK | (prelude.ceu : lin 233 : col 37) | (break(false) i
                
                { // CALL | (prelude.ceu : lin 233 : col 56) | ==(x,nil)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local x */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 233, col 56) : {{==}}(x,nil)");
            
        
                } // CALL | (prelude.ceu : lin 233 : col 56) | ==(x,nil)
                
                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            ceux_pop(X->S, 1);        // (2)
                            ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_9029;
                    }
                }
             // BREAK | (prelude.ceu : lin 233 : col 21) | (break if if 
                
                { // IF | (prelude.ceu : lin 233 : col 47) | if ===(v2'[
                    
                { // CALL | (prelude.ceu : lin 233 : col 38) | ===(v2'[x[0
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 44) /* global {{===}} */));

                    
                        
                { // INDEX | (prelude.ceu : lin 233 : col 28) | v2'[x[0]]
                    // IDX
                    
                { // INDEX | (prelude.ceu : lin 233 : col 32) | x[0]
                    // IDX
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local x */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 233, col 32) : x[0]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 233, col 32) : x[0]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2' */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 233, col 28) : v2'[x[0]]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 233, col 28) : v2'[x[0]]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        
                { // INDEX | (prelude.ceu : lin 233 : col 42) | x[1]
                    // IDX
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local x */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 233, col 42) : x[1]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 233, col 42) : x[1]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 233, col 38) : {{===}}(v2'[x[0]],x[1])");
            
        
                } // CALL | (prelude.ceu : lin 233 : col 38) | ===(v2'[x[0
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 233 : col 48) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 233 : col 48) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 233 : col 63) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 233 : col 63) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_9029;
                    }
                }
            
                        
                            CEU_LOOP_STOP_9029:
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 233 : col 33) | (val x = ceu_
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : ) !CEU_BREAK ? 0 :  1;
                        ceux_block_leave(X->S, X->base+1, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    if (CEU_BREAK) {
                        CEU_BREAK = 0;
                    } else {
                        //ceux_pop(X->S, 1);
                        goto CEU_LOOP_START_9029;
                    }
            
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 235 : col 29) | do (val ceu_7
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 236 : col 3) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 236 : col 3) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 236 : col 18) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 236 : col 18) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 230 : col 40) | if do (val 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 213 : col 1) | (func :rec (v1,
                    int ceu_f_equals_equals_equals (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 213 : col 27) | (val t1 = typ
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 214 : col 5) | (val t1 = type(
                
                    
                { // CALL | (prelude.ceu : lin 214 : col 14) | type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 214, col 14) : type(v1)");
            
        
                } // CALL | (prelude.ceu : lin 214 : col 14) | type(v1)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local t1 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 214 : col 5) | (val t1 = type()
        
            
                // DCL | (prelude.ceu : lin 215 : col 5) | (val t2 = type(
                
                    
                { // CALL | (prelude.ceu : lin 215 : col 14) | type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 215, col 14) : type(v2)");
            
        
                } // CALL | (prelude.ceu : lin 215 : col 14) | type(v2)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local t2 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 215 : col 5) | (val t2 = type()
        
            
                { // BLOCK | (prelude.ceu : lin 222 : col 7) | do (val equal
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 223 : col 9) | (val equals-tup
                
                     // CREATE | (prelude.ceu : lin 223 : col 9) | (func (v1',v2')
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_equals_dash_tuple_dash_vector,
                        2,  // TODO: remove assert
                        3,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 2 + 0) /* local equals-tuple-vector */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 223 : col 9) | (val equals-tup)
        
            
                // DCL | (prelude.ceu : lin 230 : col 9) | (val contains-d
                
                     // CREATE | (prelude.ceu : lin 230 : col 9) | (func (v1',v2')
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_contains_dash_dict_question_,
                        2,  // TODO: remove assert
                        2,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 2 + 1) /* local contains-dict? */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 230 : col 9) | (val contains-d)
        
            
                { // BLOCK | (prelude.ceu : lin 223 : col 21) | do if ==(
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 227 : col 29) | if ==(v1,v2
                    
                { // CALL | (prelude.ceu : lin 217 : col 12) | ==(v1,v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 217, col 12) : {{==}}(v1,v2)");
            
        
                } // CALL | (prelude.ceu : lin 217 : col 12) | ==(v1,v2)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 217 : col 19) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 217 : col 19) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 219 : col 36) | if /=(t1,
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 222 : col 29) | if /=(t1,t2
                    
                { // CALL | (prelude.ceu : lin 218 : col 12) | /=(t1,t2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 15) /* global {{/=}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local t1 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 1) /* local t2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 218, col 12) : {{/=}}(t1,t2)");
            
        
                } // CALL | (prelude.ceu : lin 218 : col 12) | /=(t1,t2)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 218 : col 19) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 218 : col 19) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 220 : col 36) | if do (val 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 223 : col 29) | if do (val ce
                    
                { // BLOCK | (prelude.ceu : lin 220 : col 21) | do (val ceu_6
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 221 : col 25) | (val ceu_6538 =
                
                    
                { // CALL | (prelude.ceu : lin 219 : col 12) | ==(t1,:tupl
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local t1 */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_tuple} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 219, col 12) : {{==}}(t1,:tuple)");
            
        
                } // CALL | (prelude.ceu : lin 219 : col 12) | ==(t1,:tupl
                
                    ceux_copy(X->S, (X->base + 0 + 4 + 0) /* local ceu_6538 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 221 : col 25) | (val ceu_6538 =)
        
            
                { // IF | (prelude.ceu : lin 220 : col 25) | if ceu_6538 c
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local ceu_6538 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 220 : col 37) | ceu_6538
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local ceu_6538 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 220 : col 37) | ceu_6538
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 222 : col 32) | ==(t1,:ve
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 219 : col 28) | ==(t1,:vect
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local t1 */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_vector} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 219, col 28) : {{==}}(t1,:vector)");
            
        
                } // CALL | (prelude.ceu : lin 219 : col 28) | ==(t1,:vect
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 222 : col 32) | ==(t1,:ve
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 220 : col 21) | do (val ceu_6
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 221 : col 3) | equals-tuple-
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 219 : col 42) | equals-tuple-ve
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local equals-tuple-vector */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 219, col 42) : equals-tuple-vector(v1,v2)");
            
        
                } // CALL | (prelude.ceu : lin 219 : col 42) | equals-tuple-ve
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 221 : col 3) | equals-tuple-
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 221 : col 36) | if ==(t1,
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 224 : col 29) | if ==(t1,:d
                    
                { // CALL | (prelude.ceu : lin 220 : col 12) | ==(t1,:dict
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local t1 */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_dict} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 220, col 12) : {{==}}(t1,:dict)");
            
        
                } // CALL | (prelude.ceu : lin 220 : col 12) | ==(t1,:dict
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 220 : col 22) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (prelude.ceu : lin 221 : col 21) | do (val ceu_6
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 222 : col 25) | (val ceu_6626 =
                
                    
                { // CALL | (prelude.ceu : lin 220 : col 24) | contains-dict?(
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 1) /* local contains-dict? */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 220, col 24) : contains-dict?(v1,v2)");
            
        
                } // CALL | (prelude.ceu : lin 220 : col 24) | contains-dict?(
                
                    ceux_copy(X->S, (X->base + 0 + 4 + 0) /* local ceu_6626 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 222 : col 25) | (val ceu_6626 =)
        
            
                { // IF | (prelude.ceu : lin 221 : col 25) | if ceu_6626 c
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local ceu_6626 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 221 : col 37) | contains-dict
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 220 : col 50) | contains-dict?(
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 1) /* local contains-dict? */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 220, col 50) : contains-dict?(v2,v1)");
            
        
                } // CALL | (prelude.ceu : lin 220 : col 50) | contains-dict?(
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 221 : col 37) | contains-dict
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 221 : col 32) | ceu_6626
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local ceu_6626 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 221 : col 32) | ceu_6626
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 221 : col 21) | do (val ceu_6
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 220 : col 22) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 226 : col 36) | if true fal
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 229 : col 29) | if true false
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 221 : col 14) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 221 : col 14) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 223 : col 36) | (do nil)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        // PASS | (prelude.ceu : lin 223 : col 36) | (do nil)
ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 223 : col 36) | (do nil)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 226 : col 36) | if true fal
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 221 : col 36) | if ==(t1,
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 220 : col 36) | if do (val 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 219 : col 36) | if /=(t1,
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 223 : col 21) | do if ==(
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 222 : col 7) | do (val equal
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 213 : col 27) | (val t1 = typ
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 240 : col 1) | (func :rec (v1,
                    int ceu_f_equals_slash_equals (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 240 : col 27) | if ===(v1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 241 : col 6) | if ===(v1,v
                    
                { // CALL | (prelude.ceu : lin 241 : col 13) | ===(v1,v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 44) /* global {{===}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 241, col 13) : {{===}}(v1,v2)");
            
        
                } // CALL | (prelude.ceu : lin 241 : col 13) | ===(v1,v2)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 241 : col 21) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 241 : col 21) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 241 : col 36) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 241 : col 36) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 240 : col 27) | if ===(v1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 244 : col 1) | (func (v1,v2) 
                    int ceu_f_is_plic_ (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 244 : col 18) | do if ==
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (prelude.ceu : lin 252 : col 21) | do if ==(
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 256 : col 29) | if ==(v1,v2
                    
                { // CALL | (prelude.ceu : lin 246 : col 13) | ==(v1,v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 246, col 13) : {{==}}(v1,v2)");
            
        
                } // CALL | (prelude.ceu : lin 246 : col 13) | ==(v1,v2)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 246 : col 20) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 246 : col 20) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 248 : col 36) | if =/=(ty
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 251 : col 29) | if =/=(type
                    
                { // CALL | (prelude.ceu : lin 247 : col 19) | =/=(type(v2
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 45) /* global {{=/=}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 247 : col 10) | type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 247, col 10) : type(v2)");
            
        
                } // CALL | (prelude.ceu : lin 247 : col 10) | type(v2)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_tag} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 247, col 19) : {{=/=}}(type(v2),:tag)");
            
        
                } // CALL | (prelude.ceu : lin 247 : col 19) | =/=(type(v2
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 247 : col 29) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 247 : col 29) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 249 : col 36) | if ===(ty
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 252 : col 29) | if ===(type
                    
                { // CALL | (prelude.ceu : lin 248 : col 19) | ===(type(v1
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 44) /* global {{===}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 248 : col 10) | type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 248, col 10) : type(v1)");
            
        
                } // CALL | (prelude.ceu : lin 248 : col 10) | type(v1)
                
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 248, col 19) : {{===}}(type(v1),v2)");
            
        
                } // CALL | (prelude.ceu : lin 248 : col 19) | ===(type(v1
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 248 : col 27) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 248 : col 27) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 250 : col 36) | if tags(v1,v2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 253 : col 29) | if tags(v1,v2) 
                    
                { // CALL | (prelude.ceu : lin 249 : col 9) | tags(v1,v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 6) /* global tags */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 249, col 9) : tags(v1,v2)");
            
        
                } // CALL | (prelude.ceu : lin 249 : col 9) | tags(v1,v2)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 249 : col 21) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 249 : col 21) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 251 : col 36) | if true fal
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 254 : col 29) | if true false
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 250 : col 14) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 250 : col 14) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 252 : col 36) | (do nil)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        // PASS | (prelude.ceu : lin 252 : col 36) | (do nil)
ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 252 : col 36) | (do nil)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 251 : col 36) | if true fal
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 250 : col 36) | if tags(v1,v2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 249 : col 36) | if ===(ty
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 248 : col 36) | if =/=(ty
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 252 : col 21) | do if ==(
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 244 : col 18) | do if ==
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 254 : col 1) | (func (v1,v2) 
                    int ceu_f_is_dash_not_plic_ (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 254 : col 22) | if is'(v1,v2)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 255 : col 6) | if is'(v1,v2) 
                    
                { // CALL | (prelude.ceu : lin 255 : col 9) | is'(v1,v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 255, col 9) : is'(v1,v2)");
            
        
                } // CALL | (prelude.ceu : lin 255 : col 9) | is'(v1,v2)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 255 : col 20) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 255 : col 20) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 255 : col 35) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 255 : col 35) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 254 : col 22) | if is'(v1,v2)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 258 : col 1) | (func (v,xs) 
                    int ceu_f_in_plic_ (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 258 : col 18) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (prelude.ceu : lin 262 : col 29) | do (val ceu_9
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 263 : col 33) | (val ceu_9812 =
                
                    
                { // CALL | (prelude.ceu : lin 263 : col 48) | to-iter(to-iter
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 43) /* global to-iter */));

                    
                        
                { // CALL | (prelude.ceu : lin 259 : col 15) | to-iter(xs)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 43) /* global to-iter */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg xs */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 259, col 15) : to-iter(xs)");
            
        
                } // CALL | (prelude.ceu : lin 259 : col 15) | to-iter(xs)
                
                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 263, col 48) : to-iter(to-iter(xs))");
            
        
                } // CALL | (prelude.ceu : lin 263 : col 48) | to-iter(to-iter
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_9812 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 263 : col 33) | (val ceu_9812 =)
        
            
                // LOOP | (prelude.ceu : lin 260 : col 33) | loop (val x =
                CEU_LOOP_START_9984:
                    
                { // BLOCK | (prelude.ceu : lin 260 : col 33) | (val x = ceu_
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 261 : col 37) | (val x = ceu_98
                
                    
                { // CALL | (prelude.ceu : lin 259 : col 14) | ceu_9812[0](ceu
                    
                { // INDEX | (prelude.ceu : lin 259 : col 14) | ceu_9812[0]
                    // IDX
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_9812 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 259, col 14) : ceu_9812[0]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 259, col 14) : ceu_9812[0]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_9812 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 259, col 14) : ceu_9812[0](ceu_9812)");
            
        
                } // CALL | (prelude.ceu : lin 259 : col 14) | ceu_9812[0](ceu
                
                    ceux_copy(X->S, (X->base + 0 + 1 + 0) /* local x */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 261 : col 37) | (val x = ceu_98)
        
             // BREAK | (prelude.ceu : lin 260 : col 37) | (break(false) i
                
                { // CALL | (prelude.ceu : lin 260 : col 56) | ==(x,nil)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local x */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 260, col 56) : {{==}}(x,nil)");
            
        
                } // CALL | (prelude.ceu : lin 260 : col 56) | ==(x,nil)
                
                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            ceux_pop(X->S, 1);        // (2)
                            ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_9984;
                    }
                }
             // BREAK | (prelude.ceu : lin 260 : col 8) | (break if ==
                
                { // CALL | (prelude.ceu : lin 260 : col 17) | ==(x,v)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local x */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 260, col 17) : {{==}}(x,v)");
            
        
                } // CALL | (prelude.ceu : lin 260 : col 17) | ==(x,v)
                
                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_9984;
                    }
                }
            
                        
                            CEU_LOOP_STOP_9984:
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 260 : col 33) | (val x = ceu_
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : ) !CEU_BREAK ? 0 :  1;
                        ceux_block_leave(X->S, X->base+1, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    if (CEU_BREAK) {
                        CEU_BREAK = 0;
                    } else {
                        //ceux_pop(X->S, 1);
                        goto CEU_LOOP_START_9984;
                    }
            
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 262 : col 29) | do (val ceu_9
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 258 : col 18) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 264 : col 1) | (func (v,xs) 
                    int ceu_f_in_dash_not_plic_ (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 264 : col 22) | if in'(v,xs) 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 265 : col 6) | if in'(v,xs) 
                    
                { // CALL | (prelude.ceu : lin 265 : col 9) | in'(v,xs)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 48) /* global in' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg xs */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 265, col 9) : in'(v,xs)");
            
        
                } // CALL | (prelude.ceu : lin 265 : col 9) | in'(v,xs)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 265 : col 19) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 265 : col 19) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 265 : col 34) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 265 : col 34) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 264 : col 22) | if in'(v,xs) 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 272 : col 1) | (func (v) do 
                    int ceu_f_string_question_ (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 272 : col 18) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (prelude.ceu : lin 274 : col 21) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 275 : col 25) | (val ceu_10176 
                
                    
                { // BLOCK | (prelude.ceu : lin 274 : col 21) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 275 : col 25) | (val ceu_10105 
                
                    
                { // CALL | (prelude.ceu : lin 273 : col 14) | ==(type(v),
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 273 : col 7) | type(v)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 273, col 7) : type(v)");
            
        
                } // CALL | (prelude.ceu : lin 273 : col 7) | type(v)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_vector} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 273, col 14) : {{==}}(type(v),:vector)");
            
        
                } // CALL | (prelude.ceu : lin 273 : col 14) | ==(type(v),
                
                    ceux_copy(X->S, (X->base + 0 + 1 + 0) /* local ceu_10105 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 275 : col 25) | (val ceu_10105 )
        
            
                { // IF | (prelude.ceu : lin 274 : col 25) | if ceu_10105 
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_10105 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 274 : col 38) | >(#(v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 273 : col 32) | >(#(v),
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 29) /* global {{>}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 273 : col 30) | #(v)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 13) /* global {{#}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 273, col 30) : {{#}}(v)");
            
        
                } // CALL | (prelude.ceu : lin 273 : col 30) | #(v)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 273, col 32) : {{>}}({{#}}(v),0)");
            
        
                } // CALL | (prelude.ceu : lin 273 : col 32) | >(#(v),
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 274 : col 38) | >(#(v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 274 : col 32) | ceu_10105
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_10105 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 274 : col 32) | ceu_10105
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 274 : col 21) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_10176 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 275 : col 25) | (val ceu_10176 )
        
            
                { // IF | (prelude.ceu : lin 278 : col 25) | if ceu_10176 
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_10176 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 278 : col 38) | ==(type(v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 273 : col 52) | ==(type(v[0
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 273 : col 42) | type(v[0])
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        
                { // INDEX | (prelude.ceu : lin 273 : col 47) | v[0]
                    // IDX
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 273, col 47) : v[0]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 273, col 47) : v[0]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 273, col 42) : type(v[0])");
            
        
                } // CALL | (prelude.ceu : lin 273 : col 42) | type(v[0])
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_char} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 273, col 52) : {{==}}(type(v[0]),:char)");
            
        
                } // CALL | (prelude.ceu : lin 273 : col 52) | ==(type(v[0
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 278 : col 38) | ==(type(v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 274 : col 32) | ceu_10176
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_10176 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 274 : col 32) | ceu_10176
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 274 : col 21) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 272 : col 18) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 276 : col 1) | (func :rec (v) 
                    int ceu_f_to_dash_string (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 276 : col 25) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (prelude.ceu : lin 286 : col 21) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 287 : col 25) | (val ceu_10612 
                
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_10612 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 287 : col 25) | (val ceu_10612 )
        
            
                // DCL | (prelude.ceu : lin 279 : col 29) | (val it = ceu_1
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_10612 */));

                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 279 : col 29) | (val it = ceu_1)
        
            
                { // IF | (prelude.ceu : lin 278 : col 29) | if string?(it) 
                    
                { // CALL | (prelude.ceu : lin 278 : col 9) | string?(it)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 50) /* global string? */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 1) /* local it */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 278, col 9) : string?(it)");
            
        
                } // CALL | (prelude.ceu : lin 278 : col 9) | string?(it)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 278 : col 21) | v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 278 : col 21) | v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 280 : col 36) | (val it :nil 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 282 : col 29) | (val it :nil = 
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_10612 */));

                    ceux_copy(X->S, (X->base + 0 + 2 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 282 : col 29) | (val it :nil = )
        
            
                { // IF | (prelude.ceu : lin 280 : col 29) | if is'(it,:nil)
                    
                { // CALL | (prelude.ceu : lin 279 : col 16) | is'(it,:nil)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_nil} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 279, col 16) : is'(it,:nil)");
            
        
                } // CALL | (prelude.ceu : lin 279 : col 16) | is'(it,:nil)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 279 : col 22) | #['n','i','l'
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // VECTOR | (prelude.ceu : lin 279 : col 24) | #['n','i','l']
                    ceux_push(X->S, 1, ceu_create_vector());
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='n'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='i'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='l'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 2, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 279 : col 22) | #['n','i','l'
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 281 : col 36) | (val it :tag 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 283 : col 29) | (val it :tag = 
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_10612 */));

                    ceux_copy(X->S, (X->base + 0 + 3 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 283 : col 29) | (val it :tag = )
        
            
                { // IF | (prelude.ceu : lin 281 : col 29) | if is'(it,:tag)
                    
                { // CALL | (prelude.ceu : lin 280 : col 16) | is'(it,:tag)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 3 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_tag} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 280, col 16) : is'(it,:tag)");
            
        
                } // CALL | (prelude.ceu : lin 280 : col 16) | is'(it,:tag)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 280 : col 22) | to-string-tag
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 280 : col 24) | to-string-tag(v
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 9) /* global to-string-tag */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 280, col 24) : to-string-tag(v)");
            
        
                } // CALL | (prelude.ceu : lin 280 : col 24) | to-string-tag(v
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 280 : col 22) | to-string-tag
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 282 : col 36) | (val it :numb
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 284 : col 29) | (val it :number
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_10612 */));

                    ceux_copy(X->S, (X->base + 0 + 4 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 284 : col 29) | (val it :number)
        
            
                { // IF | (prelude.ceu : lin 282 : col 29) | if is'(it,:numb
                    
                { // CALL | (prelude.ceu : lin 281 : col 16) | is'(it,:number)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_number} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 281, col 16) : is'(it,:number)");
            
        
                } // CALL | (prelude.ceu : lin 281 : col 16) | is'(it,:number)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 281 : col 25) | to-string-num
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 281 : col 24) | to-string-numbe
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 7) /* global to-string-number */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 281, col 24) : to-string-number(v)");
            
        
                } // CALL | (prelude.ceu : lin 281 : col 24) | to-string-numbe
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 281 : col 25) | to-string-num
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 283 : col 36) | (val it :char
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 285 : col 29) | (val it :char =
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_10612 */));

                    ceux_copy(X->S, (X->base + 0 + 5 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 285 : col 29) | (val it :char =)
        
            
                { // IF | (prelude.ceu : lin 283 : col 29) | if is'(it,:char
                    
                { // CALL | (prelude.ceu : lin 282 : col 16) | is'(it,:char)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 5 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_char} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 282, col 16) : is'(it,:char)");
            
        
                } // CALL | (prelude.ceu : lin 282 : col 16) | is'(it,:char)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 282 : col 23) | #[v]
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // VECTOR | (prelude.ceu : lin 282 : col 24) | #[v]
                    ceux_push(X->S, 1, ceu_create_vector());
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 282 : col 23) | #[v]
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 284 : col 36) | (val it :poin
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 286 : col 29) | (val it :pointe
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_10612 */));

                    ceux_copy(X->S, (X->base + 0 + 6 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 286 : col 29) | (val it :pointe)
        
            
                { // IF | (prelude.ceu : lin 284 : col 29) | if is'(it,:poin
                    
                { // CALL | (prelude.ceu : lin 283 : col 16) | is'(it,:pointer
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 6 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_pointer} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 283, col 16) : is'(it,:pointer)");
            
        
                } // CALL | (prelude.ceu : lin 283 : col 16) | is'(it,:pointer
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 283 : col 26) | to-string-poi
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+7, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 283 : col 24) | to-string-point
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 8) /* global to-string-pointer */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 283, col 24) : to-string-pointer(v)");
            
        
                } // CALL | (prelude.ceu : lin 283 : col 24) | to-string-point
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 283 : col 26) | to-string-poi
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+7, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 285 : col 36) | if true nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+7, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 288 : col 29) | if true nil
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 284 : col 14) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+7, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 284 : col 14) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+7, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 286 : col 36) | (do nil)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+7, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        // PASS | (prelude.ceu : lin 286 : col 36) | (do nil)
ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 286 : col 36) | (do nil)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+7, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 285 : col 36) | if true nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+7, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 284 : col 36) | (val it :poin
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 283 : col 36) | (val it :char
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 282 : col 36) | (val it :numb
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 281 : col 36) | (val it :tag 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 280 : col 36) | (val it :nil 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 286 : col 21) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 276 : col 25) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 288 : col 1) | (func (v) if 
                    int ceu_f_to_dash_bool (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 288 : col 18) | if if v fal
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 289 : col 6) | if if v false
                    
                { // IF | (prelude.ceu : lin 289 : col 11) | if v false 
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 289 : col 16) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 289 : col 16) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 289 : col 31) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 289 : col 31) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 290 : col 3) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 290 : col 3) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 290 : col 18) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 290 : col 18) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 288 : col 18) | if if v fal
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 292 : col 1) | (func (v) do 
                    int ceu_f_to_dash_number (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 292 : col 20) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (prelude.ceu : lin 299 : col 21) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 300 : col 25) | (val ceu_11289 
                
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_11289 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 300 : col 25) | (val ceu_11289 )
        
            
                // DCL | (prelude.ceu : lin 295 : col 29) | (val it :tag = 
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_11289 */));

                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 295 : col 29) | (val it :tag = )
        
            
                { // IF | (prelude.ceu : lin 295 : col 29) | if is'(it,:tag)
                    
                { // CALL | (prelude.ceu : lin 294 : col 16) | is'(it,:tag)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 1) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_tag} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 294, col 16) : is'(it,:tag)");
            
        
                } // CALL | (prelude.ceu : lin 294 : col 16) | is'(it,:tag)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 294 : col 22) | ```:number   
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(   (ceux_peek(X->S,ceux_arg(X, 0) /* arg v */)).Tag)} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 294 : col 22) | ```:number   
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 296 : col 36) | (val it :char
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 298 : col 29) | (val it :char =
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_11289 */));

                    ceux_copy(X->S, (X->base + 0 + 2 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 298 : col 29) | (val it :char =)
        
            
                { // IF | (prelude.ceu : lin 296 : col 29) | if is'(it,:char
                    
                { // CALL | (prelude.ceu : lin 295 : col 16) | is'(it,:char)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_char} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 295, col 16) : is'(it,:char)");
            
        
                } // CALL | (prelude.ceu : lin 295 : col 16) | is'(it,:char)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 295 : col 23) | ```:number   
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(   (ceux_peek(X->S,ceux_arg(X, 0) /* arg v */)).Char)} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 295 : col 23) | ```:number   
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 297 : col 36) | (val it = ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 299 : col 29) | (val it = ceu_1
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_11289 */));

                    ceux_copy(X->S, (X->base + 0 + 3 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 299 : col 29) | (val it = ceu_1)
        
            
                { // IF | (prelude.ceu : lin 296 : col 29) | if string?(it) 
                    
                { // CALL | (prelude.ceu : lin 296 : col 9) | string?(it)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 50) /* global string? */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 3 + 0) /* local it */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 296, col 9) : string?(it)");
            
        
                } // CALL | (prelude.ceu : lin 296 : col 9) | string?(it)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 296 : col 21) | ```:number   
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(   atoi((ceux_peek(X->S,ceux_arg(X, 0) /* arg v */)).Dyn->Vector.buf))} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 296 : col 21) | ```:number   
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 298 : col 36) | if true nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 301 : col 29) | if true nil
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 297 : col 14) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 297 : col 14) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 299 : col 36) | (do nil)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        // PASS | (prelude.ceu : lin 299 : col 36) | (do nil)
ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 299 : col 36) | (do nil)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 298 : col 36) | if true nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 297 : col 36) | (val it = ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 296 : col 36) | (val it :char
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 299 : col 21) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 292 : col 20) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 301 : col 1) | (func (v) do 
                    int ceu_f_to_dash_tag (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 301 : col 17) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (prelude.ceu : lin 307 : col 21) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 308 : col 25) | (val ceu_11602 
                
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_11602 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 308 : col 25) | (val ceu_11602 )
        
            
                // DCL | (prelude.ceu : lin 304 : col 29) | (val it :tag = 
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_11602 */));

                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 304 : col 29) | (val it :tag = )
        
            
                { // IF | (prelude.ceu : lin 304 : col 29) | if is'(it,:tag)
                    
                { // CALL | (prelude.ceu : lin 303 : col 16) | is'(it,:tag)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 1) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_tag} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 303, col 16) : is'(it,:tag)");
            
        
                } // CALL | (prelude.ceu : lin 303 : col 16) | is'(it,:tag)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 303 : col 22) | v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 303 : col 22) | v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 305 : col 36) | (val it = ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 307 : col 29) | (val it = ceu_1
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_11602 */));

                    ceux_copy(X->S, (X->base + 0 + 2 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 307 : col 29) | (val it = ceu_1)
        
            
                { // IF | (prelude.ceu : lin 304 : col 29) | if string?(it) 
                    
                { // CALL | (prelude.ceu : lin 304 : col 9) | string?(it)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 50) /* global string? */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local it */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 304, col 9) : string?(it)");
            
        
                } // CALL | (prelude.ceu : lin 304 : col 9) | string?(it)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 304 : col 21) | to-tag-string
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 304 : col 24) | to-tag-string(v
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 10) /* global to-tag-string */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 304, col 24) : to-tag-string(v)");
            
        
                } // CALL | (prelude.ceu : lin 304 : col 24) | to-tag-string(v
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 304 : col 21) | to-tag-string
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 306 : col 36) | if true nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 309 : col 29) | if true nil
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 305 : col 14) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 305 : col 14) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 307 : col 36) | (do nil)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        // PASS | (prelude.ceu : lin 307 : col 36) | (do nil)
ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 307 : col 36) | (do nil)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 306 : col 36) | if true nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 305 : col 36) | (val it = ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 307 : col 21) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 301 : col 17) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 309 : col 1) | (func (v) do 
                    int ceu_f_to_dash_pointer (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 309 : col 21) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (prelude.ceu : lin 318 : col 21) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 319 : col 25) | (val ceu_11955 
                
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_11955 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 319 : col 25) | (val ceu_11955 )
        
            
                // DCL | (prelude.ceu : lin 312 : col 29) | (val it :pointe
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_11955 */));

                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 312 : col 29) | (val it :pointe)
        
            
                { // IF | (prelude.ceu : lin 312 : col 29) | if is'(it,:poin
                    
                { // CALL | (prelude.ceu : lin 311 : col 16) | is'(it,:pointer
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 1) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_pointer} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 311, col 16) : is'(it,:pointer)");
            
        
                } // CALL | (prelude.ceu : lin 311 : col 16) | is'(it,:pointer
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 311 : col 26) | v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 311 : col 26) | v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 313 : col 36) | (val it :tag 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 315 : col 29) | (val it :tag = 
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_11955 */));

                    ceux_copy(X->S, (X->base + 0 + 2 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 315 : col 29) | (val it :tag = )
        
            
                { // IF | (prelude.ceu : lin 313 : col 29) | if is'(it,:tag)
                    
                { // CALL | (prelude.ceu : lin 312 : col 16) | is'(it,:tag)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_tag} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 312, col 16) : is'(it,:tag)");
            
        
                } // CALL | (prelude.ceu : lin 312 : col 16) | is'(it,:tag)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 312 : col 22) | ```:pointer  
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_POINTER, {.Pointer=(   ceu_to_dash_string_dash_tag((ceux_peek(X->S,ceux_arg(X, 0) /* arg v */)).Tag))} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 312 : col 22) | ```:pointer  
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 314 : col 36) | (val it :tupl
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 316 : col 29) | (val it :tuple 
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_11955 */));

                    ceux_copy(X->S, (X->base + 0 + 3 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 316 : col 29) | (val it :tuple )
        
            
                { // IF | (prelude.ceu : lin 314 : col 29) | if is'(it,:tupl
                    
                { // CALL | (prelude.ceu : lin 313 : col 16) | is'(it,:tuple)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 3 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_tuple} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 313, col 16) : is'(it,:tuple)");
            
        
                } // CALL | (prelude.ceu : lin 313 : col 16) | is'(it,:tuple)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 313 : col 24) | ```:pointer  
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_POINTER, {.Pointer=(   (ceux_peek(X->S,ceux_arg(X, 0) /* arg v */)).Dyn->Tuple.buf)} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 313 : col 24) | ```:pointer  
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 315 : col 36) | (val it :vect
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 317 : col 29) | (val it :vector
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_11955 */));

                    ceux_copy(X->S, (X->base + 0 + 4 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 317 : col 29) | (val it :vector)
        
            
                { // IF | (prelude.ceu : lin 315 : col 29) | if is'(it,:vect
                    
                { // CALL | (prelude.ceu : lin 314 : col 16) | is'(it,:vector)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_vector} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 314, col 16) : is'(it,:vector)");
            
        
                } // CALL | (prelude.ceu : lin 314 : col 16) | is'(it,:vector)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 314 : col 25) | ```:pointer  
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_POINTER, {.Pointer=(   (ceux_peek(X->S,ceux_arg(X, 0) /* arg v */)).Dyn->Vector.buf)} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 314 : col 25) | ```:pointer  
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 316 : col 36) | (val it :dict
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 318 : col 29) | (val it :dict =
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_11955 */));

                    ceux_copy(X->S, (X->base + 0 + 5 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 318 : col 29) | (val it :dict =)
        
            
                { // IF | (prelude.ceu : lin 316 : col 29) | if is'(it,:dict
                    
                { // CALL | (prelude.ceu : lin 315 : col 16) | is'(it,:dict)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 5 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_dict} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 315, col 16) : is'(it,:dict)");
            
        
                } // CALL | (prelude.ceu : lin 315 : col 16) | is'(it,:dict)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 315 : col 23) | ```:pointer  
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_POINTER, {.Pointer=(   (ceux_peek(X->S,ceux_arg(X, 0) /* arg v */)).Dyn->Dict.buf)} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 315 : col 23) | ```:pointer  
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 317 : col 36) | if true nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 320 : col 29) | if true nil
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 316 : col 14) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 316 : col 14) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 318 : col 36) | (do nil)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        // PASS | (prelude.ceu : lin 318 : col 36) | (do nil)
ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 318 : col 36) | (do nil)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 317 : col 36) | if true nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 316 : col 36) | (val it :dict
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 315 : col 36) | (val it :vect
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 314 : col 36) | (val it :tupl
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 313 : col 36) | (val it :tag 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 318 : col 21) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 309 : col 21) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 324 : col 1) | (func (v) <
                    int ceu_f_type_dash_static_question_ (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 324 : col 23) | <(to-numb
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 325 : col 18) | <(to-number
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 30) /* global {{<}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 325 : col 5) | to-number(v)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 53) /* global to-number */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 325, col 5) : to-number(v)");
            
        
                } // CALL | (prelude.ceu : lin 325 : col 5) | to-number(v)
                
                    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(  CEU_VALUE_DYNAMIC)} }));
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 325, col 18) : {{<}}(to-number(v),```:number   CEU_VALUE_DYN...)");
            
        
                } // CALL | (prelude.ceu : lin 325 : col 18) | <(to-number
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 324 : col 23) | <(to-numb
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 327 : col 1) | (func (v) >
                    int ceu_f_type_dash_dynamic_question_ (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 327 : col 24) | >(to-numb
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 328 : col 18) | >(to-number
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 29) /* global {{>}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 328 : col 5) | to-number(v)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 53) /* global to-number */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 328, col 5) : to-number(v)");
            
        
                } // CALL | (prelude.ceu : lin 328 : col 5) | to-number(v)
                
                    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(  CEU_VALUE_DYNAMIC)} }));
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 328, col 18) : {{>}}(to-number(v),```:number   CEU_VALUE_DYN...)");
            
        
                } // CALL | (prelude.ceu : lin 328 : col 18) | >(to-number
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 327 : col 24) | >(to-numb
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 333 : col 1) | (func :rec (v) 
                    int ceu_f_copy (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 333 : col 20) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (prelude.ceu : lin 349 : col 21) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 350 : col 25) | (val ceu_12662 
                
                    
                { // CALL | (prelude.ceu : lin 334 : col 9) | type(v)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 334, col 9) : type(v)");
            
        
                } // CALL | (prelude.ceu : lin 334 : col 9) | type(v)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_12662 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 350 : col 25) | (val ceu_12662 )
        
            
                // DCL | (prelude.ceu : lin 336 : col 29) | (val it = ceu_1
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_12662 */));

                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 336 : col 29) | (val it = ceu_1)
        
            
                { // IF | (prelude.ceu : lin 335 : col 29) | if type-static?
                    
                { // CALL | (prelude.ceu : lin 335 : col 9) | type-static?(it
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 56) /* global type-static? */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 1) /* local it */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 335, col 9) : type-static?(it)");
            
        
                } // CALL | (prelude.ceu : lin 335 : col 9) | type-static?(it
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 335 : col 26) | v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 335 : col 26) | v
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 338 : col 36) | (val it :tupl
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 340 : col 29) | (val it :tuple 
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_12662 */));

                    ceux_copy(X->S, (X->base + 0 + 2 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 340 : col 29) | (val it :tuple )
        
            
                { // IF | (prelude.ceu : lin 339 : col 29) | if is'(it,:tupl
                    
                { // CALL | (prelude.ceu : lin 338 : col 16) | is'(it,:tuple)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_tuple} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 338, col 16) : is'(it,:tuple)");
            
        
                } // CALL | (prelude.ceu : lin 338 : col 16) | is'(it,:tuple)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 338 : col 24) | (val ret = tu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 339 : col 13) | (val ret = tupl
                
                    
                { // CALL | (prelude.ceu : lin 339 : col 23) | tuple(#(v))
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 11) /* global tuple */));

                    
                        
                { // CALL | (prelude.ceu : lin 339 : col 29) | #(v)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 13) /* global {{#}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 339, col 29) : {{#}}(v)");
            
        
                } // CALL | (prelude.ceu : lin 339 : col 29) | #(v)
                
                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 339, col 23) : tuple({{#}}(v))");
            
        
                } // CALL | (prelude.ceu : lin 339 : col 23) | tuple(#(v))
                
                    ceux_copy(X->S, (X->base + 0 + 3 + 0) /* local ret */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 339 : col 13) | (val ret = tupl)
        
            
                { // BLOCK | (prelude.ceu : lin 343 : col 29) | do (val ceu_s
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 3 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 344 : col 33) | (val ceu_ste_12
                
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                    ceux_copy(X->S, (X->base + 0 + 4 + 0) /* local ceu_ste_12545 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 344 : col 33) | (val ceu_ste_12)
        
            
                // DCL | (prelude.ceu : lin 345 : col 33) | (var i = +(
                
                    
                { // CALL | (prelude.ceu : lin 340 : col 26) | +(0,0)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 22) /* global {{+}} */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 340, col 26) : {{+}}(0,0)");
            
        
                } // CALL | (prelude.ceu : lin 340 : col 26) | +(0,0)
                
                    ceux_copy(X->S, (X->base + 0 + 4 + 1) /* local i */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 345 : col 33) | (var i = +()
        
            
                // DCL | (prelude.ceu : lin 343 : col 33) | (val ceu_lim_12
                
                    
                { // CALL | (prelude.ceu : lin 340 : col 29) | #(v)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 13) /* global {{#}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 340, col 29) : {{#}}(v)");
            
        
                } // CALL | (prelude.ceu : lin 340 : col 29) | #(v)
                
                    ceux_copy(X->S, (X->base + 0 + 4 + 2) /* local ceu_lim_12545 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 343 : col 33) | (val ceu_lim_12)
        
            
                // LOOP | (prelude.ceu : lin 341 : col 33) | loop (break(f
                CEU_LOOP_START_13077:
                    
                { // BLOCK | (prelude.ceu : lin 341 : col 33) | (break(false)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+7, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                         // BREAK | (prelude.ceu : lin 342 : col 37) | (break(false) i
                
                { // CALL | (prelude.ceu : lin 342 : col 56) | >=(i,ceu_li
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 31) /* global {{>=}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 1) /* local i */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 2) /* local ceu_lim_12545 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 342, col 56) : {{>=}}(i,ceu_lim_12545)");
            
        
                } // CALL | (prelude.ceu : lin 342 : col 56) | >=(i,ceu_li
                
                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            ceux_pop(X->S, 1);        // (2)
                            ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 342 : col 43) | false)
        
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_13077;
                    }
                }
            
                { // SET | (prelude.ceu : lin 341 : col 17) | (set ret[i] = c
                    
                { // CALL | (prelude.ceu : lin 341 : col 30) | copy(v[i])
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 58) /* global copy */));

                    
                        
                { // INDEX | (prelude.ceu : lin 341 : col 35) | v[i]
                    // IDX
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 1) /* local i */));

                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 341, col 35) : v[i]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 341, col 35) : v[i]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 341, col 30) : copy(v[i])");
            
        
                } // CALL | (prelude.ceu : lin 341 : col 30) | copy(v[i])
                  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                { // INDEX | (prelude.ceu : lin 341 : col 21) | ret[i]
                    // IDX
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 1) /* local i */));

                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 3 + 0) /* local ret */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 341, col 21) : ret[i]"
                    );
                
                        {
                            CEU_Value v = ceu_col_set(ceux_peek(X->S,XX(-1)), ceux_peek(X->S,XX(-2)), ceux_peek(X->S,XX(-3)));
                            CEU_ERROR_CHK_VAL(continue, v, "prelude.ceu : (lin 341, col 21) : ret[i]");
                            ceux_drop(X->S, 2);    // keep src
                        }
                        
                }
                  // dst should not pop src
                }
            
                { // SET | (prelude.ceu : lin 343 : col 37) | (set i = +(
                    
                { // CALL | (prelude.ceu : lin 343 : col 47) | +(i,ceu_ste
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 22) /* global {{+}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 1) /* local i */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local ceu_ste_12545 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 343, col 47) : {{+}}(i,ceu_ste_12545)");
            
        
                } // CALL | (prelude.ceu : lin 343 : col 47) | +(i,ceu_ste
                  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                        // ACC - SET | (prelude.ceu : lin 343 : col 41) | i
                        ceux_repl(X->S, (X->base + 0 + 4 + 1) /* local i */, ceux_peek(X->S,XX(-1)));
                      // dst should not pop src
                }
            
                        
                            CEU_LOOP_STOP_13077:
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 341 : col 33) | (break(false)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : ) !CEU_BREAK ? 0 :  0;
                        ceux_block_leave(X->S, X->base+7, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    if (CEU_BREAK) {
                        CEU_BREAK = 0;
                    } else {
                        //ceux_pop(X->S, 1);
                        goto CEU_LOOP_START_13077;
                    }
            
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 343 : col 29) | do (val ceu_s
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+4, 3, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 3 + 0) /* local ret */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 338 : col 24) | (val ret = tu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 345 : col 36) | if true err
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 348 : col 29) | if true error
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 345 : col 14) | error(:TODO)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 346 : col 13) | error(:TODO)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 1) /* global error */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_TODO} });
                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 346, col 13) : error(:TODO)");
            
        
                } // CALL | (prelude.ceu : lin 346 : col 13) | error(:TODO)
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 345 : col 14) | error(:TODO)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 348 : col 36) | (do nil)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        // PASS | (prelude.ceu : lin 348 : col 36) | (do nil)
ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 348 : col 36) | (do nil)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 345 : col 36) | if true err
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 338 : col 36) | (val it :tupl
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 349 : col 21) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 333 : col 20) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 351 : col 1) | (func (col,tp) 
                    int ceu_f_to_dash_vector (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 351 : col 26) | (val ret = #[
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 352 : col 5) | (val ret = #[])
                
                    
                { // VECTOR | (prelude.ceu : lin 352 : col 15) | #[]
                    ceux_push(X->S, 1, ceu_create_vector());
                    
                }
            
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ret */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 352 : col 5) | (val ret = #[]))
        
            
                { // BLOCK | (prelude.ceu : lin 356 : col 29) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 357 : col 33) | (val ceu_13249 
                
                    
                { // CALL | (prelude.ceu : lin 357 : col 49) | to-iter(to-iter
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 43) /* global to-iter */));

                    
                        
                { // CALL | (prelude.ceu : lin 353 : col 15) | to-iter(col,tp)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 43) /* global to-iter */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg col */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg tp */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 353, col 15) : to-iter(col,tp)");
            
        
                } // CALL | (prelude.ceu : lin 353 : col 15) | to-iter(col,tp)
                
                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 357, col 49) : to-iter(to-iter(col,tp))");
            
        
                } // CALL | (prelude.ceu : lin 357 : col 49) | to-iter(to-iter
                
                    ceux_copy(X->S, (X->base + 0 + 1 + 0) /* local ceu_13249 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 357 : col 33) | (val ceu_13249 )
        
            
                // LOOP | (prelude.ceu : lin 354 : col 33) | loop (val v =
                CEU_LOOP_START_13472:
                    
                { // BLOCK | (prelude.ceu : lin 354 : col 33) | (val v = ceu_
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 355 : col 37) | (val v = ceu_13
                
                    
                { // CALL | (prelude.ceu : lin 353 : col 14) | ceu_13249[0](ce
                    
                { // INDEX | (prelude.ceu : lin 353 : col 14) | ceu_13249[0]
                    // IDX
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_13249 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 353, col 14) : ceu_13249[0]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 353, col 14) : ceu_13249[0]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_13249 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 353, col 14) : ceu_13249[0](ceu_13249)");
            
        
                } // CALL | (prelude.ceu : lin 353 : col 14) | ceu_13249[0](ce
                
                    ceux_copy(X->S, (X->base + 0 + 2 + 0) /* local v */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 355 : col 37) | (val v = ceu_13)
        
             // BREAK | (prelude.ceu : lin 354 : col 37) | (break(false) i
                
                { // CALL | (prelude.ceu : lin 354 : col 56) | ==(v,nil)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local v */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 354, col 56) : {{==}}(v,nil)");
            
        
                } // CALL | (prelude.ceu : lin 354 : col 56) | ==(v,nil)
                
                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            ceux_pop(X->S, 1);        // (2)
                            ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 354 : col 43) | false)
        
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_13472;
                    }
                }
            
                { // BLOCK | (prelude.ceu : lin 355 : col 29) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 354 : col 24) | (val ceu_13159 
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ret */));

                    ceux_copy(X->S, (X->base + 0 + 3 + 0) /* local ceu_13159 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 354 : col 24) | (val ceu_13159 )
        
            
                { // SET | (prelude.ceu : lin 355 : col 33) | (set ceu_13159[
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local v */));
  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                { // INDEX | (prelude.ceu : lin 355 : col 37) | ceu_13159[#
                    // IDX
                    
                { // CALL | (prelude.ceu : lin 355 : col 47) | #(ceu_13159
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 13) /* global {{#}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 3 + 0) /* local ceu_13159 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 355, col 47) : {{#}}(ceu_13159)");
            
        
                } // CALL | (prelude.ceu : lin 355 : col 47) | #(ceu_13159
                
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 3 + 0) /* local ceu_13159 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 355, col 37) : ceu_13159[{{#}}(ceu_13159)]"
                    );
                
                        {
                            CEU_Value v = ceu_col_set(ceux_peek(X->S,XX(-1)), ceux_peek(X->S,XX(-2)), ceux_peek(X->S,XX(-3)));
                            CEU_ERROR_CHK_VAL(continue, v, "prelude.ceu : (lin 355, col 37) : ceu_13159[{{#}}(ceu_13159)]");
                            ceux_drop(X->S, 2);    // keep src
                        }
                        
                }
                  // dst should not pop src
                }
            
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 355 : col 29) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+3, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                            CEU_LOOP_STOP_13472:
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 354 : col 33) | (val v = ceu_
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : ) !CEU_BREAK ? 0 :  0;
                        ceux_block_leave(X->S, X->base+2, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    if (CEU_BREAK) {
                        CEU_BREAK = 0;
                    } else {
                        //ceux_pop(X->S, 1);
                        goto CEU_LOOP_START_13472;
                    }
            
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 356 : col 29) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+1, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ret */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 351 : col 26) | (val ret = #[
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 379 : col 1) | (func (col) (
                    int ceu_f_to_dash_set (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 379 : col 19) | (val ret = @[
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 380 : col 5) | (val ret = @[])
                
                    
                { // DICT | (prelude.ceu : lin 380 : col 15) | @[]
                    ceux_push(X->S, 1, ceu_create_dict());
                    
                }
            
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ret */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 380 : col 5) | (val ret = @[]))
        
            
                { // BLOCK | (prelude.ceu : lin 384 : col 29) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 385 : col 33) | (val ceu_13521 
                
                    
                { // CALL | (prelude.ceu : lin 385 : col 49) | to-iter(to-iter
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 43) /* global to-iter */));

                    
                        
                { // CALL | (prelude.ceu : lin 381 : col 13) | to-iter(col)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 43) /* global to-iter */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg col */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 381, col 13) : to-iter(col)");
            
        
                } // CALL | (prelude.ceu : lin 381 : col 13) | to-iter(col)
                
                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 385, col 49) : to-iter(to-iter(col))");
            
        
                } // CALL | (prelude.ceu : lin 385 : col 49) | to-iter(to-iter
                
                    ceux_copy(X->S, (X->base + 0 + 1 + 0) /* local ceu_13521 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 385 : col 33) | (val ceu_13521 )
        
            
                // LOOP | (prelude.ceu : lin 382 : col 33) | loop (val it 
                CEU_LOOP_START_13700:
                    
                { // BLOCK | (prelude.ceu : lin 382 : col 33) | (val it = ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 383 : col 37) | (val it = ceu_1
                
                    
                { // CALL | (prelude.ceu : lin 381 : col 10) | ceu_13521[0](ce
                    
                { // INDEX | (prelude.ceu : lin 381 : col 10) | ceu_13521[0]
                    // IDX
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_13521 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 381, col 10) : ceu_13521[0]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 381, col 10) : ceu_13521[0]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_13521 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 381, col 10) : ceu_13521[0](ceu_13521)");
            
        
                } // CALL | (prelude.ceu : lin 381 : col 10) | ceu_13521[0](ce
                
                    ceux_copy(X->S, (X->base + 0 + 2 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 383 : col 37) | (val it = ceu_1)
        
             // BREAK | (prelude.ceu : lin 382 : col 37) | (break(false) i
                
                { // CALL | (prelude.ceu : lin 382 : col 57) | ==(it,nil)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 382, col 57) : {{==}}(it,nil)");
            
        
                } // CALL | (prelude.ceu : lin 382 : col 57) | ==(it,nil)
                
                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            ceux_pop(X->S, 1);        // (2)
                            ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 382 : col 43) | false)
        
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_13700;
                    }
                }
            
                { // SET | (prelude.ceu : lin 382 : col 9) | (set ret[it] = 
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                { // INDEX | (prelude.ceu : lin 382 : col 13) | ret[it]
                    // IDX
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local it */));

                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ret */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 382, col 13) : ret[it]"
                    );
                
                        {
                            CEU_Value v = ceu_col_set(ceux_peek(X->S,XX(-1)), ceux_peek(X->S,XX(-2)), ceux_peek(X->S,XX(-3)));
                            CEU_ERROR_CHK_VAL(continue, v, "prelude.ceu : (lin 382, col 13) : ret[it]");
                            ceux_drop(X->S, 2);    // keep src
                        }
                        
                }
                  // dst should not pop src
                }
            
                        
                            CEU_LOOP_STOP_13700:
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 382 : col 33) | (val it = ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : ) !CEU_BREAK ? 0 :  0;
                        ceux_block_leave(X->S, X->base+2, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    if (CEU_BREAK) {
                        CEU_BREAK = 0;
                    } else {
                        //ceux_pop(X->S, 1);
                        goto CEU_LOOP_START_13700;
                    }
            
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 384 : col 29) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+1, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ret */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 379 : col 19) | (val ret = @[
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 391 : col 1) | (func (v1,v2) 
                    int ceu_f_less_plus_plus (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 391 : col 23) | assert(==
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 392 : col 5) | assert(==(t
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 33) /* global assert */));

                    
                        
                { // CALL | (prelude.ceu : lin 392 : col 21) | ==(type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 392 : col 12) | type(v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 392, col 12) : type(v1)");
            
        
                } // CALL | (prelude.ceu : lin 392 : col 12) | type(v1)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_vector} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 392, col 21) : {{==}}(type(v1),:vector)");
            
        
                } // CALL | (prelude.ceu : lin 392 : col 21) | ==(type(v1)
                
                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 392, col 5) : assert({{==}}(type(v1),:vector))");
            
        
                } // CALL | (prelude.ceu : lin 392 : col 5) | assert(==(t
                
                { // CALL | (prelude.ceu : lin 393 : col 5) | assert(==(t
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 33) /* global assert */));

                    
                        
                { // CALL | (prelude.ceu : lin 393 : col 21) | ==(type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 393 : col 12) | type(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 12) /* global type */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 393, col 12) : type(v2)");
            
        
                } // CALL | (prelude.ceu : lin 393 : col 12) | type(v2)
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_vector} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 393, col 21) : {{==}}(type(v2),:vector)");
            
        
                } // CALL | (prelude.ceu : lin 393 : col 21) | ==(type(v2)
                
                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 393, col 5) : assert({{==}}(type(v2),:vector))");
            
        
                } // CALL | (prelude.ceu : lin 393 : col 5) | assert(==(t
                
                { // BLOCK | (prelude.ceu : lin 394 : col 5) | do do (val 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (prelude.ceu : lin 398 : col 29) | do (val ceu_s
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 3 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 399 : col 33) | (val ceu_ste_13
                
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_ste_13877 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 399 : col 33) | (val ceu_ste_13)
        
            
                // DCL | (prelude.ceu : lin 400 : col 33) | (var i = +(
                
                    
                { // CALL | (prelude.ceu : lin 395 : col 22) | +(0,0)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 22) /* global {{+}} */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 395, col 22) : {{+}}(0,0)");
            
        
                } // CALL | (prelude.ceu : lin 395 : col 22) | +(0,0)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local i */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 400 : col 33) | (var i = +()
        
            
                // DCL | (prelude.ceu : lin 398 : col 33) | (val ceu_lim_13
                
                    
                { // CALL | (prelude.ceu : lin 395 : col 25) | #(v2)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 13) /* global {{#}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 395, col 25) : {{#}}(v2)");
            
        
                } // CALL | (prelude.ceu : lin 395 : col 25) | #(v2)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 2) /* local ceu_lim_13877 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 398 : col 33) | (val ceu_lim_13)
        
            
                // LOOP | (prelude.ceu : lin 396 : col 33) | loop (break(f
                CEU_LOOP_START_14170:
                    
                { // BLOCK | (prelude.ceu : lin 396 : col 33) | (break(false)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                         // BREAK | (prelude.ceu : lin 397 : col 37) | (break(false) i
                
                { // CALL | (prelude.ceu : lin 397 : col 56) | >=(i,ceu_li
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 31) /* global {{>=}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 1) /* local i */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 2) /* local ceu_lim_13877 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 397, col 56) : {{>=}}(i,ceu_lim_13877)");
            
        
                } // CALL | (prelude.ceu : lin 397 : col 56) | >=(i,ceu_li
                
                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            ceux_pop(X->S, 1);        // (2)
                            ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 397 : col 43) | false)
        
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_14170;
                    }
                }
            
                { // BLOCK | (prelude.ceu : lin 397 : col 29) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (prelude.ceu : lin 396 : col 27) | (val ceu_13777 
                
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                    ceux_copy(X->S, (X->base + 0 + 3 + 0) /* local ceu_13777 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 396 : col 27) | (val ceu_13777 )
        
            
                { // SET | (prelude.ceu : lin 397 : col 33) | (set ceu_13777[
                    
                { // INDEX | (prelude.ceu : lin 396 : col 25) | v2[i]
                    // IDX
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 1) /* local i */));

                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 396, col 25) : v2[i]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "prelude.ceu : (lin 396, col 25) : v2[i]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                { // INDEX | (prelude.ceu : lin 397 : col 37) | ceu_13777[#
                    // IDX
                    
                { // CALL | (prelude.ceu : lin 397 : col 47) | #(ceu_13777
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 13) /* global {{#}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 3 + 0) /* local ceu_13777 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 397, col 47) : {{#}}(ceu_13777)");
            
        
                } // CALL | (prelude.ceu : lin 397 : col 47) | #(ceu_13777
                
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 3 + 0) /* local ceu_13777 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "prelude.ceu : (lin 397, col 37) : ceu_13777[{{#}}(ceu_13777)]"
                    );
                
                        {
                            CEU_Value v = ceu_col_set(ceux_peek(X->S,XX(-1)), ceux_peek(X->S,XX(-2)), ceux_peek(X->S,XX(-3)));
                            CEU_ERROR_CHK_VAL(continue, v, "prelude.ceu : (lin 397, col 37) : ceu_13777[{{#}}(ceu_13777)]");
                            ceux_drop(X->S, 2);    // keep src
                        }
                        
                }
                  // dst should not pop src
                }
            
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 397 : col 29) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+3, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                { // SET | (prelude.ceu : lin 399 : col 37) | (set i = +(
                    
                { // CALL | (prelude.ceu : lin 399 : col 47) | +(i,ceu_ste
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 22) /* global {{+}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 1) /* local i */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_ste_13877 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 399, col 47) : {{+}}(i,ceu_ste_13877)");
            
        
                } // CALL | (prelude.ceu : lin 399 : col 47) | +(i,ceu_ste
                  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                        // ACC - SET | (prelude.ceu : lin 399 : col 41) | i
                        ceux_repl(X->S, (X->base + 0 + 0 + 1) /* local i */, ceux_peek(X->S,XX(-1)));
                      // dst should not pop src
                }
            
                        
                            CEU_LOOP_STOP_14170:
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 396 : col 33) | (break(false)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : ) !CEU_BREAK ? 0 :  0;
                        ceux_block_leave(X->S, X->base+3, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    if (CEU_BREAK) {
                        CEU_BREAK = 0;
                    } else {
                        //ceux_pop(X->S, 1);
                        goto CEU_LOOP_START_14170;
                    }
            
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 398 : col 29) | do (val ceu_s
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 3, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 394 : col 5) | do do (val 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 391 : col 23) | assert(==
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 402 : col 1) | (func (v1,v2) 
                    int ceu_f_plus_plus (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 402 : col 22) | <++(<++
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 403 : col 18) | <++(<++
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 61) /* global {{<++}} */));

                    
                        
                { // CALL | (prelude.ceu : lin 403 : col 10) | <++(#[],v1)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 61) /* global {{<++}} */));

                    
                        
                { // VECTOR | (prelude.ceu : lin 403 : col 6) | #[]
                    ceux_push(X->S, 1, ceu_create_vector());
                    
                }
            
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v1 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 403, col 10) : {{<++}}(#[],v1)");
            
        
                } // CALL | (prelude.ceu : lin 403 : col 10) | <++(#[],v1)
                
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg v2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 403, col 18) : {{<++}}({{<++}}(#[],v1),v2)");
            
        
                } // CALL | (prelude.ceu : lin 403 : col 18) | <++(<++
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 402 : col 22) | <++(<++
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 409 : col 5) | (func (v) f(g
                    int ceu_f_14315 (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 409 : col 14) | f(g(v))
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (prelude.ceu : lin 410 : col 9) | f(g(v))
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0) /* upval f */));

                    
                        
                { // CALL | (prelude.ceu : lin 410 : col 11) | g(v)
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 1) /* upval g */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg v */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 410, col 11) : g(v)");
            
        
                } // CALL | (prelude.ceu : lin 410 : col 11) | g(v)
                
                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 410, col 9) : f(g(v))");
            
        
                } // CALL | (prelude.ceu : lin 410 : col 9) | f(g(v))
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 409 : col 14) | f(g(v))
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 408 : col 1) | (func (f,g) (
                    int ceu_f_less_bar_less (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 408 : col 20) | (func (v) f
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                         // CREATE | (prelude.ceu : lin 409 : col 5) | (func (v) f(g
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_14315,
                        1,  // TODO: remove assert
                        0,
                        2
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 2
                    
                    {
                        CEU_Value up = ceux_peek(X->S, ceux_arg(X, 0) /* arg f */);
                        ceu_gc_inc_val(up);
                        clo.Dyn->Clo.upvs.buf[0] = up;
                    }
                    

                    {
                        CEU_Value up = ceux_peek(X->S, ceux_arg(X, 1) /* arg g */);
                        ceu_gc_inc_val(up);
                        clo.Dyn->Clo.upvs.buf[1] = up;
                    }
                    
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 408 : col 20) | (func (v) f
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 418 : col 1) | (func (n) if 
                    int ceu_f_random_dash_seed (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 418 : col 22) | if n ```sra
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (prelude.ceu : lin 419 : col 5) | if n ```srand
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg n */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (prelude.ceu : lin 419 : col 10) | ```srand($n.N
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        srand((ceux_peek(X->S,ceux_arg(X, 0) /* arg n */)).Number);

                        
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 420, col 9) : ```srand($n.Number);```");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 419 : col 10) | ```srand($n.N
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (prelude.ceu : lin 421 : col 12) | ```srand(time
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        srand(time(NULL));

                        
            CEU_ERROR_CHK_STK(continue, "prelude.ceu : (lin 422, col 9) : ```srand(time(NULL));```");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 421 : col 12) | ```srand(time
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 418 : col 22) | if n ```sra
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 426 : col 1) | (func () ```:
                    int ceu_f_random_dash_next (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 426 : col 21) | ```:number   
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(  rand())} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 426 : col 21) | ```:number   
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 430 : col 1) | (func (v) ```
                    int ceu_f_math_dash_sin (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 430 : col 19) | ```:number   
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(  sin((ceux_peek(X->S,ceux_arg(X, 0) /* arg v */)).Number))} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 430 : col 19) | ```:number   
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (prelude.ceu : lin 434 : col 1) | (func (v) ```
                    int ceu_f_math_dash_cos (CEUX* X) {
                        
                        do {
                { // BLOCK | (prelude.ceu : lin 434 : col 19) | ```:number   
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(  cos((ceux_peek(X->S,ceux_arg(X, 0) /* arg v */)).Number))} }));
                        
                    } while (0);

                    // BLOCK (escape) | (prelude.ceu : lin 434 : col 19) | ```:number   
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 438 : col 1) | (func (v) ```
                    int ceu_f_math_dash_floor (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 438 : col 21) | ```:number   
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(  floor((ceux_peek(X->S,ceux_arg(X, 0) /* arg v */)).Number))} }));
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 438 : col 21) | ```:number   
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 61 : col 1) | (func (ms) ``
                    int ceu_f_pico_dash_input_dash_delay (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 61 : col 28) | ```pico_input
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        pico_input_delay((ceux_peek(X->S,ceux_arg(X, 0) /* arg ms */)).Number);

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 62, col 5) : ```pico_input_delay($ms.Number);```");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 61 : col 28) | ```pico_input
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 65 : col 1) | (func (sdl) `
                    int ceu_f_pico_dash_event_dash_sdl_dash_ceu (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 65 : col 31) | ```SDL_Event*
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        SDL_Event* evt = (SDL_Event*) (ceux_peek(X->S,ceux_arg(X, 0) /* arg sdl */)).Pointer;

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 66, col 5) : ```SDL_Event* evt = (SDL_Event*) $sdl.Pointer...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 66 : col 5) | ```SDL_Event* e)
        
                // DCL | (@/pico/pico.ceu : lin 67 : col 5) | (val tp = ```:t
                
                    ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_TAG, {.Tag=(  evt->type)} }));
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local tp */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 67 : col 5) | (val tp = ```:t)
        
            
                { // BLOCK | (@/pico/pico.ceu : lin 91 : col 21) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 92 : col 25) | (val ceu_15263 
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local tp */));

                    ceux_copy(X->S, (X->base + 0 + 1 + 0) /* local ceu_15263 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 92 : col 25) | (val ceu_15263 )
        
            
                // DCL | (@/pico/pico.ceu : lin 70 : col 29) | (val it = ceu_1
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_15263 */));

                    ceux_copy(X->S, (X->base + 0 + 1 + 1) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 70 : col 29) | (val it = ceu_1)
        
            
                { // IF | (@/pico/pico.ceu : lin 69 : col 29) | if is'(it,```:t
                    
                { // CALL | (@/pico/pico.ceu : lin 69 : col 13) | is'(it,```:tag 
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 1) /* local it */));

                    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_TAG, {.Tag=(      SDL_QUIT)} }));
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 69, col 13) : is'(it,```:tag       SDL_QUIT```)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 69 : col 13) | is'(it,```:tag 
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 69 : col 38) | tags([],:Pico
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (@/pico/pico.ceu : lin 70 : col 13) | tags([],:Pico.Q
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 6) /* global tags */));

                    
                        
                { // TUPLE | (@/pico/pico.ceu : lin 70 : col 24) | []
                    ceux_push(X->S, 1, ceu_create_tuple(0));
                    
                }
            
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Pico_Quit} });
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                                        
                    

                    ceux_call(X, 3, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 70, col 13) : tags([],:Pico.Quit,true)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 70 : col 13) | tags([],:Pico.Q
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 69 : col 38) | tags([],:Pico
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 72 : col 36) | (val it = ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 74 : col 29) | (val it = ceu_1
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_15263 */));

                    ceux_copy(X->S, (X->base + 0 + 3 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 74 : col 29) | (val it = ceu_1)
        
            
                { // IF | (@/pico/pico.ceu : lin 71 : col 29) | if is'(it,```:t
                    
                { // CALL | (@/pico/pico.ceu : lin 71 : col 13) | is'(it,```:tag 
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 3 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_TAG, {.Tag=(      SDL_MOUSEMOTION)} }));
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 71, col 13) : is'(it,```:tag       SDL_MOUSEMOTION```)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 71 : col 13) | is'(it,```:tag 
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 71 : col 45) | tags([[```:nu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (@/pico/pico.ceu : lin 72 : col 13) | tags([[```:numb
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 6) /* global tags */));

                    
                        
                { // TUPLE | (@/pico/pico.ceu : lin 72 : col 32) | [[```:number   
                    ceux_push(X->S, 1, ceu_create_tuple(1));
                    
                { // TUPLE | (@/pico/pico.ceu : lin 73 : col 17) | [```:number    
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(    evt->button.x)} }));
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(    evt->button.y)} }));
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Pico_Mouse_Motion} });
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                                        
                    

                    ceux_call(X, 3, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 72, col 13) : tags([[```:number     evt->button.x```,```:nu...)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 72 : col 13) | tags([[```:numb
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 71 : col 45) | tags([[```:nu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 75 : col 36) | (val it = ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 77 : col 29) | (val it = ceu_1
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_15263 */));

                    ceux_copy(X->S, (X->base + 0 + 4 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 77 : col 29) | (val it = ceu_1)
        
            
                { // IF | (@/pico/pico.ceu : lin 75 : col 29) | if is'(it,```:t
                    
                { // CALL | (@/pico/pico.ceu : lin 75 : col 13) | is'(it,```:tag 
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_TAG, {.Tag=(      SDL_MOUSEBUTTONDOWN)} }));
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 75, col 13) : is'(it,```:tag       SDL_MOUSEBUTTONDOWN```)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 75 : col 13) | is'(it,```:tag 
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 75 : col 49) | tags([[```:nu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (@/pico/pico.ceu : lin 76 : col 13) | tags([[```:numb
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 6) /* global tags */));

                    
                        
                { // TUPLE | (@/pico/pico.ceu : lin 76 : col 35) | [[```:number   
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    
                { // TUPLE | (@/pico/pico.ceu : lin 77 : col 17) | [```:number    
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(    evt->button.x)} }));
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(    evt->button.y)} }));
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_TAG, {.Tag=(    evt->button.button)} }));
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Pico_Mouse_Button_Dn} });
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                                        
                    

                    ceux_call(X, 3, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 76, col 13) : tags([[```:number     evt->button.x```,```:nu...)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 76 : col 13) | tags([[```:numb
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 75 : col 49) | tags([[```:nu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 80 : col 36) | (val it = ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 82 : col 29) | (val it = ceu_1
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_15263 */));

                    ceux_copy(X->S, (X->base + 0 + 5 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 82 : col 29) | (val it = ceu_1)
        
            
                { // IF | (@/pico/pico.ceu : lin 80 : col 29) | if is'(it,```:t
                    
                { // CALL | (@/pico/pico.ceu : lin 80 : col 13) | is'(it,```:tag 
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 5 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_TAG, {.Tag=(      SDL_MOUSEBUTTONUP)} }));
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 80, col 13) : is'(it,```:tag       SDL_MOUSEBUTTONUP```)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 80 : col 13) | is'(it,```:tag 
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 80 : col 47) | tags([[```:nu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (@/pico/pico.ceu : lin 81 : col 13) | tags([[```:numb
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 6) /* global tags */));

                    
                        
                { // TUPLE | (@/pico/pico.ceu : lin 81 : col 35) | [[```:number   
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    
                { // TUPLE | (@/pico/pico.ceu : lin 82 : col 17) | [```:number    
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(    evt->button.x)} }));
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(    evt->button.y)} }));
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_TAG, {.Tag=(    evt->button.button)} }));
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Pico_Mouse_Button_Up} });
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                                        
                    

                    ceux_call(X, 3, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 81, col 13) : tags([[```:number     evt->button.x```,```:nu...)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 81 : col 13) | tags([[```:numb
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 80 : col 47) | tags([[```:nu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 85 : col 36) | (val it = ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 87 : col 29) | (val it = ceu_1
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_15263 */));

                    ceux_copy(X->S, (X->base + 0 + 6 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 87 : col 29) | (val it = ceu_1)
        
            
                { // IF | (@/pico/pico.ceu : lin 85 : col 29) | if is'(it,```:t
                    
                { // CALL | (@/pico/pico.ceu : lin 85 : col 13) | is'(it,```:tag 
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 6 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_TAG, {.Tag=(      SDL_KEYDOWN)} }));
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 85, col 13) : is'(it,```:tag       SDL_KEYDOWN```)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 85 : col 13) | is'(it,```:tag 
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 85 : col 41) | tags([```:tag
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+7, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (@/pico/pico.ceu : lin 86 : col 13) | tags([```:tag  
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 6) /* global tags */));

                    
                        
                { // TUPLE | (@/pico/pico.ceu : lin 86 : col 26) | [```:tag     ev
                    ceux_push(X->S, 1, ceu_create_tuple(1));
                    ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_TAG, {.Tag=(    evt->key.keysym.sym)} }));
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Pico_Key_Dn} });
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                                        
                    

                    ceux_call(X, 3, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 86, col 13) : tags([```:tag     evt->key.keysym.sym```],:Pi...)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 86 : col 13) | tags([```:tag  
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 85 : col 41) | tags([```:tag
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+7, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 88 : col 36) | (val it = ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+7, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 90 : col 29) | (val it = ceu_1
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_15263 */));

                    ceux_copy(X->S, (X->base + 0 + 7 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 90 : col 29) | (val it = ceu_1)
        
            
                { // IF | (@/pico/pico.ceu : lin 87 : col 29) | if is'(it,```:t
                    
                { // CALL | (@/pico/pico.ceu : lin 87 : col 13) | is'(it,```:tag 
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 7 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_TAG, {.Tag=(      SDL_KEYUP)} }));
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 87, col 13) : is'(it,```:tag       SDL_KEYUP```)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 87 : col 13) | is'(it,```:tag 
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 87 : col 39) | tags([```:tag
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+8, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (@/pico/pico.ceu : lin 88 : col 13) | tags([```:tag  
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 6) /* global tags */));

                    
                        
                { // TUPLE | (@/pico/pico.ceu : lin 88 : col 26) | [```:tag     ev
                    ceux_push(X->S, 1, ceu_create_tuple(1));
                    ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_TAG, {.Tag=(    evt->key.keysym.sym)} }));
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Pico_Key_Up} });
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                                        
                    

                    ceux_call(X, 3, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 88, col 13) : tags([```:tag     evt->key.keysym.sym```],:Pi...)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 88 : col 13) | tags([```:tag  
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 87 : col 39) | tags([```:tag
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+8, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 90 : col 36) | if true err
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+8, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (@/pico/pico.ceu : lin 93 : col 29) | if true error
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 89 : col 14) | error(:error)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+8, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (@/pico/pico.ceu : lin 89 : col 17) | error(:error)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 1) /* global error */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_error} });
                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 89, col 17) : error(:error)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 89 : col 17) | error(:error)
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 89 : col 14) | error(:error)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+8, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 91 : col 36) | (do nil)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+8, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        // PASS | (@/pico/pico.ceu : lin 91 : col 36) | (do nil)
ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 91 : col 36) | (do nil)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+8, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 90 : col 36) | if true err
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+8, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 88 : col 36) | (val it = ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+7, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 85 : col 36) | (val it = ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 80 : col 36) | (val it = ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 75 : col 36) | (val it = ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 72 : col 36) | (val it = ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 91 : col 21) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 65 : col 31) | ```SDL_Event*
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 93 : col 1) | (func (tag) `
                    int ceu_f_pico_dash_input_dash_event (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 93 : col 29) | ```        i
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
        int tag_to_type (int tag) {
            switch (tag) {
                case CEU_TAG_Pico_Any:
                    return SDL_ANY;
                case CEU_TAG_Pico_Quit:
                    return SDL_QUIT;
                case CEU_TAG_Pico_Key_Dn:
                    return SDL_KEYDOWN;
                case CEU_TAG_Pico_Key_Up:
                    return SDL_KEYUP;
                case CEU_TAG_Pico_Mouse_Motion:
                    return SDL_MOUSEMOTION;
                case CEU_TAG_Pico_Mouse_Button_Dn:
                    return SDL_MOUSEBUTTONDOWN;
                case CEU_TAG_Pico_Mouse_Button_Up:
                    return SDL_MOUSEBUTTONUP;
                default:
                    assert(0 && "bug found : missing tag -> type");
            }
        }

        SDL_Event sdl;
        int type = tag_to_type((ceux_peek(X->S,ceux_arg(X, 0) /* arg tag */)).Tag);
        pico_input_event(&sdl,type);
    

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 94, col 5) : ```         int tag_to_type (int tag) {      ...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 94 : col 5) | ```        int)
        
                { // CALL | (@/pico/pico.ceu : lin 120 : col 5) | pico-event-sdl-
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 72) /* global pico-event-sdl-ceu */));

                    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_POINTER, {.Pointer=(  &sdl)} }));
                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 120, col 5) : pico-event-sdl-ceu(```:pointer   &sdl```)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 120 : col 5) | pico-event-sdl-
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 93 : col 29) | ```        i
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 123 : col 1) | (func (tp,time)
                    int ceu_f_pico_dash_input_dash_event_dash_timeout (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 123 : col 42) | ```SDL_Event 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        SDL_Event sdl;

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 124, col 5) : ```SDL_Event sdl;```");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 124 : col 5) | ```SDL_Event sd)
        
                // DCL | (@/pico/pico.ceu : lin 125 : col 5) | (val ok = ```:b
                
                    ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_BOOL, {.Bool=(  pico_input_event_timeout(&sdl,(ceux_peek(X->S,ceux_arg(X, 0) /* arg tp */)).Tag,(ceux_peek(X->S,ceux_arg(X, 1) /* arg time */)).Number))} }));
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ok */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 125 : col 5) | (val ok = ```:b)
        
            
                // DCL | (@/pico/pico.ceu : lin 126 : col 5) | (val sdl = ```:
                
                    ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_POINTER, {.Pointer=(  &sdl)} }));
                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local sdl */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 126 : col 5) | (val sdl = ```:)
        
            
                { // BLOCK | (@/pico/pico.ceu : lin 128 : col 21) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 129 : col 25) | (val ceu_15980 
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ok */));

                    ceux_copy(X->S, (X->base + 0 + 2 + 0) /* local ceu_15980 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 129 : col 25) | (val ceu_15980 )
        
            
                { // IF | (@/pico/pico.ceu : lin 128 : col 25) | if ceu_15980 
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local ceu_15980 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 128 : col 38) | pico-event-sd
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (@/pico/pico.ceu : lin 127 : col 12) | pico-event-sdl-
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 72) /* global pico-event-sdl-ceu */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 1) /* local sdl */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg tp */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 127, col 12) : pico-event-sdl-ceu(sdl,tp)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 127 : col 12) | pico-event-sdl-
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 128 : col 38) | pico-event-sd
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 128 : col 32) | ceu_15980
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local ceu_15980 */));

                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 128 : col 32) | ceu_15980
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 128 : col 21) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 123 : col 42) | ```SDL_Event 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 132 : col 1) | (func () ```p
                    int ceu_f_pico_dash_output_dash_clear (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 132 : col 27) | ```pico_outpu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        pico_output_clear();

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 133, col 5) : ```pico_output_clear();```");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 132 : col 27) | ```pico_outpu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 136 : col 1) | (func (pos :XY,
                    int ceu_f_pico_dash_output_dash_draw_dash_image (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 136 : col 48) | (val x = pos[
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 3 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 137 : col 5) | (val x = pos[:x
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 137 : col 13) | pos[:x]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg pos */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 137, col 13) : pos[:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 137, col 13) : pos[:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local x */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 137 : col 5) | (val x = pos[:x)
        
            
                // DCL | (@/pico/pico.ceu : lin 138 : col 5) | (val y = pos[:y
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 138 : col 13) | pos[:y]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg pos */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 138, col 13) : pos[:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 138, col 13) : pos[:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local y */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 138 : col 5) | (val y = pos[:y)
        
            
                // DCL | (@/pico/pico.ceu : lin 139 : col 5) | (val xcache = d
                
                    
                { // BLOCK | (@/pico/pico.ceu : lin 140 : col 21) | do (val ceu_1
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 141 : col 25) | (val ceu_16170 
                
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 2) /* arg cache */));

                    ceux_copy(X->S, (X->base + 0 + 3 + 0) /* local ceu_16170 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 141 : col 25) | (val ceu_16170 )
        
            
                { // IF | (@/pico/pico.ceu : lin 140 : col 25) | if ceu_16170 
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 3 + 0) /* local ceu_16170 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 140 : col 38) | ceu_16170
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 3 + 0) /* local ceu_16170 */));

                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 140 : col 38) | ceu_16170
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 142 : col 32) | ==(cache,
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (@/pico/pico.ceu : lin 139 : col 34) | ==(cache,ni
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 2) /* arg cache */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 139, col 34) : {{==}}(cache,nil)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 139 : col 34) | ==(cache,ni
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 142 : col 32) | ==(cache,
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 140 : col 21) | do (val ceu_1
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 2) /* local xcache */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 139 : col 5) | (val xcache = d)
        
            _pico_output_draw_image_cache((SDL_Point){(ceux_peek(X->S,(X->base + 0 + 0 + 0) /* local x */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 1) /* local y */)).Number}, (char*)(ceux_peek(X->S,ceux_arg(X, 1) /* arg img */)).Dyn->Vector.buf, (ceux_peek(X->S,(X->base + 0 + 0 + 2) /* local xcache */)).Bool);

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 140, col 5) : ```_pico_output_draw_image_cache((SDL_Point){...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 136 : col 48) | (val x = pos[
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 3, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 143 : col 1) | (func (p1 :XY,p
                    int ceu_f_pico_dash_output_dash_draw_dash_line (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 143 : col 43) | (val x1 = p1[
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 4 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 144 : col 5) | (val x1 = p1[:x
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 144 : col 14) | p1[:x]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg p1 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 144, col 14) : p1[:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 144, col 14) : p1[:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local x1 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 144 : col 5) | (val x1 = p1[:x)
        
            
                // DCL | (@/pico/pico.ceu : lin 145 : col 5) | (val y1 = p1[:y
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 145 : col 14) | p1[:y]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg p1 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 145, col 14) : p1[:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 145, col 14) : p1[:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local y1 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 145 : col 5) | (val y1 = p1[:y)
        
            
                // DCL | (@/pico/pico.ceu : lin 146 : col 5) | (val x2 = p2[:x
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 146 : col 14) | p2[:x]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg p2 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 146, col 14) : p2[:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 146, col 14) : p2[:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 2) /* local x2 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 146 : col 5) | (val x2 = p2[:x)
        
            
                // DCL | (@/pico/pico.ceu : lin 147 : col 5) | (val y2 = p2[:y
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 147 : col 14) | p2[:y]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg p2 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 147, col 14) : p2[:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 147, col 14) : p2[:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 3) /* local y2 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 147 : col 5) | (val y2 = p2[:y)
        
            pico_output_draw_line((SDL_Point){(ceux_peek(X->S,(X->base + 0 + 0 + 0) /* local x1 */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 1) /* local y1 */)).Number},
                           (SDL_Point){(ceux_peek(X->S,(X->base + 0 + 0 + 2) /* local x2 */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 3) /* local y2 */)).Number});

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 148, col 5) : ```pico_output_draw_line((SDL_Point){$x1.Numb...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 143 : col 43) | (val x1 = p1[
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 4, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 152 : col 1) | (func (r :Rect)
                    int ceu_f_pico_dash_output_dash_draw_dash_rect (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 152 : col 37) | (val x = r[:p
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 4 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 153 : col 5) | (val x = r[:pos
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 153 : col 13) | r[:pos][:x]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 153 : col 13) | r[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 153, col 13) : r[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 153, col 13) : r[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 153, col 13) : r[:pos][:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 153, col 13) : r[:pos][:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local x */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 153 : col 5) | (val x = r[:pos)
        
            
                // DCL | (@/pico/pico.ceu : lin 154 : col 5) | (val y = r[:pos
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 154 : col 13) | r[:pos][:y]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 154 : col 13) | r[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 154, col 13) : r[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 154, col 13) : r[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 154, col 13) : r[:pos][:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 154, col 13) : r[:pos][:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local y */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 154 : col 5) | (val y = r[:pos)
        
            
                // DCL | (@/pico/pico.ceu : lin 155 : col 5) | (val w = r[:dim
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 155 : col 13) | r[:dim][:w]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 155 : col 13) | r[:dim]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 155, col 13) : r[:dim]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 155, col 13) : r[:dim]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 155, col 13) : r[:dim][:w]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 155, col 13) : r[:dim][:w]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 2) /* local w */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 155 : col 5) | (val w = r[:dim)
        
            
                // DCL | (@/pico/pico.ceu : lin 156 : col 5) | (val h = r[:dim
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 156 : col 13) | r[:dim][:h]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 156 : col 13) | r[:dim]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 156, col 13) : r[:dim]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 156, col 13) : r[:dim]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 156, col 13) : r[:dim][:h]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 156, col 13) : r[:dim][:h]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 3) /* local h */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 156 : col 5) | (val h = r[:dim)
        
            pico_output_draw_rect((SDL_Rect){(ceux_peek(X->S,(X->base + 0 + 0 + 0) /* local x */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 1) /* local y */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 2) /* local w */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 3) /* local h */)).Number});

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 157, col 5) : ```pico_output_draw_rect((SDL_Rect){$x.Number...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 152 : col 37) | (val x = r[:p
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 4, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 160 : col 1) | (func (r :Rect)
                    int ceu_f_pico_dash_output_dash_draw_dash_oval (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 160 : col 37) | (val x = r[:p
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 4 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 161 : col 5) | (val x = r[:pos
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 161 : col 13) | r[:pos][:x]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 161 : col 13) | r[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 161, col 13) : r[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 161, col 13) : r[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 161, col 13) : r[:pos][:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 161, col 13) : r[:pos][:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local x */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 161 : col 5) | (val x = r[:pos)
        
            
                // DCL | (@/pico/pico.ceu : lin 162 : col 5) | (val y = r[:pos
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 162 : col 13) | r[:pos][:y]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 162 : col 13) | r[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 162, col 13) : r[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 162, col 13) : r[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 162, col 13) : r[:pos][:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 162, col 13) : r[:pos][:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local y */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 162 : col 5) | (val y = r[:pos)
        
            
                // DCL | (@/pico/pico.ceu : lin 163 : col 5) | (val w = r[:dim
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 163 : col 13) | r[:dim][:w]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 163 : col 13) | r[:dim]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 163, col 13) : r[:dim]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 163, col 13) : r[:dim]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 163, col 13) : r[:dim][:w]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 163, col 13) : r[:dim][:w]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 2) /* local w */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 163 : col 5) | (val w = r[:dim)
        
            
                // DCL | (@/pico/pico.ceu : lin 164 : col 5) | (val h = r[:dim
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 164 : col 13) | r[:dim][:h]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 164 : col 13) | r[:dim]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 164, col 13) : r[:dim]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 164, col 13) : r[:dim]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 164, col 13) : r[:dim][:h]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 164, col 13) : r[:dim][:h]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 3) /* local h */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 164 : col 5) | (val h = r[:dim)
        
            pico_output_draw_oval((SDL_Rect){(ceux_peek(X->S,(X->base + 0 + 0 + 0) /* local x */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 1) /* local y */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 2) /* local w */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 3) /* local h */)).Number});

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 165, col 5) : ```pico_output_draw_oval((SDL_Rect){$x.Number...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 160 : col 37) | (val x = r[:p
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 4, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 168 : col 1) | (func (pos :XY)
                    int ceu_f_pico_dash_output_dash_draw_dash_pixel (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 168 : col 38) | (val x = pos[
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 169 : col 5) | (val x = pos[:x
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 169 : col 13) | pos[:x]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg pos */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 169, col 13) : pos[:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 169, col 13) : pos[:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local x */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 169 : col 5) | (val x = pos[:x)
        
            
                // DCL | (@/pico/pico.ceu : lin 170 : col 5) | (val y = pos[:y
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 170 : col 13) | pos[:y]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg pos */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 170, col 13) : pos[:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 170, col 13) : pos[:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local y */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 170 : col 5) | (val y = pos[:y)
        
            pico_output_draw_pixel((SDL_Point){(ceux_peek(X->S,(X->base + 0 + 0 + 0) /* local x */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 1) /* local y */)).Number});

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 171, col 5) : ```pico_output_draw_pixel((SDL_Point){$x.Numb...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 168 : col 38) | (val x = pos[
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 174 : col 1) | (func (pos :XY,
                    int ceu_f_pico_dash_output_dash_draw_dash_text (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 174 : col 42) | (val x = pos[
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 175 : col 5) | (val x = pos[:x
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 175 : col 13) | pos[:x]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg pos */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 175, col 13) : pos[:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 175, col 13) : pos[:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local x */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 175 : col 5) | (val x = pos[:x)
        
            
                // DCL | (@/pico/pico.ceu : lin 176 : col 5) | (val y = pos[:y
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 176 : col 13) | pos[:y]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg pos */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 176, col 13) : pos[:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 176, col 13) : pos[:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local y */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 176 : col 5) | (val y = pos[:y)
        
            pico_output_draw_text((SDL_Point){(ceux_peek(X->S,(X->base + 0 + 0 + 0) /* local x */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 1) /* local y */)).Number}, (ceux_peek(X->S,ceux_arg(X, 1) /* arg txt */)).Dyn->Vector.buf);

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 177, col 5) : ```pico_output_draw_text((SDL_Point){$x.Numbe...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 174 : col 42) | (val x = pos[
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 180 : col 1) | (func () ```p
                    int ceu_f_pico_dash_output_dash_present (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 180 : col 29) | ```pico_outpu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        pico_output_present();

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 181, col 5) : ```pico_output_present();```");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 180 : col 29) | ```pico_outpu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 184 : col 1) | (func (path) 
                    int ceu_f_pico_dash_output_dash_sound (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 184 : col 31) | ```pico_outpu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        pico_output_sound((ceux_peek(X->S,ceux_arg(X, 0) /* arg path */)).Dyn->Vector.buf);

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 185, col 5) : ```pico_output_sound($path.Dyn->Vector.buf);`...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 184 : col 31) | ```pico_outpu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 188 : col 1) | (func (txt) `
                    int ceu_f_pico_dash_output_dash_write (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 188 : col 30) | ```pico_outpu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        pico_output_write((ceux_peek(X->S,ceux_arg(X, 0) /* arg txt */)).Dyn->Vector.buf);

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 189, col 5) : ```pico_output_write($txt.Dyn->Vector.buf);``...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 188 : col 30) | ```pico_outpu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 192 : col 1) | (func (txt) `
                    int ceu_f_pico_dash_output_dash_writeln (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 192 : col 32) | ```pico_outpu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        pico_output_writeln((ceux_peek(X->S,ceux_arg(X, 0) /* arg txt */)).Dyn->Vector.buf);

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 193, col 5) : ```pico_output_writeln($txt.Dyn->Vector.buf);...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 192 : col 32) | ```pico_outpu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 200 : col 1) | (func () /
                    int ceu_f_pico_dash_state_dash_get_dash_fps (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 200 : col 28) | /(1000,PI
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (@/pico/pico.ceu : lin 201 : col 10) | /(1000,PICO
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 26) /* global {{/}} */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1000} });
                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 201 : col 12) | PICO[:mpf]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 70) /* global PICO */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 201, col 12) : PICO[:mpf]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 201, col 12) : PICO[:mpf]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 201, col 10) : {{/}}(1000,PICO[:mpf])");
            
        
                } // CALL | (@/pico/pico.ceu : lin 201 : col 10) | /(1000,PICO
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 200 : col 28) | /(1000,PI
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 204 : col 1) | (func () ```
                    int ceu_f_pico_dash_state_dash_get_dash_size (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 204 : col 29) | ```        S
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
        SDL_Point sz;
        pico_state_get_size(&sz);
    

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 205, col 5) : ```         SDL_Point sz;         pico_state_...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 205 : col 5) | ```        SDL)
        
                { // TUPLE | (@/pico/pico.ceu : lin 209 : col 5) | [```:number   s
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(  sz.x)} }));
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(  sz.y)} }));
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 204 : col 29) | ```        S
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 212 : col 1) | (func (img) `
                    int ceu_f_pico_dash_state_dash_get_dash_size_dash_image (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 212 : col 38) | ```        S
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
        SDL_Point sz;
        pico_state_get_size_image((char*)(ceux_peek(X->S,ceux_arg(X, 0) /* arg img */)).Dyn->Vector.buf, &sz);
    

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 213, col 5) : ```         SDL_Point sz;         pico_state_...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 213 : col 5) | ```        SDL)
        
                { // TUPLE | (@/pico/pico.ceu : lin 217 : col 5) | [```:number   s
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(  sz.x)} }));
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(  sz.y)} }));
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 212 : col 38) | ```        S
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 222 : col 1) | (func (fps) (
                    int ceu_f_pico_dash_state_dash_set_dash_fps (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 222 : col 31) | (set PICO[:mp
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // SET | (@/pico/pico.ceu : lin 223 : col 5) | (set PICO[:mpf]
                    
                { // CALL | (@/pico/pico.ceu : lin 223 : col 25) | /(1000,fps)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 26) /* global {{/}} */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1000} });
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg fps */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 223, col 25) : {{/}}(1000,fps)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 223 : col 25) | /(1000,fps)
                  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                { // INDEX | (@/pico/pico.ceu : lin 223 : col 9) | PICO[:mpf]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 70) /* global PICO */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 223, col 9) : PICO[:mpf]"
                    );
                
                        {
                            CEU_Value v = ceu_col_set(ceux_peek(X->S,XX(-1)), ceux_peek(X->S,XX(-2)), ceux_peek(X->S,XX(-3)));
                            CEU_ERROR_CHK_VAL(continue, v, "@/pico/pico.ceu : (lin 223, col 9) : PICO[:mpf]");
                            ceux_drop(X->S, 2);    // keep src
                        }
                        
                }
                  // dst should not pop src
                }
            
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 222 : col 31) | (set PICO[:mp
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 226 : col 1) | (func (h,v) `
                    int ceu_f_pico_dash_state_dash_set_dash_anchor (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 226 : col 34) | ```pico_state
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        pico_state_set_anchor((ceux_peek(X->S,ceux_arg(X, 0) /* arg h */)).Tag,(ceux_peek(X->S,ceux_arg(X, 1) /* arg v */)).Tag);

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 227, col 5) : ```pico_state_set_anchor($h.Tag,$v.Tag);```");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 226 : col 34) | ```pico_state
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 230 : col 1) | (func (on) ``
                    int ceu_f_pico_dash_state_dash_set_dash_auto (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 230 : col 31) | ```pico_state
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        pico_state_set_auto((ceux_peek(X->S,ceux_arg(X, 0) /* arg on */)).Bool);

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 231, col 5) : ```pico_state_set_auto($on.Bool);```");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 230 : col 31) | ```pico_state
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 234 : col 1) | (func (clr :RGB
                    int ceu_f_pico_dash_state_dash_set_dash_color_dash_clear (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 234 : col 44) | (val r = clr[
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 4 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 235 : col 5) | (val r = clr[:r
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 235 : col 13) | clr[:r]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg clr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 235, col 13) : clr[:r]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 235, col 13) : clr[:r]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local r */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 235 : col 5) | (val r = clr[:r)
        
            
                // DCL | (@/pico/pico.ceu : lin 236 : col 5) | (val g = clr[:g
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 236 : col 13) | clr[:g]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg clr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 236, col 13) : clr[:g]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 236, col 13) : clr[:g]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local g */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 236 : col 5) | (val g = clr[:g)
        
            
                // DCL | (@/pico/pico.ceu : lin 237 : col 5) | (val b = clr[:b
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 237 : col 13) | clr[:b]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=2} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg clr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 237, col 13) : clr[:b]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 237, col 13) : clr[:b]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 2) /* local b */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 237 : col 5) | (val b = clr[:b)
        
            
                // DCL | (@/pico/pico.ceu : lin 238 : col 5) | (val a = clr[:a
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 238 : col 13) | clr[:a]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=3} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg clr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 238, col 13) : clr[:a]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 238, col 13) : clr[:a]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 3) /* local a */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 238 : col 5) | (val a = clr[:a)
        
            pico_state_set_color_clear((SDL_Color){(ceux_peek(X->S,(X->base + 0 + 0 + 0) /* local r */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 1) /* local g */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 2) /* local b */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 3) /* local a */)).Number});

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 239, col 5) : ```pico_state_set_color_clear((SDL_Color){$r....)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 234 : col 44) | (val r = clr[
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 4, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 242 : col 1) | (func (clr :RGB
                    int ceu_f_pico_dash_state_dash_set_dash_color_dash_draw (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 242 : col 43) | (val r = clr[
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 4 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 243 : col 5) | (val r = clr[:r
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 243 : col 13) | clr[:r]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg clr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 243, col 13) : clr[:r]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 243, col 13) : clr[:r]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local r */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 243 : col 5) | (val r = clr[:r)
        
            
                // DCL | (@/pico/pico.ceu : lin 244 : col 5) | (val g = clr[:g
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 244 : col 13) | clr[:g]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg clr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 244, col 13) : clr[:g]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 244, col 13) : clr[:g]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local g */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 244 : col 5) | (val g = clr[:g)
        
            
                // DCL | (@/pico/pico.ceu : lin 245 : col 5) | (val b = clr[:b
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 245 : col 13) | clr[:b]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=2} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg clr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 245, col 13) : clr[:b]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 245, col 13) : clr[:b]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 2) /* local b */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 245 : col 5) | (val b = clr[:b)
        
            
                // DCL | (@/pico/pico.ceu : lin 246 : col 5) | (val a = clr[:a
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 246 : col 13) | clr[:a]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=3} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg clr */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 246, col 13) : clr[:a]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 246, col 13) : clr[:a]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 3) /* local a */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 246 : col 5) | (val a = clr[:a)
        
            pico_state_set_color_draw((SDL_Color){(ceux_peek(X->S,(X->base + 0 + 0 + 0) /* local r */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 1) /* local g */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 2) /* local b */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 3) /* local a */)).Number});

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 247, col 5) : ```pico_state_set_color_draw((SDL_Color){$r.N...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 242 : col 43) | (val r = clr[
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 4, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 250 : col 1) | (func (pos :XY)
                    int ceu_f_pico_dash_state_dash_set_dash_cursor (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 250 : col 37) | (val x = pos[
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 251 : col 5) | (val x = pos[:x
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 251 : col 13) | pos[:x]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg pos */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 251, col 13) : pos[:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 251, col 13) : pos[:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local x */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 251 : col 5) | (val x = pos[:x)
        
            
                // DCL | (@/pico/pico.ceu : lin 252 : col 5) | (val y = pos[:y
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 252 : col 13) | pos[:y]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg pos */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 252, col 13) : pos[:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 252, col 13) : pos[:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local y */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 252 : col 5) | (val y = pos[:y)
        
            pico_state_set_cursor((SDL_Point){(ceux_peek(X->S,(X->base + 0 + 0 + 0) /* local x */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 1) /* local y */)).Number});

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 253, col 5) : ```pico_state_set_cursor((SDL_Point){$x.Numbe...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 250 : col 37) | (val x = pos[
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 256 : col 1) | (func (file,h) 
                    int ceu_f_pico_dash_state_dash_set_dash_font (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 256 : col 36) | ```pico_state
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        pico_state_set_font((ceux_peek(X->S,ceux_arg(X, 0) /* arg file */)).Dyn->Vector.buf,(ceux_peek(X->S,ceux_arg(X, 1) /* arg h */)).Number);

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 257, col 5) : ```pico_state_set_font($file.Dyn->Vector.buf,...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 256 : col 36) | ```pico_state
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 260 : col 1) | (func (on) ``
                    int ceu_f_pico_dash_state_dash_set_dash_grid (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 260 : col 31) | ```pico_state
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        pico_state_set_grid((ceux_peek(X->S,ceux_arg(X, 0) /* arg on */)).Bool);

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 261, col 5) : ```pico_state_set_grid($on.Bool);```");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 260 : col 31) | ```pico_state
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 264 : col 1) | (func (r :Rect)
                    int ceu_f_pico_dash_state_dash_set_dash_image_dash_crop (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 264 : col 41) | if ==(r,n
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (@/pico/pico.ceu : lin 265 : col 5) | if ==(r,nil
                    
                { // CALL | (@/pico/pico.ceu : lin 265 : col 10) | ==(r,nil)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg r */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 265, col 10) : {{==}}(r,nil)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 265 : col 10) | ==(r,nil)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 265 : col 17) | ```pico_state
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        pico_state_set_image_crop((SDL_Rect){0,0,0,0});

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 266, col 9) : ```pico_state_set_image_crop((SDL_Rect){0,0,0...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 265 : col 17) | ```pico_state
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 267 : col 12) | (val x = r[:p
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 4 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 268 : col 9) | (val x = r[:pos
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 268 : col 17) | r[:pos][:x]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 268 : col 17) | r[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 268, col 17) : r[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 268, col 17) : r[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 268, col 17) : r[:pos][:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 268, col 17) : r[:pos][:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local x */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 268 : col 9) | (val x = r[:pos)
        
            
                // DCL | (@/pico/pico.ceu : lin 269 : col 9) | (val y = r[:pos
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 269 : col 17) | r[:pos][:y]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 269 : col 17) | r[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 269, col 17) : r[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 269, col 17) : r[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 269, col 17) : r[:pos][:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 269, col 17) : r[:pos][:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local y */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 269 : col 9) | (val y = r[:pos)
        
            
                // DCL | (@/pico/pico.ceu : lin 270 : col 9) | (val w = r[:dim
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 270 : col 17) | r[:dim][:w]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 270 : col 17) | r[:dim]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 270, col 17) : r[:dim]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 270, col 17) : r[:dim]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 270, col 17) : r[:dim][:w]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 270, col 17) : r[:dim][:w]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 2) /* local w */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 270 : col 9) | (val w = r[:dim)
        
            
                // DCL | (@/pico/pico.ceu : lin 271 : col 9) | (val h = r[:dim
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 271 : col 17) | r[:dim][:h]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 271 : col 17) | r[:dim]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 271, col 17) : r[:dim]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 271, col 17) : r[:dim]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 271, col 17) : r[:dim][:h]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 271, col 17) : r[:dim][:h]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 3) /* local h */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 271 : col 9) | (val h = r[:dim)
        
            pico_state_set_image_crop((SDL_Rect){(ceux_peek(X->S,(X->base + 0 + 0 + 0) /* local x */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 1) /* local y */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 2) /* local w */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 3) /* local h */)).Number});

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 272, col 9) : ```pico_state_set_image_crop((SDL_Rect){$x.Nu...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 267 : col 12) | (val x = r[:p
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 4, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 264 : col 41) | if ==(r,n
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 276 : col 1) | (func (pos :XY)
                    int ceu_f_pico_dash_state_dash_set_dash_pan (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 276 : col 34) | (val x = pos[
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 277 : col 5) | (val x = pos[:x
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 277 : col 13) | pos[:x]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg pos */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 277, col 13) : pos[:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 277, col 13) : pos[:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local x */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 277 : col 5) | (val x = pos[:x)
        
            
                // DCL | (@/pico/pico.ceu : lin 278 : col 5) | (val y = pos[:y
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 278 : col 13) | pos[:y]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg pos */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 278, col 13) : pos[:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 278, col 13) : pos[:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local y */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 278 : col 5) | (val y = pos[:y)
        
            pico_state_set_pan((SDL_Point){(ceux_peek(X->S,(X->base + 0 + 0 + 0) /* local x */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 1) /* local y */)).Number});

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 279, col 5) : ```pico_state_set_pan((SDL_Point){$x.Number,$...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 276 : col 34) | (val x = pos[
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 282 : col 1) | (func (dim :WH)
                    int ceu_f_pico_dash_state_dash_set_dash_size (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 282 : col 35) | (val w = dim[
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 283 : col 5) | (val w = dim[:w
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 283 : col 13) | dim[:w]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg dim */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 283, col 13) : dim[:w]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 283, col 13) : dim[:w]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local w */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 283 : col 5) | (val w = dim[:w)
        
            
                // DCL | (@/pico/pico.ceu : lin 284 : col 5) | (val h = dim[:h
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 284 : col 13) | dim[:h]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg dim */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 284, col 13) : dim[:h]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 284, col 13) : dim[:h]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local h */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 284 : col 5) | (val h = dim[:h)
        
            pico_state_set_size((SDL_Point){(ceux_peek(X->S,(X->base + 0 + 0 + 0) /* local w */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 1) /* local h */)).Number});

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 285, col 5) : ```pico_state_set_size((SDL_Point){$w.Number,...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 282 : col 35) | (val w = dim[
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 288 : col 1) | (func (dim :WH)
                    int ceu_f_pico_dash_state_dash_set_dash_size_dash_image (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 288 : col 41) | (val w = dim[
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 289 : col 5) | (val w = dim[:w
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 289 : col 13) | dim[:w]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg dim */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 289, col 13) : dim[:w]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 289, col 13) : dim[:w]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local w */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 289 : col 5) | (val w = dim[:w)
        
            
                // DCL | (@/pico/pico.ceu : lin 290 : col 5) | (val h = dim[:h
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 290 : col 13) | dim[:h]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg dim */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 290, col 13) : dim[:h]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 290, col 13) : dim[:h]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local h */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 290 : col 5) | (val h = dim[:h)
        
            pico_state_set_size_image((SDL_Point){(ceux_peek(X->S,(X->base + 0 + 0 + 0) /* local w */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 1) /* local h */)).Number});

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 291, col 5) : ```pico_state_set_size_image((SDL_Point){$w.N...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 288 : col 41) | (val w = dim[
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 294 : col 1) | (func (dim :WH)
                    int ceu_f_pico_dash_state_dash_set_dash_size_dash_pixel (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 294 : col 41) | (val w = dim[
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 295 : col 5) | (val w = dim[:w
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 295 : col 13) | dim[:w]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg dim */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 295, col 13) : dim[:w]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 295, col 13) : dim[:w]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local w */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 295 : col 5) | (val w = dim[:w)
        
            
                // DCL | (@/pico/pico.ceu : lin 296 : col 5) | (val h = dim[:h
                
                    
                { // INDEX | (@/pico/pico.ceu : lin 296 : col 13) | dim[:h]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg dim */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 296, col 13) : dim[:h]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 296, col 13) : dim[:h]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local h */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 296 : col 5) | (val h = dim[:h)
        
            pico_state_set_size_pixel((SDL_Point){(ceux_peek(X->S,(X->base + 0 + 0 + 0) /* local w */)).Number,(ceux_peek(X->S,(X->base + 0 + 0 + 1) /* local h */)).Number});

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 297, col 5) : ```pico_state_set_size_pixel((SDL_Point){$w.N...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 294 : col 41) | (val w = dim[
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 300 : col 1) | (func (title) 
                    int ceu_f_pico_dash_state_dash_set_dash_title (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 300 : col 35) | ```pico_state
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        pico_state_set_title((ceux_peek(X->S,ceux_arg(X, 0) /* arg title */)).Dyn->Vector.buf);

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 301, col 5) : ```pico_state_set_title($title.Dyn->Vector.bu...)");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 300 : col 35) | ```pico_state
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 306 : col 1) | (func (pt :XY,r
                    int ceu_f_pico_dash_point_dash_vs_dash_rect_question_ (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 306 : col 42) | do if <
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (@/pico/pico.ceu : lin 314 : col 21) | do if <(p
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (@/pico/pico.ceu : lin 318 : col 29) | if <(pt[:x]
                    
                { // CALL | (@/pico/pico.ceu : lin 308 : col 14) | <(pt[:x],
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 30) /* global {{<}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 308 : col 9) | pt[:x]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg pt */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 308, col 9) : pt[:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 308, col 9) : pt[:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        
                { // CALL | (@/pico/pico.ceu : lin 308 : col 24) | -(r[:pos][:
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 23) /* global {{-}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 308 : col 17) | r[:pos][:x]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 308 : col 17) | r[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 308, col 17) : r[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 308, col 17) : r[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 308, col 17) : r[:pos][:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 308, col 17) : r[:pos][:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        
                { // CALL | (@/pico/pico.ceu : lin 308 : col 33) | /(r[:dim][:
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 26) /* global {{/}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 308 : col 26) | r[:dim][:w]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 308 : col 26) | r[:dim]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 308, col 26) : r[:dim]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 308, col 26) : r[:dim]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 308, col 26) : r[:dim][:w]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 308, col 26) : r[:dim][:w]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=2} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 308, col 33) : {{/}}(r[:dim][:w],2)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 308 : col 33) | /(r[:dim][:
                
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 308, col 24) : {{-}}(r[:pos][:x],{{/}}(r[:dim][:w],2))");
            
        
                } // CALL | (@/pico/pico.ceu : lin 308 : col 24) | -(r[:pos][:
                
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 308, col 14) : {{<}}(pt[:x],{{-}}(r[:pos][:x],{{/}}(r[:dim][...)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 308 : col 14) | <(pt[:x],
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 308 : col 39) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 308 : col 39) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 310 : col 36) | if >(pt[:
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (@/pico/pico.ceu : lin 313 : col 29) | if >(pt[:x]
                    
                { // CALL | (@/pico/pico.ceu : lin 309 : col 14) | >(pt[:x],
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 29) /* global {{>}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 309 : col 9) | pt[:x]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg pt */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 309, col 9) : pt[:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 309, col 9) : pt[:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        
                { // CALL | (@/pico/pico.ceu : lin 309 : col 24) | +(r[:pos][:
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 22) /* global {{+}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 309 : col 17) | r[:pos][:x]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 309 : col 17) | r[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 309, col 17) : r[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 309, col 17) : r[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 309, col 17) : r[:pos][:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 309, col 17) : r[:pos][:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        
                { // CALL | (@/pico/pico.ceu : lin 309 : col 33) | /(r[:dim][:
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 26) /* global {{/}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 309 : col 26) | r[:dim][:w]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 309 : col 26) | r[:dim]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 309, col 26) : r[:dim]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 309, col 26) : r[:dim]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 309, col 26) : r[:dim][:w]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 309, col 26) : r[:dim][:w]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=2} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 309, col 33) : {{/}}(r[:dim][:w],2)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 309 : col 33) | /(r[:dim][:
                
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 309, col 24) : {{+}}(r[:pos][:x],{{/}}(r[:dim][:w],2))");
            
        
                } // CALL | (@/pico/pico.ceu : lin 309 : col 24) | +(r[:pos][:
                
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 309, col 14) : {{>}}(pt[:x],{{+}}(r[:pos][:x],{{/}}(r[:dim][...)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 309 : col 14) | >(pt[:x],
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 309 : col 39) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 309 : col 39) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 311 : col 36) | if <(pt[:
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (@/pico/pico.ceu : lin 314 : col 29) | if <(pt[:y]
                    
                { // CALL | (@/pico/pico.ceu : lin 310 : col 14) | <(pt[:y],
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 30) /* global {{<}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 310 : col 9) | pt[:y]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg pt */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 310, col 9) : pt[:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 310, col 9) : pt[:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        
                { // CALL | (@/pico/pico.ceu : lin 310 : col 24) | -(r[:pos][:
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 23) /* global {{-}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 310 : col 17) | r[:pos][:y]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 310 : col 17) | r[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 310, col 17) : r[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 310, col 17) : r[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 310, col 17) : r[:pos][:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 310, col 17) : r[:pos][:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        
                { // CALL | (@/pico/pico.ceu : lin 310 : col 33) | /(r[:dim][:
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 26) /* global {{/}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 310 : col 26) | r[:dim][:h]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 310 : col 26) | r[:dim]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 310, col 26) : r[:dim]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 310, col 26) : r[:dim]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 310, col 26) : r[:dim][:h]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 310, col 26) : r[:dim][:h]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=2} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 310, col 33) : {{/}}(r[:dim][:h],2)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 310 : col 33) | /(r[:dim][:
                
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 310, col 24) : {{-}}(r[:pos][:y],{{/}}(r[:dim][:h],2))");
            
        
                } // CALL | (@/pico/pico.ceu : lin 310 : col 24) | -(r[:pos][:
                
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 310, col 14) : {{<}}(pt[:y],{{-}}(r[:pos][:y],{{/}}(r[:dim][...)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 310 : col 14) | <(pt[:y],
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 310 : col 39) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 310 : col 39) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 312 : col 36) | if >(pt[:
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (@/pico/pico.ceu : lin 315 : col 29) | if >(pt[:y]
                    
                { // CALL | (@/pico/pico.ceu : lin 311 : col 14) | >(pt[:y],
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 29) /* global {{>}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 311 : col 9) | pt[:y]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg pt */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 311, col 9) : pt[:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 311, col 9) : pt[:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        
                { // CALL | (@/pico/pico.ceu : lin 311 : col 24) | +(r[:pos][:
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 22) /* global {{+}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 311 : col 17) | r[:pos][:y]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 311 : col 17) | r[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 311, col 17) : r[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 311, col 17) : r[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 311, col 17) : r[:pos][:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 311, col 17) : r[:pos][:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        
                { // CALL | (@/pico/pico.ceu : lin 311 : col 33) | /(r[:dim][:
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 26) /* global {{/}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 311 : col 26) | r[:dim][:h]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 311 : col 26) | r[:dim]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg r */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 311, col 26) : r[:dim]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 311, col 26) : r[:dim]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 311, col 26) : r[:dim][:h]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 311, col 26) : r[:dim][:h]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=2} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 311, col 33) : {{/}}(r[:dim][:h],2)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 311 : col 33) | /(r[:dim][:
                
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 311, col 24) : {{+}}(r[:pos][:y],{{/}}(r[:dim][:h],2))");
            
        
                } // CALL | (@/pico/pico.ceu : lin 311 : col 24) | +(r[:pos][:
                
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 311, col 14) : {{>}}(pt[:y],{{+}}(r[:pos][:y],{{/}}(r[:dim][...)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 311 : col 14) | >(pt[:y],
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 311 : col 39) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 311 : col 39) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 313 : col 36) | if true tru
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (@/pico/pico.ceu : lin 316 : col 29) | if true true
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 312 : col 14) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 312 : col 14) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 314 : col 36) | (do nil)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        // PASS | (@/pico/pico.ceu : lin 314 : col 36) | (do nil)
ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 314 : col 36) | (do nil)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 313 : col 36) | if true tru
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 312 : col 36) | if >(pt[:
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 311 : col 36) | if <(pt[:
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 310 : col 36) | if >(pt[:
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 314 : col 21) | do if <(p
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 306 : col 42) | do if <
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 316 : col 1) | (func (r1 :Rect
                    int ceu_f_pico_dash_rect_dash_vs_dash_rect_question_ (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 316 : col 44) | do (val w2 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (@/pico/pico.ceu : lin 323 : col 7) | do (val w2 = 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 6 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 324 : col 9) | (val w2 = /
                
                    
                { // CALL | (@/pico/pico.ceu : lin 324 : col 27) | /(r2[:dim][
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 26) /* global {{/}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 324 : col 18) | r2[:dim][:w]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 324 : col 18) | r2[:dim]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg r2 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 324, col 18) : r2[:dim]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 324, col 18) : r2[:dim]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 324, col 18) : r2[:dim][:w]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 324, col 18) : r2[:dim][:w]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=2} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 324, col 27) : {{/}}(r2[:dim][:w],2)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 324 : col 27) | /(r2[:dim][
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local w2 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 324 : col 9) | (val w2 = /)
        
            
                // DCL | (@/pico/pico.ceu : lin 325 : col 9) | (val h2 = /
                
                    
                { // CALL | (@/pico/pico.ceu : lin 325 : col 27) | /(r2[:dim][
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 26) /* global {{/}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 325 : col 18) | r2[:dim][:h]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 325 : col 18) | r2[:dim]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg r2 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 325, col 18) : r2[:dim]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 325, col 18) : r2[:dim]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 325, col 18) : r2[:dim][:h]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 325, col 18) : r2[:dim][:h]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=2} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 325, col 27) : {{/}}(r2[:dim][:h],2)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 325 : col 27) | /(r2[:dim][
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local h2 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 325 : col 9) | (val h2 = /)
        
            
                // DCL | (@/pico/pico.ceu : lin 326 : col 9) | (val p1 = [-
                
                    
                { // TUPLE | (@/pico/pico.ceu : lin 326 : col 18) | [-(r2[:pos]
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    
                { // CALL | (@/pico/pico.ceu : lin 326 : col 28) | -(r2[:pos][
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 23) /* global {{-}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 326 : col 19) | r2[:pos][:x]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 326 : col 19) | r2[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg r2 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 326, col 19) : r2[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 326, col 19) : r2[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 326, col 19) : r2[:pos][:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 326, col 19) : r2[:pos][:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local w2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 326, col 28) : {{-}}(r2[:pos][:x],w2)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 326 : col 28) | -(r2[:pos][
                
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                { // CALL | (@/pico/pico.ceu : lin 326 : col 43) | -(r2[:pos][
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 23) /* global {{-}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 326 : col 34) | r2[:pos][:y]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 326 : col 34) | r2[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg r2 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 326, col 34) : r2[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 326, col 34) : r2[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 326, col 34) : r2[:pos][:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 326, col 34) : r2[:pos][:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 1) /* local h2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 326, col 43) : {{-}}(r2[:pos][:y],h2)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 326 : col 43) | -(r2[:pos][
                
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    ceux_copy(X->S, (X->base + 0 + 0 + 2) /* local p1 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 326 : col 9) | (val p1 = [-)
        
            
                // DCL | (@/pico/pico.ceu : lin 327 : col 9) | (val p2 = [-
                
                    
                { // TUPLE | (@/pico/pico.ceu : lin 327 : col 18) | [-(r2[:pos]
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    
                { // CALL | (@/pico/pico.ceu : lin 327 : col 28) | -(r2[:pos][
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 23) /* global {{-}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 327 : col 19) | r2[:pos][:x]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 327 : col 19) | r2[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg r2 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 327, col 19) : r2[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 327, col 19) : r2[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 327, col 19) : r2[:pos][:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 327, col 19) : r2[:pos][:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local w2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 327, col 28) : {{-}}(r2[:pos][:x],w2)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 327 : col 28) | -(r2[:pos][
                
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                { // CALL | (@/pico/pico.ceu : lin 327 : col 43) | +(r2[:pos][
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 22) /* global {{+}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 327 : col 34) | r2[:pos][:y]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 327 : col 34) | r2[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg r2 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 327, col 34) : r2[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 327, col 34) : r2[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 327, col 34) : r2[:pos][:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 327, col 34) : r2[:pos][:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 1) /* local h2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 327, col 43) : {{+}}(r2[:pos][:y],h2)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 327 : col 43) | +(r2[:pos][
                
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    ceux_copy(X->S, (X->base + 0 + 0 + 3) /* local p2 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 327 : col 9) | (val p2 = [-)
        
            
                // DCL | (@/pico/pico.ceu : lin 328 : col 9) | (val p3 = [+
                
                    
                { // TUPLE | (@/pico/pico.ceu : lin 328 : col 18) | [+(r2[:pos]
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    
                { // CALL | (@/pico/pico.ceu : lin 328 : col 28) | +(r2[:pos][
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 22) /* global {{+}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 328 : col 19) | r2[:pos][:x]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 328 : col 19) | r2[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg r2 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 328, col 19) : r2[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 328, col 19) : r2[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 328, col 19) : r2[:pos][:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 328, col 19) : r2[:pos][:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local w2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 328, col 28) : {{+}}(r2[:pos][:x],w2)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 328 : col 28) | +(r2[:pos][
                
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                { // CALL | (@/pico/pico.ceu : lin 328 : col 43) | +(r2[:pos][
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 22) /* global {{+}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 328 : col 34) | r2[:pos][:y]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 328 : col 34) | r2[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg r2 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 328, col 34) : r2[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 328, col 34) : r2[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 328, col 34) : r2[:pos][:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 328, col 34) : r2[:pos][:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 1) /* local h2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 328, col 43) : {{+}}(r2[:pos][:y],h2)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 328 : col 43) | +(r2[:pos][
                
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    ceux_copy(X->S, (X->base + 0 + 0 + 4) /* local p3 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 328 : col 9) | (val p3 = [+)
        
            
                // DCL | (@/pico/pico.ceu : lin 329 : col 9) | (val p4 = [+
                
                    
                { // TUPLE | (@/pico/pico.ceu : lin 329 : col 18) | [+(r2[:pos]
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    
                { // CALL | (@/pico/pico.ceu : lin 329 : col 28) | +(r2[:pos][
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 22) /* global {{+}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 329 : col 19) | r2[:pos][:x]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 329 : col 19) | r2[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg r2 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 329, col 19) : r2[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 329, col 19) : r2[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 329, col 19) : r2[:pos][:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 329, col 19) : r2[:pos][:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local w2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 329, col 28) : {{+}}(r2[:pos][:x],w2)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 329 : col 28) | +(r2[:pos][
                
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                { // CALL | (@/pico/pico.ceu : lin 329 : col 43) | -(r2[:pos][
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 23) /* global {{-}} */));

                    
                        
                { // INDEX | (@/pico/pico.ceu : lin 329 : col 34) | r2[:pos][:y]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    
                { // INDEX | (@/pico/pico.ceu : lin 329 : col 34) | r2[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg r2 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 329, col 34) : r2[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 329, col 34) : r2[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 329, col 34) : r2[:pos][:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 329, col 34) : r2[:pos][:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 1) /* local h2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 329, col 43) : {{-}}(r2[:pos][:y],h2)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 329 : col 43) | -(r2[:pos][
                
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    ceux_copy(X->S, (X->base + 0 + 0 + 5) /* local p4 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 329 : col 9) | (val p4 = [+)
        
            
                { // BLOCK | (@/pico/pico.ceu : lin 324 : col 21) | do if pico-po
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (@/pico/pico.ceu : lin 328 : col 29) | if pico-point-v
                    
                { // CALL | (@/pico/pico.ceu : lin 318 : col 9) | pico-point-vs-r
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 103) /* global pico-point-vs-rect? */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 2) /* local p1 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg r1 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 318, col 9) : pico-point-vs-rect?(p1,r1)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 318 : col 9) | pico-point-vs-r
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 318 : col 36) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 318 : col 36) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 320 : col 36) | if pico-point
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (@/pico/pico.ceu : lin 323 : col 29) | if pico-point-v
                    
                { // CALL | (@/pico/pico.ceu : lin 319 : col 9) | pico-point-vs-r
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 103) /* global pico-point-vs-rect? */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 3) /* local p2 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg r1 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 319, col 9) : pico-point-vs-rect?(p2,r1)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 319 : col 9) | pico-point-vs-r
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 319 : col 36) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 319 : col 36) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 321 : col 36) | if pico-point
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (@/pico/pico.ceu : lin 324 : col 29) | if pico-point-v
                    
                { // CALL | (@/pico/pico.ceu : lin 320 : col 9) | pico-point-vs-r
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 103) /* global pico-point-vs-rect? */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 4) /* local p3 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg r1 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 320, col 9) : pico-point-vs-rect?(p3,r1)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 320 : col 9) | pico-point-vs-r
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 320 : col 36) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 320 : col 36) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 322 : col 36) | if pico-point
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (@/pico/pico.ceu : lin 325 : col 29) | if pico-point-v
                    
                { // CALL | (@/pico/pico.ceu : lin 321 : col 9) | pico-point-vs-r
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 103) /* global pico-point-vs-rect? */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 5) /* local p4 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg r1 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 321, col 9) : pico-point-vs-rect?(p4,r1)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 321 : col 9) | pico-point-vs-r
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 321 : col 36) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 321 : col 36) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 323 : col 36) | if true fal
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (@/pico/pico.ceu : lin 326 : col 29) | if true false
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 322 : col 14) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 322 : col 14) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 324 : col 36) | (do nil)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        // PASS | (@/pico/pico.ceu : lin 324 : col 36) | (do nil)
ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 324 : col 36) | (do nil)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 323 : col 36) | if true fal
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 322 : col 36) | if pico-point
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 321 : col 36) | if pico-point
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 320 : col 36) | if pico-point
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 324 : col 21) | do if pico-po
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 323 : col 7) | do (val w2 = 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 6, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 316 : col 44) | do (val w2 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 333 : col 1) | (func (tsks,f-c
                    int ceu_f_pico_dash_collisions (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 333 : col 36) | (val ret = #[
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 334 : col 5) | (val ret = #[])
                
                    
                { // VECTOR | (@/pico/pico.ceu : lin 334 : col 15) | #[]
                    ceux_push(X->S, 1, ceu_create_vector());
                    
                }
            
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ret */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 334 : col 5) | (val ret = #[]))
        
            
                { // BLOCK | (@/pico/pico.ceu : lin 345 : col 29) | do (val ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 346 : col 33) | (val ceu_20669 
                
                    
                { // CALL | (@/pico/pico.ceu : lin 346 : col 49) | to-iter(tsks)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 43) /* global to-iter */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg tsks */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 346, col 49) : to-iter(tsks)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 346 : col 49) | to-iter(tsks)
                
                    ceux_copy(X->S, (X->base + 0 + 1 + 0) /* local ceu_20669 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 346 : col 33) | (val ceu_20669 )
        
            
                // LOOP | (@/pico/pico.ceu : lin 336 : col 33) | loop (val tsk
                CEU_LOOP_START_21162:
                    
                { // BLOCK | (@/pico/pico.ceu : lin 336 : col 33) | (val tsk1 = c
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 337 : col 37) | (val tsk1 = ceu
                
                    
                { // CALL | (@/pico/pico.ceu : lin 335 : col 17) | ceu_20669[0](ce
                    
                { // INDEX | (@/pico/pico.ceu : lin 335 : col 17) | ceu_20669[0]
                    // IDX
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_20669 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 335, col 17) : ceu_20669[0]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 335, col 17) : ceu_20669[0]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_20669 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 335, col 17) : ceu_20669[0](ceu_20669)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 335 : col 17) | ceu_20669[0](ce
                
                    ceux_copy(X->S, (X->base + 0 + 2 + 0) /* local tsk1 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 337 : col 37) | (val tsk1 = ceu)
        
             // BREAK | (@/pico/pico.ceu : lin 336 : col 37) | (break(false) i
                
                { // CALL | (@/pico/pico.ceu : lin 336 : col 59) | ==(tsk1,nil
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local tsk1 */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 336, col 59) : {{==}}(tsk1,nil)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 336 : col 59) | ==(tsk1,nil
                
                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            ceux_pop(X->S, 1);        // (2)
                            ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 336 : col 43) | false)
        
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_21162;
                    }
                }
            
                { // BLOCK | (@/pico/pico.ceu : lin 344 : col 29) | do (val ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 345 : col 33) | (val ceu_20495 
                
                    
                { // CALL | (@/pico/pico.ceu : lin 345 : col 49) | to-iter(tsks)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 43) /* global to-iter */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 0) /* arg tsks */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 345, col 49) : to-iter(tsks)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 345 : col 49) | to-iter(tsks)
                
                    ceux_copy(X->S, (X->base + 0 + 3 + 0) /* local ceu_20495 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 345 : col 33) | (val ceu_20495 )
        
            
                // LOOP | (@/pico/pico.ceu : lin 337 : col 33) | loop (val tsk
                CEU_LOOP_START_21155:
                    
                { // BLOCK | (@/pico/pico.ceu : lin 337 : col 33) | (val tsk2 = c
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 338 : col 37) | (val tsk2 = ceu
                
                    
                { // CALL | (@/pico/pico.ceu : lin 336 : col 21) | ceu_20495[0](ce
                    
                { // INDEX | (@/pico/pico.ceu : lin 336 : col 21) | ceu_20495[0]
                    // IDX
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 3 + 0) /* local ceu_20495 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 336, col 21) : ceu_20495[0]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "@/pico/pico.ceu : (lin 336, col 21) : ceu_20495[0]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 3 + 0) /* local ceu_20495 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 336, col 21) : ceu_20495[0](ceu_20495)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 336 : col 21) | ceu_20495[0](ce
                
                    ceux_copy(X->S, (X->base + 0 + 4 + 0) /* local tsk2 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 338 : col 37) | (val tsk2 = ceu)
        
             // BREAK | (@/pico/pico.ceu : lin 337 : col 37) | (break(false) i
                
                { // CALL | (@/pico/pico.ceu : lin 337 : col 59) | ==(tsk2,nil
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local tsk2 */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 337, col 59) : {{==}}(tsk2,nil)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 337 : col 59) | ==(tsk2,nil
                
                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            ceux_pop(X->S, 1);        // (2)
                            ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 337 : col 43) | false)
        
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_21155;
                    }
                }
            
                // DCL | (@/pico/pico.ceu : lin 338 : col 13) | (val ok? = do 
                
                    
                { // BLOCK | (@/pico/pico.ceu : lin 339 : col 21) | do (val ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 340 : col 25) | (val ceu_20302 
                
                    
                { // CALL | (@/pico/pico.ceu : lin 338 : col 29) | /=(tsk1,tsk
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 15) /* global {{/=}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local tsk1 */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local tsk2 */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 338, col 29) : {{/=}}(tsk1,tsk2)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 338 : col 29) | /=(tsk1,tsk
                
                    ceux_copy(X->S, (X->base + 0 + 6 + 0) /* local ceu_20302 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 340 : col 25) | (val ceu_20302 )
        
            
                { // IF | (@/pico/pico.ceu : lin 339 : col 25) | if ceu_20302 
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 6 + 0) /* local ceu_20302 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 339 : col 38) | f-cmp(tsk1.pu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+7, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (@/pico/pico.ceu : lin 338 : col 42) | f-cmp(tsk1.pub,
                    ceux_push(X->S, 1, ceux_peek(X->S, ceux_arg(X, 1) /* arg f-cmp */));

                    
                        
            { // PUB | (@/pico/pico.ceu : lin 338 : col 48) | tsk1.pub
                ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local tsk1 */));

                CEU_Value tsk = 
                    ceux_peek(X->S, XX(-1))
                
                ;
                
                    if (!ceu_istask_val(tsk)) {
                        CEU_ERROR_THR_S(continue, "pub error : expected task", "@/pico/pico.ceu : (lin 338, col 48) : tsk1.pub");
                    }
                
                
                    // [(tsk)]
                    
                        ceux_repl(X->S, XX(-1), tsk.Dyn->Exe_Task.pub);                        
                    
                    // [pub]
                
            }
            
                    
                        
            { // PUB | (@/pico/pico.ceu : lin 338 : col 58) | tsk2.pub
                ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local tsk2 */));

                CEU_Value tsk = 
                    ceux_peek(X->S, XX(-1))
                
                ;
                
                    if (!ceu_istask_val(tsk)) {
                        CEU_ERROR_THR_S(continue, "pub error : expected task", "@/pico/pico.ceu : (lin 338, col 58) : tsk2.pub");
                    }
                
                
                    // [(tsk)]
                    
                        ceux_repl(X->S, XX(-1), tsk.Dyn->Exe_Task.pub);                        
                    
                    // [pub]
                
            }
            
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 338, col 42) : f-cmp(tsk1.pub,tsk2.pub)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 338 : col 42) | f-cmp(tsk1.pub,
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 339 : col 38) | f-cmp(tsk1.pu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+7, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 339 : col 32) | ceu_20302
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+7, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 6 + 0) /* local ceu_20302 */));

                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 339 : col 32) | ceu_20302
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+7, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 339 : col 21) | do (val ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    ceux_copy(X->S, (X->base + 0 + 4 + 1) /* local ok? */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 338 : col 13) | (val ok? = do )
        
            
                { // IF | (@/pico/pico.ceu : lin 339 : col 13) | if ok? do (
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 1) /* local ok? */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 339 : col 20) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (@/pico/pico.ceu : lin 341 : col 29) | do (val ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (@/pico/pico.ceu : lin 340 : col 32) | (val ceu_20382 
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ret */));

                    ceux_copy(X->S, (X->base + 0 + 6 + 0) /* local ceu_20382 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 340 : col 32) | (val ceu_20382 )
        
            
                { // SET | (@/pico/pico.ceu : lin 341 : col 33) | (set ceu_20382[
                    
                { // TUPLE | (@/pico/pico.ceu : lin 340 : col 30) | [tsk1,tsk2]
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 2 + 0) /* local tsk1 */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local tsk2 */));

                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
              // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                { // INDEX | (@/pico/pico.ceu : lin 341 : col 37) | ceu_20382[#
                    // IDX
                    
                { // CALL | (@/pico/pico.ceu : lin 341 : col 47) | #(ceu_20382
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 13) /* global {{#}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 6 + 0) /* local ceu_20382 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 341, col 47) : {{#}}(ceu_20382)");
            
        
                } // CALL | (@/pico/pico.ceu : lin 341 : col 47) | #(ceu_20382
                
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 6 + 0) /* local ceu_20382 */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 341, col 37) : ceu_20382[{{#}}(ceu_20382)]"
                    );
                
                        {
                            CEU_Value v = ceu_col_set(ceux_peek(X->S,XX(-1)), ceux_peek(X->S,XX(-2)), ceux_peek(X->S,XX(-3)));
                            CEU_ERROR_CHK_VAL(continue, v, "@/pico/pico.ceu : (lin 341, col 37) : ceu_20382[{{#}}(ceu_20382)]");
                            ceux_drop(X->S, 2);    // keep src
                        }
                        
                }
                  // dst should not pop src
                }
            
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 341 : col 29) | do (val ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+6, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 339 : col 20) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 339 : col 13) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 339 : col 13) | nil)
        
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 339 : col 13) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                 // BREAK | (@/pico/pico.ceu : lin 342 : col 13) | (break if ok?)
                ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 1) /* local ok? */));

                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            
                                ceux_pop(X->S, 1);    // (3)
                            
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_21155;
                    }
                }
            
                        
                            CEU_LOOP_STOP_21155:
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 337 : col 33) | (val tsk2 = c
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : ) !CEU_BREAK ? 0 :  0;
                        ceux_block_leave(X->S, X->base+4, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    if (CEU_BREAK) {
                        CEU_BREAK = 0;
                    } else {
                        //ceux_pop(X->S, 1);
                        goto CEU_LOOP_START_21155;
                    }
            
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 344 : col 29) | do (val ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+3, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        
                            CEU_LOOP_STOP_21162:
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 336 : col 33) | (val tsk1 = c
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : ) !CEU_BREAK ? 0 :  0;
                        ceux_block_leave(X->S, X->base+2, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    if (CEU_BREAK) {
                        CEU_BREAK = 0;
                    } else {
                        //ceux_pop(X->S, 1);
                        goto CEU_LOOP_START_21162;
                    }
            
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 345 : col 29) | do (val ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+1, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ret */));

                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 333 : col 36) | (val ret = #[
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (@/pico/pico.ceu : lin 350 : col 1) | (func () (set
                    int ceu_f_pico_dash_quit (CEUX* X) {
                        
                        do {
                { // BLOCK | (@/pico/pico.ceu : lin 350 : col 19) | (set PICO[:qu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // SET | (@/pico/pico.ceu : lin 351 : col 5) | (set PICO[:quit
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                { // INDEX | (@/pico/pico.ceu : lin 351 : col 9) | PICO[:quit]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 70) /* global PICO */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "@/pico/pico.ceu : (lin 351, col 9) : PICO[:quit]"
                    );
                
                        {
                            CEU_Value v = ceu_col_set(ceux_peek(X->S,XX(-1)), ceux_peek(X->S,XX(-2)), ceux_peek(X->S,XX(-3)));
                            CEU_ERROR_CHK_VAL(continue, v, "@/pico/pico.ceu : (lin 351, col 9) : PICO[:quit]");
                            ceux_drop(X->S, 2);    // keep src
                        }
                        
                }
                  // dst should not pop src
                }
            
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 350 : col 19) | (set PICO[:qu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (first_game.ceu : lin 354 : col 1) | (func () pico
                    int ceu_f_pico_dash_loop (CEUX* X) {
                        
                        do {
                { // BLOCK | (first_game.ceu : lin 354 : col 19) | pico-state-se
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (first_game.ceu : lin 355 : col 5) | pico-state-set-
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 91) /* global pico-state-set-auto */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 355, col 5) : pico-state-set-auto(false)");
            
        
                } // CALL | (first_game.ceu : lin 355 : col 5) | pico-state-set-
                
                // DCL | (first_game.ceu : lin 356 : col 5) | (var old = ```:
                
                    ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(  SDL_GetTicks())} }));
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local old */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 356 : col 5) | (var old = ```:)
        
            
                // LOOP | (first_game.ceu : lin 357 : col 5) | loop (val now
                CEU_LOOP_START_21770:
                    
                { // BLOCK | (first_game.ceu : lin 357 : col 5) | (val now = ``
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 3 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 358 : col 9) | (val now = ```:
                
                    ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_NUMBER, {.Number=(  SDL_GetTicks())} }));
                    ceux_copy(X->S, (X->base + 0 + 1 + 0) /* local now */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 358 : col 9) | (val now = ```:)
        
            
                // DCL | (first_game.ceu : lin 359 : col 9) | (val togo = -
                
                    
                { // CALL | (first_game.ceu : lin 359 : col 29) | -(PICO[:mpf
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 23) /* global {{-}} */));

                    
                        
                { // INDEX | (first_game.ceu : lin 359 : col 20) | PICO[:mpf]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 70) /* global PICO */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 359, col 20) : PICO[:mpf]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "first_game.ceu : (lin 359, col 20) : PICO[:mpf]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        
                { // CALL | (first_game.ceu : lin 359 : col 36) | -(now,old)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 23) /* global {{-}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local now */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local old */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 359, col 36) : {{-}}(now,old)");
            
        
                } // CALL | (first_game.ceu : lin 359 : col 36) | -(now,old)
                
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 359, col 29) : {{-}}(PICO[:mpf],{{-}}(now,old))");
            
        
                } // CALL | (first_game.ceu : lin 359 : col 29) | -(PICO[:mpf
                
                    ceux_copy(X->S, (X->base + 0 + 1 + 1) /* local togo */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 359 : col 9) | (val togo = -)
        
            
                { // IF | (first_game.ceu : lin 360 : col 9) | if <=(togo,
                    
                { // CALL | (first_game.ceu : lin 360 : col 17) | <=(togo,0)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 32) /* global {{<=}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 1) /* local togo */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 360, col 17) : {{<=}}(togo,0)");
            
        
                } // CALL | (first_game.ceu : lin 360 : col 17) | <=(togo,0)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (first_game.ceu : lin 360 : col 22) | broadcast'(:t
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (first_game.ceu : lin 361 : col 13) | broadcast'(:tas
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 18) /* global broadcast' */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_task} });
                    
                        
                { // CALL | (first_game.ceu : lin 361 : col 23) | tags([PICO[:mpf
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 6) /* global tags */));

                    
                        
                { // TUPLE | (first_game.ceu : lin 361 : col 35) | [PICO[:mpf]]
                    ceux_push(X->S, 1, ceu_create_tuple(1));
                    
                { // INDEX | (first_game.ceu : lin 361 : col 36) | PICO[:mpf]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 70) /* global PICO */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 361, col 36) : PICO[:mpf]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "first_game.ceu : (lin 361, col 36) : PICO[:mpf]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Pico_Frame} });
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                                        
                    

                    ceux_call(X, 3, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 361, col 23) : tags([PICO[:mpf]],:Pico.Frame,true)");
            
        
                } // CALL | (first_game.ceu : lin 361 : col 23) | tags([PICO[:mpf
                
                                        
                    

                    ceux_call(X, 2, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 361, col 13) : broadcast'(:task,tags([PICO[:mpf]],:Pico.Fram...)");
            
        
                } // CALL | (first_game.ceu : lin 361 : col 13) | broadcast'(:tas
                
                { // CALL | (first_game.ceu : lin 362 : col 13) | broadcast'(:tas
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 18) /* global broadcast' */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_task} });
                    
                        
                { // CALL | (first_game.ceu : lin 362 : col 23) | tags([PICO[:mpf
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 6) /* global tags */));

                    
                        
                { // TUPLE | (first_game.ceu : lin 362 : col 30) | [PICO[:mpf]]
                    ceux_push(X->S, 1, ceu_create_tuple(1));
                    
                { // INDEX | (first_game.ceu : lin 362 : col 31) | PICO[:mpf]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 70) /* global PICO */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 362, col 31) : PICO[:mpf]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "first_game.ceu : (lin 362, col 31) : PICO[:mpf]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Clock} });
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                                        
                    

                    ceux_call(X, 3, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 362, col 23) : tags([PICO[:mpf]],:Clock,true)");
            
        
                } // CALL | (first_game.ceu : lin 362 : col 23) | tags([PICO[:mpf
                
                                        
                    

                    ceux_call(X, 2, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 362, col 13) : broadcast'(:task,tags([PICO[:mpf]],:Clock,tru...)");
            
        
                } // CALL | (first_game.ceu : lin 362 : col 13) | broadcast'(:tas
                
                { // CALL | (first_game.ceu : lin 363 : col 13) | pico-output-cle
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 75) /* global pico-output-clear */));

                                        
                    

                    ceux_call(X, 0, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 363, col 13) : pico-output-clear()");
            
        
                } // CALL | (first_game.ceu : lin 363 : col 13) | pico-output-cle
                
                { // CALL | (first_game.ceu : lin 364 : col 13) | broadcast'(:tas
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 18) /* global broadcast' */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_task} });
                    
                        
                { // CALL | (first_game.ceu : lin 364 : col 23) | tags([],:Pico.D
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 6) /* global tags */));

                    
                        
                { // TUPLE | (first_game.ceu : lin 364 : col 34) | []
                    ceux_push(X->S, 1, ceu_create_tuple(0));
                    
                }
            
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Pico_Draw} });
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                                        
                    

                    ceux_call(X, 3, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 364, col 23) : tags([],:Pico.Draw,true)");
            
        
                } // CALL | (first_game.ceu : lin 364 : col 23) | tags([],:Pico.D
                
                                        
                    

                    ceux_call(X, 2, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 364, col 13) : broadcast'(:task,tags([],:Pico.Draw,true))");
            
        
                } // CALL | (first_game.ceu : lin 364 : col 13) | broadcast'(:tas
                
                { // CALL | (first_game.ceu : lin 365 : col 13) | pico-output-pre
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 82) /* global pico-output-present */));

                                        
                    

                    ceux_call(X, 0, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 365, col 13) : pico-output-present()");
            
        
                } // CALL | (first_game.ceu : lin 365 : col 13) | pico-output-pre
                
                { // SET | (first_game.ceu : lin 366 : col 13) | (set old = +
                    
                { // CALL | (first_game.ceu : lin 366 : col 28) | +(togo,now)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 22) /* global {{+}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 1) /* local togo */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local now */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 366, col 28) : {{+}}(togo,now)");
            
        
                } // CALL | (first_game.ceu : lin 366 : col 28) | +(togo,now)
                  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                        // ACC - SET | (first_game.ceu : lin 366 : col 17) | old
                        ceux_repl(X->S, (X->base + 0 + 0 + 0) /* local old */, ceux_peek(X->S,XX(-1)));
                      // dst should not pop src
                }
            
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 360 : col 22) | broadcast'(:t
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } else {
                            
                { // BLOCK | (first_game.ceu : lin 360 : col 9) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 360 : col 9) | nil)
        
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 360 : col 9) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        }
                    }
                }
                
                // DCL | (first_game.ceu : lin 368 : col 9) | (val e = pico-i
                
                    
                { // CALL | (first_game.ceu : lin 368 : col 17) | pico-input-even
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 74) /* global pico-input-event-timeout */));

                    
                        ceux_push(X->S, 1, ((CEU_Value){ CEU_VALUE_TAG, {.Tag=(  SDL_ANY)} }));
                    
                        
                { // CALL | (first_game.ceu : lin 368 : col 58) | max(0,togo)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 36) /* global max */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 1) /* local togo */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 368, col 58) : max(0,togo)");
            
        
                } // CALL | (first_game.ceu : lin 368 : col 58) | max(0,togo)
                
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 368, col 17) : pico-input-event-timeout(```:tag   SDL_ANY```...)");
            
        
                } // CALL | (first_game.ceu : lin 368 : col 17) | pico-input-even
                
                    ceux_copy(X->S, (X->base + 0 + 1 + 2) /* local e */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 368 : col 9) | (val e = pico-i)
        
            
                { // SET | (first_game.ceu : lin 369 : col 9) | (set PICO[:quit
                    
                { // CALL | (first_game.ceu : lin 369 : col 32) | is'(e,:Pico.Qui
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 2) /* local e */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Pico_Quit} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 369, col 32) : is'(e,:Pico.Quit)");
            
        
                } // CALL | (first_game.ceu : lin 369 : col 32) | is'(e,:Pico.Qui
                  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                { // INDEX | (first_game.ceu : lin 369 : col 13) | PICO[:quit]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 70) /* global PICO */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 369, col 13) : PICO[:quit]"
                    );
                
                        {
                            CEU_Value v = ceu_col_set(ceux_peek(X->S,XX(-1)), ceux_peek(X->S,XX(-2)), ceux_peek(X->S,XX(-3)));
                            CEU_ERROR_CHK_VAL(continue, v, "first_game.ceu : (lin 369, col 13) : PICO[:quit]");
                            ceux_drop(X->S, 2);    // keep src
                        }
                        
                }
                  // dst should not pop src
                }
            
                { // CALL | (first_game.ceu : lin 370 : col 9) | broadcast'(:tas
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 18) /* global broadcast' */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_task} });
                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 2) /* local e */));

                                        
                    

                    ceux_call(X, 2, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 370, col 9) : broadcast'(:task,e)");
            
        
                } // CALL | (first_game.ceu : lin 370 : col 9) | broadcast'(:tas
                 // BREAK | (first_game.ceu : lin 371 : col 9) | (break if PICO[
                
                { // INDEX | (first_game.ceu : lin 371 : col 15) | PICO[:quit]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 70) /* global PICO */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 371, col 15) : PICO[:quit]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "first_game.ceu : (lin 371, col 15) : PICO[:quit]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_21770;
                    }
                }
            
                        
                            CEU_LOOP_STOP_21770:
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 357 : col 5) | (val now = ``
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : ) !CEU_BREAK ? 0 :  1;
                        ceux_block_leave(X->S, X->base+1, 3, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                    if (CEU_BREAK) {
                        CEU_BREAK = 0;
                    } else {
                        //ceux_pop(X->S, 1);
                        goto CEU_LOOP_START_21770;
                    }
            
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 354 : col 19) | pico-state-se
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (first_game.ceu : lin 22 : col 13) | (task :nested (
                    int ceu_f_27969 (CEUX* X) {
                        
                            X->exe->status = (X->action == CEU_ACTION_ABORT) ? CEU_EXE_STATUS_TERMINATED : CEU_EXE_STATUS_RESUMED;
                            switch (X->exe->pc) {
                                case 0:
                                    if (X->action == CEU_ACTION_ABORT) {
                                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                                        return 1;
                                    }
                        
                        do {
                { // BLOCK | (first_game.ceu : lin 22 : col 29) | loop do (
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // LOOP | (first_game.ceu : lin 22 : col 21) | loop do (va
                CEU_LOOP_START_27966:
                    
                { // BLOCK | (first_game.ceu : lin 22 : col 21) | do (var it 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (first_game.ceu : lin 22 : col 21) | do (var it :P
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 24 : col 25) | (var it :Pico.D
                
            
                // LOOP | (first_game.ceu : lin 15 : col 25) | loop (set it 
                CEU_LOOP_START_27884:
                    
                { // BLOCK | (first_game.ceu : lin 15 : col 25) | (set it = yie
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // SET | (first_game.ceu : lin 16 : col 29) | (set it = yield
                    
                { // YIELD (first_game.ceu : lin 23 : col 25) | yield(nil)
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    X->exe->status = CEU_EXE_STATUS_YIELDED;
                    X->exe->pc = 27829;
                    return 1;   // TODO: args MULTI
                case 27829: // YIELD (first_game.ceu : lin 23 : col 25) | yield(nil)
                    if (X->action == CEU_ACTION_ABORT) {
                        //ceux_push(X->S, 1, (CEU_Value){CEU_VALUE_NIL}); // fake out=1
                        continue;
                    }
                #if CEU >= 4
                    if (X->action == CEU_ACTION_ERROR) {
                        //assert(X->args>1 && CEU_ERROR_IS(X->S) && "TODO: varargs resume");
                        continue;
                    }
                #endif
                    //assert(X->args<=1 && "TODO: varargs resume");
                #if 0
                    // fill missing args with nils
                    {
                        int N = 1 - X->args;
                        assert(N > 0);
                        for (int i=0; i<N; i++) {
                            for (int i=0; i<N; i++) {
                                ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                            }
                        }
                    }
                #endif
                }
              // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                        // ACC - SET | (first_game.ceu : lin 16 : col 33) | it
                        ceux_repl(X->S, (X->base + 0 + 0 + 0) /* local it */, ceux_peek(X->S,XX(-1)));
                      // dst should not pop src
                }
             // BREAK | (first_game.ceu : lin 25 : col 33) | (break if do 
                
                { // BLOCK | (first_game.ceu : lin 15 : col 21) | do (val ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 16 : col 25) | (val ceu_22092 
                
                    
                { // CALL | (first_game.ceu : lin 14 : col 40) | is'(it,:Pico.Dr
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Pico_Draw} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 14, col 40) : is'(it,:Pico.Draw)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 14 : col 40) | is'(it,:Pico.Dr
                
                    ceux_copy(X->S, (X->base + 0 + 1 + 0) /* local ceu_22092 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 16 : col 25) | (val ceu_22092 )
        
            
                { // IF | (first_game.ceu : lin 15 : col 25) | if ceu_22092 
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_22092 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (first_game.ceu : lin 15 : col 38) | is'(it,:Pico.
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (first_game.ceu : lin 14 : col 22) | is'(it,:Pico.Dr
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Pico_Draw} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 14, col 22) : is'(it,:Pico.Draw)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 14 : col 22) | is'(it,:Pico.Dr
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 15 : col 38) | is'(it,:Pico.
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        } else {
                            
                { // BLOCK | (first_game.ceu : lin 15 : col 32) | ceu_22092
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_22092 */));

                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 15 : col 32) | ceu_22092
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 15 : col 21) | do (val ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_27884;
                    }
                }
            
                        
                            CEU_LOOP_STOP_27884:
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 15 : col 25) | (set it = yie
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : ) !CEU_BREAK ? 0 :  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                    if (CEU_BREAK) {
                        CEU_BREAK = 0;
                    } else {
                        //ceux_pop(X->S, 1);
                        goto CEU_LOOP_START_27884;
                    }
            // DELAY | (first_game.ceu : lin 21 : col 25) | delay
X->exe_task->time = CEU_TIME;
                { // CALL | (first_game.ceu : lin 15 : col 13) | pico-state-set-
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 93) /* global pico-state-set-color-draw */));

                    
                        
                { // TUPLE | (first_game.ceu : lin 15 : col 39) | [255,255,255,25
                    ceux_push(X->S, 1, ceu_create_tuple(4));
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=255} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=255} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=255} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 2, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=255} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 3, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 15, col 13) : pico-state-set-color-draw([255,255,255,255])");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 15 : col 13) | pico-state-set-
                
                { // CALL | (first_game.ceu : lin 16 : col 13) | pico-output-dra
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 78) /* global pico-output-draw-rect */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->exe->clo.Dyn->Clo_Task.up_tsk->X->S /* nested */, (X->exe->clo.Dyn->Clo_Task.up_tsk->X->base + 0 + 0 + 2) /* local player */));

                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 16, col 13) : pico-output-draw-rect(player)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 16 : col 13) | pico-output-dra
                
                { // CALL | (first_game.ceu : lin 17 : col 13) | pico-output-dra
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 81) /* global pico-output-draw-text */));

                    
                        
                { // TUPLE | (first_game.ceu : lin 17 : col 35) | [-(20),25]
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    
                { // CALL | (first_game.ceu : lin 17 : col 36) | -(20)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 23) /* global {{-}} */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=20} });
                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 17, col 36) : {{-}}(20)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 17 : col 36) | -(20)
                
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=25} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    
                        ceux_push(X->S, 1, ceux_peek(X->exe->clo.Dyn->Clo_Task.up_tsk->X->S /* nested */, (X->exe->clo.Dyn->Clo_Task.up_tsk->X->base + 0 + 0 + 1) /* local score-text */));

                                        
                    

                    ceux_call(X, 2, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 17, col 13) : pico-output-draw-text([{{-}}(20),25],score-te...)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 17 : col 13) | pico-output-dra
                
                { // CALL | (first_game.ceu : lin 18 : col 13) | pico-state-set-
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 93) /* global pico-state-set-color-draw */));

                    
                        
                { // TUPLE | (first_game.ceu : lin 18 : col 39) | [255,255,0,255]
                    ceux_push(X->S, 1, ceu_create_tuple(4));
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=255} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=255} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 2, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=255} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 3, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 18, col 13) : pico-state-set-color-draw([255,255,0,255])");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 18 : col 13) | pico-state-set-
                
                { // CALL | (first_game.ceu : lin 19 : col 13) | pico-output-dra
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 78) /* global pico-output-draw-rect */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->exe->clo.Dyn->Clo_Task.up_tsk->X->S /* nested */, (X->exe->clo.Dyn->Clo_Task.up_tsk->X->base + 0 + 0 + 3) /* local coin */));

                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 19, col 13) : pico-output-draw-rect(coin)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 19 : col 13) | pico-output-dra
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 22 : col 21) | do (var it :P
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        
                            CEU_LOOP_STOP_27966:
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 22 : col 21) | do (var it 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : ) !CEU_BREAK ? 0 :  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                    if (CEU_BREAK) {
                        CEU_BREAK = 0;
                    } else {
                        //ceux_pop(X->S, 1);
                        goto CEU_LOOP_START_27966;
                    }
            
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 22 : col 29) | loop do (
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                } while (0);
                        
                                {
                                    int top = ceux_n_get(X->S);
                                
                                    // task return value in pub(t)
                                    if (top > 0) {
                                        ceu_gc_dec_val(X->exe_task->pub);
                                        X->exe_task->pub = ceux_peek(X->S, XX(-1));
                                        ceu_gc_inc_val(X->exe_task->pub);
                                    }
                                
                                    int ret = ceu_exe_term(X);
                                    if (!CEU_ERROR_IS(X->S) && ret!=0) {
                                        // nrm->err: remove pending return in the stack
                                        ceux_rem(X->S, top-1);
                                    }
                                }
                            } // close switch
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (first_game.ceu : lin 60 : col 37) | (task :nested (
                    int ceu_f_28474 (CEUX* X) {
                        
                            X->exe->status = (X->action == CEU_ACTION_ABORT) ? CEU_EXE_STATUS_TERMINATED : CEU_EXE_STATUS_RESUMED;
                            switch (X->exe->pc) {
                                case 0:
                                    if (X->action == CEU_ACTION_ABORT) {
                                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                                        return 1;
                                    }
                        
                        do {
                { // BLOCK | (first_game.ceu : lin 60 : col 53) | do (var ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (first_game.ceu : lin 37 : col 21) | do (var ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 39 : col 29) | (var ceu_23456 
                
                    
                { // CALL | (first_game.ceu : lin 36 : col 28) | *(1,1000)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 24) /* global {{*}} */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1000} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 36, col 28) : {{*}}(1,1000)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 36 : col 28) | *(1,1000)
                
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local ceu_23456 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 39 : col 29) | (var ceu_23456 )
        
            
                // DCL | (first_game.ceu : lin 38 : col 25) | (var it :Clock)
                
            
                // LOOP | (first_game.ceu : lin 37 : col 25) | loop (set it 
                CEU_LOOP_START_28464:
                    
                { // BLOCK | (first_game.ceu : lin 37 : col 25) | (set it = yie
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // SET | (first_game.ceu : lin 38 : col 29) | (set it = yield
                    
                { // YIELD (first_game.ceu : lin 42 : col 25) | yield(nil)
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    X->exe->status = CEU_EXE_STATUS_YIELDED;
                    X->exe->pc = 28382;
                    return 1;   // TODO: args MULTI
                case 28382: // YIELD (first_game.ceu : lin 42 : col 25) | yield(nil)
                    if (X->action == CEU_ACTION_ABORT) {
                        //ceux_push(X->S, 1, (CEU_Value){CEU_VALUE_NIL}); // fake out=1
                        continue;
                    }
                #if CEU >= 4
                    if (X->action == CEU_ACTION_ERROR) {
                        //assert(X->args>1 && CEU_ERROR_IS(X->S) && "TODO: varargs resume");
                        continue;
                    }
                #endif
                    //assert(X->args<=1 && "TODO: varargs resume");
                #if 0
                    // fill missing args with nils
                    {
                        int N = 1 - X->args;
                        assert(N > 0);
                        for (int i=0; i<N; i++) {
                            for (int i=0; i<N; i++) {
                                ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                            }
                        }
                    }
                #endif
                }
              // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                        // ACC - SET | (first_game.ceu : lin 38 : col 33) | it
                        ceux_repl(X->S, (X->base + 0 + 0 + 1) /* local it */, ceux_peek(X->S,XX(-1)));
                      // dst should not pop src
                }
             // BREAK | (first_game.ceu : lin 44 : col 33) | (break if do 
                
                { // BLOCK | (first_game.ceu : lin 44 : col 42) | do if is'(it,
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // IF | (first_game.ceu : lin 45 : col 37) | if is'(it,:Cloc
                    
                { // CALL | (first_game.ceu : lin 45 : col 47) | is'(it,:Clock)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 1) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Clock} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 45, col 47) : is'(it,:Clock)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 45 : col 47) | is'(it,:Clock)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (first_game.ceu : lin 45 : col 54) | (set ceu_2345
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // SET | (first_game.ceu : lin 46 : col 41) | (set ceu_23456 
                    
                { // CALL | (first_game.ceu : lin 46 : col 67) | -(ceu_23456
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 23) /* global {{-}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_23456 */));

                    
                        
                { // INDEX | (first_game.ceu : lin 46 : col 69) | it[:ms]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 1) /* local it */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 46, col 69) : it[:ms]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "first_game.ceu : (lin 46, col 69) : it[:ms]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 46, col 67) : {{-}}(ceu_23456,it[:ms])");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 46 : col 67) | -(ceu_23456
                  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                        // ACC - SET | (first_game.ceu : lin 46 : col 45) | ceu_23456
                        ceux_repl(X->S, (X->base + 0 + 0 + 0) /* local ceu_23456 */, ceux_peek(X->S,XX(-1)));
                      // dst should not pop src
                }
            
                { // IF | (first_game.ceu : lin 47 : col 41) | if >(ceu_23
                    
                { // CALL | (first_game.ceu : lin 47 : col 55) | >(ceu_23456
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 29) /* global {{>}} */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local ceu_23456 */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 47, col 55) : {{>}}(ceu_23456,0)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 47 : col 55) | >(ceu_23456
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (first_game.ceu : lin 47 : col 60) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 47 : col 60) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        } else {
                            
                { // BLOCK | (first_game.ceu : lin 49 : col 48) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 49 : col 48) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 45 : col 54) | (set ceu_2345
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        } else {
                            
                { // BLOCK | (first_game.ceu : lin 45 : col 37) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 45 : col 37) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 44 : col 42) | do if is'(it,
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_28464;
                    }
                }
            
                        
                            CEU_LOOP_STOP_28464:
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 37 : col 25) | (set it = yie
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : ) !CEU_BREAK ? 0 :  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                    if (CEU_BREAK) {
                        CEU_BREAK = 0;
                    } else {
                        //ceux_pop(X->S, 1);
                        goto CEU_LOOP_START_28464;
                    }
            // DELAY | (first_game.ceu : lin 56 : col 25) | delay
X->exe_task->time = CEU_TIME;ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 1) /* local it */));

                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 37 : col 21) | do (var ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 60 : col 53) | do (var ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                } while (0);
                        
                                {
                                    int top = ceux_n_get(X->S);
                                
                                    // task return value in pub(t)
                                    if (top > 0) {
                                        ceu_gc_dec_val(X->exe_task->pub);
                                        X->exe_task->pub = ceux_peek(X->S, XX(-1));
                                        ceu_gc_inc_val(X->exe_task->pub);
                                    }
                                
                                    int ret = ceu_exe_term(X);
                                    if (!CEU_ERROR_IS(X->S) && ret!=0) {
                                        // nrm->err: remove pending return in the stack
                                        ceux_rem(X->S, top-1);
                                    }
                                }
                            } // close switch
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (first_game.ceu : lin 42 : col 37) | (task :nested (
                    int ceu_f_28617 (CEUX* X) {
                        
                            X->exe->status = (X->action == CEU_ACTION_ABORT) ? CEU_EXE_STATUS_TERMINATED : CEU_EXE_STATUS_RESUMED;
                            switch (X->exe->pc) {
                                case 0:
                                    if (X->action == CEU_ACTION_ABORT) {
                                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                                        return 1;
                                    }
                        
                        do {
                { // BLOCK | (first_game.ceu : lin 42 : col 53) | loop do (
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // LOOP | (first_game.ceu : lin 40 : col 21) | loop do (va
                CEU_LOOP_START_28614:
                    
                { // BLOCK | (first_game.ceu : lin 40 : col 21) | do (var it 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (first_game.ceu : lin 41 : col 21) | do (var it :P
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 43 : col 25) | (var it :Pico.D
                
            
                // LOOP | (first_game.ceu : lin 38 : col 25) | loop (set it 
                CEU_LOOP_START_28572:
                    
                { // BLOCK | (first_game.ceu : lin 38 : col 25) | (set it = yie
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // SET | (first_game.ceu : lin 39 : col 29) | (set it = yield
                    
                { // YIELD (first_game.ceu : lin 41 : col 25) | yield(nil)
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    X->exe->status = CEU_EXE_STATUS_YIELDED;
                    X->exe->pc = 28517;
                    return 1;   // TODO: args MULTI
                case 28517: // YIELD (first_game.ceu : lin 41 : col 25) | yield(nil)
                    if (X->action == CEU_ACTION_ABORT) {
                        //ceux_push(X->S, 1, (CEU_Value){CEU_VALUE_NIL}); // fake out=1
                        continue;
                    }
                #if CEU >= 4
                    if (X->action == CEU_ACTION_ERROR) {
                        //assert(X->args>1 && CEU_ERROR_IS(X->S) && "TODO: varargs resume");
                        continue;
                    }
                #endif
                    //assert(X->args<=1 && "TODO: varargs resume");
                #if 0
                    // fill missing args with nils
                    {
                        int N = 1 - X->args;
                        assert(N > 0);
                        for (int i=0; i<N; i++) {
                            for (int i=0; i<N; i++) {
                                ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                            }
                        }
                    }
                #endif
                }
              // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                        // ACC - SET | (first_game.ceu : lin 39 : col 33) | it
                        ceux_repl(X->S, (X->base + 0 + 0 + 0) /* local it */, ceux_peek(X->S,XX(-1)));
                      // dst should not pop src
                }
             // BREAK | (first_game.ceu : lin 43 : col 33) | (break if do 
                
                { // BLOCK | (first_game.ceu : lin 38 : col 21) | do (val ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 39 : col 25) | (val ceu_23231 
                
                    
                { // CALL | (first_game.ceu : lin 37 : col 52) | is'(it,:Pico.Dr
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Pico_Draw} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 37, col 52) : is'(it,:Pico.Draw)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 37 : col 52) | is'(it,:Pico.Dr
                
                    ceux_copy(X->S, (X->base + 0 + 1 + 0) /* local ceu_23231 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 39 : col 25) | (val ceu_23231 )
        
            
                { // IF | (first_game.ceu : lin 38 : col 25) | if ceu_23231 
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_23231 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (first_game.ceu : lin 38 : col 38) | is'(it,:Pico.
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // CALL | (first_game.ceu : lin 37 : col 34) | is'(it,:Pico.Dr
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Pico_Draw} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 37, col 34) : is'(it,:Pico.Draw)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 37 : col 34) | is'(it,:Pico.Dr
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 38 : col 38) | is'(it,:Pico.
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        } else {
                            
                { // BLOCK | (first_game.ceu : lin 38 : col 32) | ceu_23231
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+2, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_23231 */));

                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 38 : col 32) | ceu_23231
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+2, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 38 : col 21) | do (val ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_28572;
                    }
                }
            
                        
                            CEU_LOOP_STOP_28572:
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 38 : col 25) | (set it = yie
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : ) !CEU_BREAK ? 0 :  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                    if (CEU_BREAK) {
                        CEU_BREAK = 0;
                    } else {
                        //ceux_pop(X->S, 1);
                        goto CEU_LOOP_START_28572;
                    }
            // DELAY | (first_game.ceu : lin 44 : col 25) | delay
X->exe_task->time = CEU_TIME;
                { // CALL | (first_game.ceu : lin 38 : col 25) | pico-output-dra
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 81) /* global pico-output-draw-text */));

                    
                        
                { // TUPLE | (first_game.ceu : lin 38 : col 47) | [0,-(20)]
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                { // CALL | (first_game.ceu : lin 38 : col 50) | -(20)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 23) /* global {{-}} */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=20} });
                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 38, col 50) : {{-}}(20)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 38 : col 50) | -(20)
                
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    
                        
                { // VECTOR | (first_game.ceu : lin 38 : col 56) | #['H','i','t','
                    ceux_push(X->S, 1, ceu_create_vector());
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='H'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='i'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='t'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 2, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='!'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 3, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                                        
                    

                    ceux_call(X, 2, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 38, col 25) : pico-output-draw-text([0,{{-}}(20)],#['H','i'...)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 38 : col 25) | pico-output-dra
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 41 : col 21) | do (var it :P
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        
                            CEU_LOOP_STOP_28614:
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 40 : col 21) | do (var it 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : ) !CEU_BREAK ? 0 :  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                    if (CEU_BREAK) {
                        CEU_BREAK = 0;
                    } else {
                        //ceux_pop(X->S, 1);
                        goto CEU_LOOP_START_28614;
                    }
            
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 42 : col 53) | loop do (
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                } while (0);
                        
                                {
                                    int top = ceux_n_get(X->S);
                                
                                    // task return value in pub(t)
                                    if (top > 0) {
                                        ceu_gc_dec_val(X->exe_task->pub);
                                        X->exe_task->pub = ceux_peek(X->S, XX(-1));
                                        ceu_gc_inc_val(X->exe_task->pub);
                                    }
                                
                                    int ret = ceu_exe_term(X);
                                    if (!CEU_ERROR_IS(X->S) && ret!=0) {
                                        // nrm->err: remove pending return in the stack
                                        ceux_rem(X->S, top-1);
                                    }
                                }
                            } // close switch
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (first_game.ceu : lin 39 : col 37) | (task :nested (
                    int ceu_f_28852 (CEUX* X) {
                        
                            X->exe->status = (X->action == CEU_ACTION_ABORT) ? CEU_EXE_STATUS_TERMINATED : CEU_EXE_STATUS_RESUMED;
                            switch (X->exe->pc) {
                                case 0:
                                    if (X->action == CEU_ACTION_ABORT) {
                                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                                        return 1;
                                    }
                        
                        do {
                { // BLOCK | (first_game.ceu : lin 39 : col 53) | do (var it 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (first_game.ceu : lin 43 : col 21) | do (var it :P
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 45 : col 25) | (var it :Pico.K
                
            
                // LOOP | (first_game.ceu : lin 28 : col 25) | loop (set it 
                CEU_LOOP_START_28033:
                    
                { // BLOCK | (first_game.ceu : lin 28 : col 25) | (set it = yie
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // SET | (first_game.ceu : lin 29 : col 29) | (set it = yield
                    
                { // YIELD (first_game.ceu : lin 27 : col 13) | yield(nil)
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    X->exe->status = CEU_EXE_STATUS_YIELDED;
                    X->exe->pc = 28012;
                    return 1;   // TODO: args MULTI
                case 28012: // YIELD (first_game.ceu : lin 27 : col 13) | yield(nil)
                    if (X->action == CEU_ACTION_ABORT) {
                        //ceux_push(X->S, 1, (CEU_Value){CEU_VALUE_NIL}); // fake out=1
                        continue;
                    }
                #if CEU >= 4
                    if (X->action == CEU_ACTION_ERROR) {
                        //assert(X->args>1 && CEU_ERROR_IS(X->S) && "TODO: varargs resume");
                        continue;
                    }
                #endif
                    //assert(X->args<=1 && "TODO: varargs resume");
                #if 0
                    // fill missing args with nils
                    {
                        int N = 1 - X->args;
                        assert(N > 0);
                        for (int i=0; i<N; i++) {
                            for (int i=0; i<N; i++) {
                                ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                            }
                        }
                    }
                #endif
                }
              // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                        // ACC - SET | (first_game.ceu : lin 29 : col 33) | it
                        ceux_repl(X->S, (X->base + 0 + 0 + 0) /* local it */, ceux_peek(X->S,XX(-1)));
                      // dst should not pop src
                }
             // BREAK | (first_game.ceu : lin 29 : col 33) | (break if is'(i
                
                { // CALL | (first_game.ceu : lin 27 : col 26) | is'(it,:Pico.Ke
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Pico_Key_Dn} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 27, col 26) : is'(it,:Pico.Key.Dn)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 27 : col 26) | is'(it,:Pico.Ke
                
                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_28033;
                    }
                }
            
                        
                            CEU_LOOP_STOP_28033:
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 28 : col 25) | (set it = yie
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : ) !CEU_BREAK ? 0 :  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                    if (CEU_BREAK) {
                        CEU_BREAK = 0;
                    } else {
                        //ceux_pop(X->S, 1);
                        goto CEU_LOOP_START_28033;
                    }
            // DELAY | (first_game.ceu : lin 30 : col 25) | delay
X->exe_task->time = CEU_TIME;
                { // BLOCK | (first_game.ceu : lin 34 : col 21) | do (val ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 35 : col 25) | (val ceu_22834 
                
                    
                { // INDEX | (first_game.ceu : lin 28 : col 17) | it[:key]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 0 + 0) /* local it */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 28, col 17) : it[:key]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "first_game.ceu : (lin 28, col 17) : it[:key]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    ceux_copy(X->S, (X->base + 0 + 1 + 0) /* local ceu_22834 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 35 : col 25) | (val ceu_22834 )
        
            
                // DCL | (first_game.ceu : lin 30 : col 29) | (val it :Key-Le
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_22834 */));

                    ceux_copy(X->S, (X->base + 0 + 1 + 1) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 30 : col 29) | (val it :Key-Le)
        
            
                { // IF | (first_game.ceu : lin 30 : col 29) | if is'(it,:Key-
                    
                { // CALL | (first_game.ceu : lin 29 : col 24) | is'(it,:Key-Lef
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 1) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Key_Left} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 29, col 24) : is'(it,:Key-Left)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 29 : col 24) | is'(it,:Key-Lef
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (first_game.ceu : lin 29 : col 35) | (set player[:
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // SET | (first_game.ceu : lin 29 : col 31) | (set player[:po
                    
                { // CALL | (first_game.ceu : lin 29 : col 63) | -(player[:p
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 23) /* global {{-}} */));

                    
                        
                { // INDEX | (first_game.ceu : lin 29 : col 50) | player[:pos][:x
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    
                { // INDEX | (first_game.ceu : lin 29 : col 50) | player[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->exe->clo.Dyn->Clo_Task.up_tsk->X->S /* nested */, (X->exe->clo.Dyn->Clo_Task.up_tsk->X->base + 0 + 0 + 2) /* local player */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 29, col 50) : player[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "first_game.ceu : (lin 29, col 50) : player[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 29, col 50) : player[:pos][:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "first_game.ceu : (lin 29, col 50) : player[:pos][:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 29, col 63) : {{-}}(player[:pos][:x],1)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 29 : col 63) | -(player[:p
                  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                { // INDEX | (first_game.ceu : lin 29 : col 35) | player[:pos][:x
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    
                { // INDEX | (first_game.ceu : lin 29 : col 35) | player[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->exe->clo.Dyn->Clo_Task.up_tsk->X->S /* nested */, (X->exe->clo.Dyn->Clo_Task.up_tsk->X->base + 0 + 0 + 2) /* local player */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 29, col 35) : player[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "first_game.ceu : (lin 29, col 35) : player[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 29, col 35) : player[:pos][:x]"
                    );
                
                        {
                            CEU_Value v = ceu_col_set(ceux_peek(X->S,XX(-1)), ceux_peek(X->S,XX(-2)), ceux_peek(X->S,XX(-3)));
                            CEU_ERROR_CHK_VAL(continue, v, "first_game.ceu : (lin 29, col 35) : player[:pos][:x]");
                            ceux_drop(X->S, 2);    // keep src
                        }
                        
                }
                  // dst should not pop src
                }
            
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 29 : col 35) | (set player[:
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+3, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        } else {
                            
                { // BLOCK | (first_game.ceu : lin 31 : col 36) | (val it :Key-
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 33 : col 29) | (val it :Key-Ri
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_22834 */));

                    ceux_copy(X->S, (X->base + 0 + 3 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 33 : col 29) | (val it :Key-Ri)
        
            
                { // IF | (first_game.ceu : lin 31 : col 29) | if is'(it,:Key-
                    
                { // CALL | (first_game.ceu : lin 30 : col 24) | is'(it,:Key-Rig
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 3 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Key_Right} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 30, col 24) : is'(it,:Key-Right)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 30 : col 24) | is'(it,:Key-Rig
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (first_game.ceu : lin 30 : col 36) | (set player[:
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // SET | (first_game.ceu : lin 30 : col 31) | (set player[:po
                    
                { // CALL | (first_game.ceu : lin 30 : col 63) | +(player[:p
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 22) /* global {{+}} */));

                    
                        
                { // INDEX | (first_game.ceu : lin 30 : col 50) | player[:pos][:x
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    
                { // INDEX | (first_game.ceu : lin 30 : col 50) | player[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->exe->clo.Dyn->Clo_Task.up_tsk->X->S /* nested */, (X->exe->clo.Dyn->Clo_Task.up_tsk->X->base + 0 + 0 + 2) /* local player */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 30, col 50) : player[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "first_game.ceu : (lin 30, col 50) : player[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 30, col 50) : player[:pos][:x]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "first_game.ceu : (lin 30, col 50) : player[:pos][:x]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 30, col 63) : {{+}}(player[:pos][:x],1)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 30 : col 63) | +(player[:p
                  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                { // INDEX | (first_game.ceu : lin 30 : col 35) | player[:pos][:x
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    
                { // INDEX | (first_game.ceu : lin 30 : col 35) | player[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->exe->clo.Dyn->Clo_Task.up_tsk->X->S /* nested */, (X->exe->clo.Dyn->Clo_Task.up_tsk->X->base + 0 + 0 + 2) /* local player */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 30, col 35) : player[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "first_game.ceu : (lin 30, col 35) : player[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 30, col 35) : player[:pos][:x]"
                    );
                
                        {
                            CEU_Value v = ceu_col_set(ceux_peek(X->S,XX(-1)), ceux_peek(X->S,XX(-2)), ceux_peek(X->S,XX(-3)));
                            CEU_ERROR_CHK_VAL(continue, v, "first_game.ceu : (lin 30, col 35) : player[:pos][:x]");
                            ceux_drop(X->S, 2);    // keep src
                        }
                        
                }
                  // dst should not pop src
                }
            
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 30 : col 36) | (set player[:
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        } else {
                            
                { // BLOCK | (first_game.ceu : lin 32 : col 36) | (val it :Key-
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 34 : col 29) | (val it :Key-Do
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_22834 */));

                    ceux_copy(X->S, (X->base + 0 + 4 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 34 : col 29) | (val it :Key-Do)
        
            
                { // IF | (first_game.ceu : lin 32 : col 29) | if is'(it,:Key-
                    
                { // CALL | (first_game.ceu : lin 31 : col 24) | is'(it,:Key-Dow
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Key_Down} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 31, col 24) : is'(it,:Key-Down)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 31 : col 24) | is'(it,:Key-Dow
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (first_game.ceu : lin 31 : col 35) | (set player[:
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // SET | (first_game.ceu : lin 31 : col 31) | (set player[:po
                    
                { // CALL | (first_game.ceu : lin 31 : col 63) | -(player[:p
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 23) /* global {{-}} */));

                    
                        
                { // INDEX | (first_game.ceu : lin 31 : col 50) | player[:pos][:y
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    
                { // INDEX | (first_game.ceu : lin 31 : col 50) | player[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->exe->clo.Dyn->Clo_Task.up_tsk->X->S /* nested */, (X->exe->clo.Dyn->Clo_Task.up_tsk->X->base + 0 + 0 + 2) /* local player */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 31, col 50) : player[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "first_game.ceu : (lin 31, col 50) : player[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 31, col 50) : player[:pos][:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "first_game.ceu : (lin 31, col 50) : player[:pos][:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 31, col 63) : {{-}}(player[:pos][:y],1)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 31 : col 63) | -(player[:p
                  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                { // INDEX | (first_game.ceu : lin 31 : col 35) | player[:pos][:y
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    
                { // INDEX | (first_game.ceu : lin 31 : col 35) | player[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->exe->clo.Dyn->Clo_Task.up_tsk->X->S /* nested */, (X->exe->clo.Dyn->Clo_Task.up_tsk->X->base + 0 + 0 + 2) /* local player */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 31, col 35) : player[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "first_game.ceu : (lin 31, col 35) : player[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 31, col 35) : player[:pos][:y]"
                    );
                
                        {
                            CEU_Value v = ceu_col_set(ceux_peek(X->S,XX(-1)), ceux_peek(X->S,XX(-2)), ceux_peek(X->S,XX(-3)));
                            CEU_ERROR_CHK_VAL(continue, v, "first_game.ceu : (lin 31, col 35) : player[:pos][:y]");
                            ceux_drop(X->S, 2);    // keep src
                        }
                        
                }
                  // dst should not pop src
                }
            
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 31 : col 35) | (set player[:
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+5, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        } else {
                            
                { // BLOCK | (first_game.ceu : lin 33 : col 36) | (val it :Key-
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 35 : col 29) | (val it :Key-Up
                
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_22834 */));

                    ceux_copy(X->S, (X->base + 0 + 5 + 0) /* local it */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 35 : col 29) | (val it :Key-Up)
        
            
                { // IF | (first_game.ceu : lin 33 : col 29) | if is'(it,:Key-
                    
                { // CALL | (first_game.ceu : lin 32 : col 24) | is'(it,:Key-Up)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 5 + 0) /* local it */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_Key_Up} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 32, col 24) : is'(it,:Key-Up)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 32 : col 24) | is'(it,:Key-Up)
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (first_game.ceu : lin 32 : col 33) | (set player[:
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // SET | (first_game.ceu : lin 32 : col 31) | (set player[:po
                    
                { // CALL | (first_game.ceu : lin 32 : col 63) | +(player[:p
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 22) /* global {{+}} */));

                    
                        
                { // INDEX | (first_game.ceu : lin 32 : col 50) | player[:pos][:y
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    
                { // INDEX | (first_game.ceu : lin 32 : col 50) | player[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->exe->clo.Dyn->Clo_Task.up_tsk->X->S /* nested */, (X->exe->clo.Dyn->Clo_Task.up_tsk->X->base + 0 + 0 + 2) /* local player */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 32, col 50) : player[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "first_game.ceu : (lin 32, col 50) : player[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 32, col 50) : player[:pos][:y]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "first_game.ceu : (lin 32, col 50) : player[:pos][:y]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 32, col 63) : {{+}}(player[:pos][:y],1)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 32 : col 63) | +(player[:p
                  // src is on the stack and should be returned
                    // <<< SRC | DST >>>
                    
                { // INDEX | (first_game.ceu : lin 32 : col 35) | player[:pos][:y
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=1} });
                        
                    
                    // COL
                    
                { // INDEX | (first_game.ceu : lin 32 : col 35) | player[:pos]
                    // IDX
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        
                    
                    // COL
                    ceux_push(X->S, 1, ceux_peek(X->exe->clo.Dyn->Clo_Task.up_tsk->X->S /* nested */, (X->exe->clo.Dyn->Clo_Task.up_tsk->X->base + 0 + 0 + 2) /* local player */));

                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 32, col 35) : player[:pos]"
                    );
                
                        {
                            CEU_Value v = CEU_ERROR_CHK_VAL(continue, ceu_col_get(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))), "first_game.ceu : (lin 32, col 35) : player[:pos]");
                            ceu_gc_inc_val(v);
                            ceux_drop(X->S, 2);
                            ceux_push(X->S, 1, v);
                            ceu_gc_dec_val(v);
                        }
                    
                }
                
                    CEU_ERROR_CHK_VAL (
                        continue,
                        ceu_col_check(ceux_peek(X->S,XX(-1)),ceux_peek(X->S,XX(-2))),
                        "first_game.ceu : (lin 32, col 35) : player[:pos][:y]"
                    );
                
                        {
                            CEU_Value v = ceu_col_set(ceux_peek(X->S,XX(-1)), ceux_peek(X->S,XX(-2)), ceux_peek(X->S,XX(-3)));
                            CEU_ERROR_CHK_VAL(continue, v, "first_game.ceu : (lin 32, col 35) : player[:pos][:y]");
                            ceux_drop(X->S, 2);    // keep src
                        }
                        
                }
                  // dst should not pop src
                }
            
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 32 : col 33) | (set player[:
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        } else {
                            
                { // BLOCK | (first_game.ceu : lin 34 : col 36) | (do nil)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        // PASS | (first_game.ceu : lin 34 : col 36) | (do nil)
ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 34 : col 36) | nil)
        
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 34 : col 36) | (do nil)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 33 : col 36) | (val it :Key-
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+5, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 32 : col 36) | (val it :Key-
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+4, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 31 : col 36) | (val it :Key-
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+3, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 34 : col 21) | do (val ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+1, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                { // IF | (first_game.ceu : lin 35 : col 13) | if pico-rect-vs
                    
                { // CALL | (first_game.ceu : lin 35 : col 18) | pico-rect-vs-re
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 104) /* global pico-rect-vs-rect? */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->exe->clo.Dyn->Clo_Task.up_tsk->X->S /* nested */, (X->exe->clo.Dyn->Clo_Task.up_tsk->X->base + 0 + 0 + 2) /* local player */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->exe->clo.Dyn->Clo_Task.up_tsk->X->S /* nested */, (X->exe->clo.Dyn->Clo_Task.up_tsk->X->base + 0 + 0 + 3) /* local coin */));

                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 35, col 18) : pico-rect-vs-rect?(player,coin)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 35 : col 18) | pico-rect-vs-re
                
                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (first_game.ceu : lin 35 : col 52) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (first_game.ceu : lin 41 : col 21) | do (val ceu_0
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 43 : col 29) | (val ceu_0_2358
                
                    
                { // SPAWN | (first_game.ceu : lin 60 : col 30) | (spawn (task :n
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                     // CREATE | (first_game.ceu : lin 60 : col 37) | (task :nested (
                {
                    assert(X->exe!=NULL && X->exe->type==CEU_VALUE_EXE_TASK);
                    CEU_Value clo = ceu_create_clo_task (
                        
                        ceu_f_28474,
                        0,  // TODO: remove assert
                        2,
                        0
                        , X->exe_task
                    );
                    ceux_push(X->S, 1, clo);
                    
                        // TODO: use args+locs+upvs+tmps?
                        //clo.Dyn->Clo_Exe.mem_n = sizeof(CEU_Clo_Mem_28474);                    
                    
                    
                    // UPVALS = 0
                    
                }
                
                    
                    {
                        ceux_spawn(X, 0, X->now);
                        
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 60, col 30) : (spawn (task :nested () { do { (var ceu_23456...)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                        
                    }
                } // SPAWN | (first_game.ceu : lin 60 : col 30) | (spawn (task :n
            
                    ceux_copy(X->S, (X->base + 0 + 1 + 0) /* local ceu_0_23581 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 43 : col 29) | (val ceu_0_2358)
        
            
                // DCL | (first_game.ceu : lin 62 : col 29) | (val ceu_1_2358
                
                    
                { // SPAWN | (first_game.ceu : lin 42 : col 30) | (spawn (task :n
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                     // CREATE | (first_game.ceu : lin 42 : col 37) | (task :nested (
                {
                    assert(X->exe!=NULL && X->exe->type==CEU_VALUE_EXE_TASK);
                    CEU_Value clo = ceu_create_clo_task (
                        
                        ceu_f_28617,
                        0,  // TODO: remove assert
                        2,
                        0
                        , X->exe_task
                    );
                    ceux_push(X->S, 1, clo);
                    
                        // TODO: use args+locs+upvs+tmps?
                        //clo.Dyn->Clo_Exe.mem_n = sizeof(CEU_Clo_Mem_28617);                    
                    
                    
                    // UPVALS = 0
                    
                }
                
                    
                    {
                        ceux_spawn(X, 0, X->now);
                        
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 42, col 30) : (spawn (task :nested () { loop { do { (var it...)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                        
                    }
                } // SPAWN | (first_game.ceu : lin 42 : col 30) | (spawn (task :n
            
                    ceux_copy(X->S, (X->base + 0 + 1 + 1) /* local ceu_1_23581 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 62 : col 29) | (val ceu_1_2358)
        
            
                // LOOP | (first_game.ceu : lin 44 : col 25) | loop (break i
                CEU_LOOP_START_28834:
                    
                { // BLOCK | (first_game.ceu : lin 44 : col 25) | (break if do 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                         // BREAK | (first_game.ceu : lin 45 : col 29) | (break if do 
                
                { // BLOCK | (first_game.ceu : lin 51 : col 21) | do (val ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+3, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 52 : col 25) | (val ceu_24394 
                
                    
                { // BLOCK | (first_game.ceu : lin 48 : col 21) | do (val ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 49 : col 25) | (val ceu_24279 
                
                    
                { // CALL | (first_game.ceu : lin 47 : col 60) | ==(status(c
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        
                { // CALL | (first_game.ceu : lin 47 : col 40) | status(ceu_0_23
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 17) /* global status */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_0_23581 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 47, col 40) : status(ceu_0_23581)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 47 : col 40) | status(ceu_0_23
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_terminated} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 47, col 60) : {{==}}(status(ceu_0_23581),:terminated)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 47 : col 60) | ==(status(c
                
                    ceux_copy(X->S, (X->base + 0 + 4 + 0) /* local ceu_24279 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 49 : col 25) | (val ceu_24279 )
        
            
                { // IF | (first_game.ceu : lin 48 : col 25) | if ceu_24279 
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local ceu_24279 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (first_game.ceu : lin 48 : col 38) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (first_game.ceu : lin 48 : col 21) | do (val ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 49 : col 25) | (val ceu_24287 
                
                    
            { // PUB | (first_game.ceu : lin 47 : col 81) | ceu_0_23581.pub
                ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 0) /* local ceu_0_23581 */));

                CEU_Value tsk = 
                    ceux_peek(X->S, XX(-1))
                
                ;
                
                    if (!ceu_istask_val(tsk)) {
                        CEU_ERROR_THR_S(continue, "pub error : expected task", "first_game.ceu : (lin 47, col 81) : ceu_0_23581.pub");
                    }
                
                
                    // [(tsk)]
                    
                        ceux_repl(X->S, XX(-1), tsk.Dyn->Exe_Task.pub);                        
                    
                    // [pub]
                
            }
            
                    ceux_copy(X->S, (X->base + 0 + 5 + 0) /* local ceu_24287 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 49 : col 25) | (val ceu_24287 )
        
            
                { // IF | (first_game.ceu : lin 48 : col 25) | if ceu_24287 
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 5 + 0) /* local ceu_24287 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (first_game.ceu : lin 48 : col 38) | ceu_24287
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 5 + 0) /* local ceu_24287 */));

                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 48 : col 38) | ceu_24287
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        } else {
                            
                { // BLOCK | (first_game.ceu : lin 50 : col 32) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 50 : col 32) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 48 : col 21) | do (val ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 48 : col 38) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        } else {
                            
                { // BLOCK | (first_game.ceu : lin 50 : col 32) | ceu_24279
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local ceu_24279 */));

                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 50 : col 32) | ceu_24279
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 48 : col 21) | do (val ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                    ceux_copy(X->S, (X->base + 0 + 3 + 0) /* local ceu_24394 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 52 : col 25) | (val ceu_24394 )
        
            
                { // IF | (first_game.ceu : lin 54 : col 25) | if ceu_24394 
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 3 + 0) /* local ceu_24394 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (first_game.ceu : lin 54 : col 38) | ceu_24394
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 3 + 0) /* local ceu_24394 */));

                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 54 : col 38) | ceu_24394
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        } else {
                            
                { // BLOCK | (first_game.ceu : lin 56 : col 32) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (first_game.ceu : lin 51 : col 21) | do (val ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 52 : col 25) | (val ceu_24527 
                
                    
                { // BLOCK | (first_game.ceu : lin 50 : col 21) | do (val ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 51 : col 25) | (val ceu_24412 
                
                    
                { // CALL | (first_game.ceu : lin 49 : col 60) | ==(status(c
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        
                { // CALL | (first_game.ceu : lin 49 : col 40) | status(ceu_1_23
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 17) /* global status */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 1) /* local ceu_1_23581 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 49, col 40) : status(ceu_1_23581)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 49 : col 40) | status(ceu_1_23
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_terminated} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 49, col 60) : {{==}}(status(ceu_1_23581),:terminated)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 49 : col 60) | ==(status(c
                
                    ceux_copy(X->S, (X->base + 0 + 5 + 0) /* local ceu_24412 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 51 : col 25) | (val ceu_24412 )
        
            
                { // IF | (first_game.ceu : lin 50 : col 25) | if ceu_24412 
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 5 + 0) /* local ceu_24412 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (first_game.ceu : lin 50 : col 38) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (first_game.ceu : lin 50 : col 21) | do (val ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 51 : col 25) | (val ceu_24420 
                
                    
            { // PUB | (first_game.ceu : lin 49 : col 81) | ceu_1_23581.pub
                ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 1 + 1) /* local ceu_1_23581 */));

                CEU_Value tsk = 
                    ceux_peek(X->S, XX(-1))
                
                ;
                
                    if (!ceu_istask_val(tsk)) {
                        CEU_ERROR_THR_S(continue, "pub error : expected task", "first_game.ceu : (lin 49, col 81) : ceu_1_23581.pub");
                    }
                
                
                    // [(tsk)]
                    
                        ceux_repl(X->S, XX(-1), tsk.Dyn->Exe_Task.pub);                        
                    
                    // [pub]
                
            }
            
                    ceux_copy(X->S, (X->base + 0 + 6 + 0) /* local ceu_24420 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 51 : col 25) | (val ceu_24420 )
        
            
                { // IF | (first_game.ceu : lin 50 : col 25) | if ceu_24420 
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 6 + 0) /* local ceu_24420 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (first_game.ceu : lin 50 : col 38) | ceu_24420
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+7, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 6 + 0) /* local ceu_24420 */));

                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 50 : col 38) | ceu_24420
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+7, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        } else {
                            
                { // BLOCK | (first_game.ceu : lin 52 : col 32) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+7, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 52 : col 32) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+7, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 50 : col 21) | do (val ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 50 : col 38) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        } else {
                            
                { // BLOCK | (first_game.ceu : lin 52 : col 32) | ceu_24412
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 5 + 0) /* local ceu_24412 */));

                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 52 : col 32) | ceu_24412
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 50 : col 21) | do (val ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                    ceux_copy(X->S, (X->base + 0 + 4 + 0) /* local ceu_24527 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 52 : col 25) | (val ceu_24527 )
        
            
                { // IF | (first_game.ceu : lin 56 : col 25) | if ceu_24527 
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local ceu_24527 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (first_game.ceu : lin 56 : col 38) | ceu_24527
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local ceu_24527 */));

                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 56 : col 38) | ceu_24527
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        } else {
                            
                { // BLOCK | (first_game.ceu : lin 58 : col 32) | false
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+5, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 58 : col 32) | false
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+5, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 51 : col 21) | do (val ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 56 : col 32) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 51 : col 21) | do (val ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+3, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_28834;
                    }
                }
            
                { // YIELD (first_game.ceu : lin 52 : col 29) | yield(nil)
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    X->exe->status = CEU_EXE_STATUS_YIELDED;
                    X->exe->pc = 28828;
                    return 1;   // TODO: args MULTI
                case 28828: // YIELD (first_game.ceu : lin 52 : col 29) | yield(nil)
                    if (X->action == CEU_ACTION_ABORT) {
                        //ceux_push(X->S, 1, (CEU_Value){CEU_VALUE_NIL}); // fake out=1
                        continue;
                    }
                #if CEU >= 4
                    if (X->action == CEU_ACTION_ERROR) {
                        //assert(X->args>1 && CEU_ERROR_IS(X->S) && "TODO: varargs resume");
                        continue;
                    }
                #endif
                    //assert(X->args<=1 && "TODO: varargs resume");
                #if 0
                    // fill missing args with nils
                    {
                        int N = 0 - X->args;
                        assert(N > 0);
                        for (int i=0; i<N; i++) {
                            for (int i=0; i<N; i++) {
                                ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                            }
                        }
                    }
                #endif
                }
            
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 52 : col 29) | yield(nil))
        // DELAY | (first_game.ceu : lin 53 : col 29) | delay
X->exe_task->time = CEU_TIME;
                        
                            CEU_LOOP_STOP_28834:
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 44 : col 25) | (break if do 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : ) !CEU_BREAK ? 0 :  1;
                        ceux_block_leave(X->S, X->base+3, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                    if (CEU_BREAK) {
                        CEU_BREAK = 0;
                    } else {
                        //ceux_pop(X->S, 1);
                        goto CEU_LOOP_START_28834;
                    }
            
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 41 : col 21) | do (val ceu_0
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 35 : col 52) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        } else {
                            
                { // BLOCK | (first_game.ceu : lin 35 : col 13) | nil
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+1, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 35 : col 13) | nil
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+1, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 43 : col 21) | do (var it :P
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 39 : col 53) | do (var it 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                } while (0);
                        
                                {
                                    int top = ceux_n_get(X->S);
                                
                                    // task return value in pub(t)
                                    if (top > 0) {
                                        ceu_gc_dec_val(X->exe_task->pub);
                                        X->exe_task->pub = ceux_peek(X->S, XX(-1));
                                        ceu_gc_inc_val(X->exe_task->pub);
                                    }
                                
                                    int ret = ceu_exe_term(X);
                                    if (!CEU_ERROR_IS(X->S) && ret!=0) {
                                        // nrm->err: remove pending return in the stack
                                        ceux_rem(X->S, top-1);
                                    }
                                }
                            } // close switch
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (first_game.ceu : lin 45 : col 37) | (task :nested (
                    int ceu_f_28881 (CEUX* X) {
                        
                            X->exe->status = (X->action == CEU_ACTION_ABORT) ? CEU_EXE_STATUS_TERMINATED : CEU_EXE_STATUS_RESUMED;
                            switch (X->exe->pc) {
                                case 0:
                                    if (X->action == CEU_ACTION_ABORT) {
                                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                                        return 1;
                                    }
                        
                        do {
                { // BLOCK | (first_game.ceu : lin 45 : col 53) | (do nil)
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        // PASS | (first_game.ceu : lin 43 : col 16) | (do nil)
ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 45 : col 53) | (do nil)
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                } while (0);
                        
                                {
                                    int top = ceux_n_get(X->S);
                                
                                    // task return value in pub(t)
                                    if (top > 0) {
                                        ceu_gc_dec_val(X->exe_task->pub);
                                        X->exe_task->pub = ceux_peek(X->S, XX(-1));
                                        ceu_gc_inc_val(X->exe_task->pub);
                                    }
                                
                                    int ret = ceu_exe_term(X);
                                    if (!CEU_ERROR_IS(X->S) && ret!=0) {
                                        // nrm->err: remove pending return in the stack
                                        ceux_rem(X->S, top-1);
                                    }
                                }
                            } // close switch
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (first_game.ceu : lin 47 : col 9) | (task :nested (
                    int ceu_f_29002 (CEUX* X) {
                        
                            X->exe->status = (X->action == CEU_ACTION_ABORT) ? CEU_EXE_STATUS_TERMINATED : CEU_EXE_STATUS_RESUMED;
                            switch (X->exe->pc) {
                                case 0:
                                    if (X->action == CEU_ACTION_ABORT) {
                                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                                        return 1;
                                    }
                        
                        do {
                { // BLOCK | (first_game.ceu : lin 47 : col 25) | (var score = 
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 4 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 8 : col 5) | (var score = 0)
                
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                    ceux_copy(X->S, (X->base + 0 + 0 + 0) /* local score */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 8 : col 5) | (var score = 0))
        
            
                // DCL | (first_game.ceu : lin 9 : col 5) | (var score-text
                
                    
                { // VECTOR | (first_game.ceu : lin 9 : col 22) | #['s','c','o','
                    ceux_push(X->S, 1, ceu_create_vector());
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='s'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='c'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='o'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 2, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='r'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 3, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='e'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 4, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char=':'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 5, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char=' '} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 6, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    ceux_copy(X->S, (X->base + 0 + 0 + 1) /* local score-text */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 9 : col 5) | (var score-text)
        
            
                // DCL | (first_game.ceu : lin 10 : col 5) | (var player :Re
                
                    
                { // TUPLE | (first_game.ceu : lin 10 : col 24) | [[-(10),5],
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    
                { // TUPLE | (first_game.ceu : lin 10 : col 25) | [-(10),5]
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    
                { // CALL | (first_game.ceu : lin 10 : col 26) | -(10)
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 23) /* global {{-}} */));

                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=10} });
                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 10, col 26) : {{-}}(10)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 10 : col 26) | -(10)
                
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=5} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                { // TUPLE | (first_game.ceu : lin 10 : col 33) | [5,5]
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=5} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=5} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    ceux_copy(X->S, (X->base + 0 + 0 + 2) /* local player */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 10 : col 5) | (var player :Re)
        
            
                // DCL | (first_game.ceu : lin 11 : col 5) | (var coin :Rect
                
                    
                { // TUPLE | (first_game.ceu : lin 11 : col 22) | [[0,0],[5,5]]
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    
                { // TUPLE | (first_game.ceu : lin 11 : col 23) | [0,0]
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=0} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                { // TUPLE | (first_game.ceu : lin 11 : col 29) | [5,5]
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=5} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=5} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    ceux_copy(X->S, (X->base + 0 + 0 + 3) /* local coin */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 11 : col 5) | (var coin :Rect)
        
            
                { // SPAWN | (first_game.ceu : lin 22 : col 6) | (spawn (task :n
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                     // CREATE | (first_game.ceu : lin 22 : col 13) | (task :nested (
                {
                    assert(X->exe!=NULL && X->exe->type==CEU_VALUE_EXE_TASK);
                    CEU_Value clo = ceu_create_clo_task (
                        
                        ceu_f_27969,
                        0,  // TODO: remove assert
                        2,
                        0
                        , X->exe_task
                    );
                    ceux_push(X->S, 1, clo);
                    
                        // TODO: use args+locs+upvs+tmps?
                        //clo.Dyn->Clo_Exe.mem_n = sizeof(CEU_Clo_Mem_27969);                    
                    
                    
                    // UPVALS = 0
                    
                }
                
                    
                    {
                        ceux_spawn(X, 0, X->now);
                        
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 22, col 6) : (spawn (task :nested () { loop { do { (var it...)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                        ceux_pop(X->S, 1);
                    }
                } // SPAWN | (first_game.ceu : lin 22 : col 6) | (spawn (task :n
            
                // LOOP | (first_game.ceu : lin 24 : col 5) | loop do (va
                CEU_LOOP_START_28999:
                    
                { // BLOCK | (first_game.ceu : lin 24 : col 5) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (first_game.ceu : lin 26 : col 9) | do (val ceu_0
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+4, 2 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 28 : col 29) | (val ceu_0_2570
                
                    
                { // SPAWN | (first_game.ceu : lin 39 : col 30) | (spawn (task :n
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                     // CREATE | (first_game.ceu : lin 39 : col 37) | (task :nested (
                {
                    assert(X->exe!=NULL && X->exe->type==CEU_VALUE_EXE_TASK);
                    CEU_Value clo = ceu_create_clo_task (
                        
                        ceu_f_28852,
                        0,  // TODO: remove assert
                        7,
                        0
                        , X->exe_task
                    );
                    ceux_push(X->S, 1, clo);
                    
                        // TODO: use args+locs+upvs+tmps?
                        //clo.Dyn->Clo_Exe.mem_n = sizeof(CEU_Clo_Mem_28852);                    
                    
                    
                    // UPVALS = 0
                    
                }
                
                    
                    {
                        ceux_spawn(X, 0, X->now);
                        
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 39, col 30) : (spawn (task :nested () { do { (var it :Pico....)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                        
                    }
                } // SPAWN | (first_game.ceu : lin 39 : col 30) | (spawn (task :n
            
                    ceux_copy(X->S, (X->base + 0 + 4 + 0) /* local ceu_0_25702 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 28 : col 29) | (val ceu_0_2570)
        
            
                // DCL | (first_game.ceu : lin 41 : col 29) | (val ceu_1_2570
                
                    
                { // SPAWN | (first_game.ceu : lin 45 : col 30) | (spawn (task :n
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                     // CREATE | (first_game.ceu : lin 45 : col 37) | (task :nested (
                {
                    assert(X->exe!=NULL && X->exe->type==CEU_VALUE_EXE_TASK);
                    CEU_Value clo = ceu_create_clo_task (
                        
                        ceu_f_28881,
                        0,  // TODO: remove assert
                        0,
                        0
                        , X->exe_task
                    );
                    ceux_push(X->S, 1, clo);
                    
                        // TODO: use args+locs+upvs+tmps?
                        //clo.Dyn->Clo_Exe.mem_n = sizeof(CEU_Clo_Mem_28881);                    
                    
                    
                    // UPVALS = 0
                    
                }
                
                    
                    {
                        ceux_spawn(X, 0, X->now);
                        
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 45, col 30) : (spawn (task :nested () { (do nil) })())");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                        
                    }
                } // SPAWN | (first_game.ceu : lin 45 : col 30) | (spawn (task :n
            
                    ceux_copy(X->S, (X->base + 0 + 4 + 1) /* local ceu_1_25702 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 41 : col 29) | (val ceu_1_2570)
        
            
                // LOOP | (first_game.ceu : lin 47 : col 25) | loop (break(n
                CEU_LOOP_START_28992:
                    
                { // BLOCK | (first_game.ceu : lin 47 : col 25) | (break(nil) i
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                         // BREAK | (first_game.ceu : lin 48 : col 29) | (break(nil) if 
                
                { // BLOCK | (first_game.ceu : lin 54 : col 21) | do (val ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+6, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 55 : col 25) | (val ceu_27522 
                
                    
                { // CALL | (first_game.ceu : lin 50 : col 59) | ==(status(c
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        
                { // CALL | (first_game.ceu : lin 50 : col 39) | status(ceu_0_25
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 17) /* global status */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 0) /* local ceu_0_25702 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 50, col 39) : status(ceu_0_25702)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 50 : col 39) | status(ceu_0_25
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_terminated} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 50, col 59) : {{==}}(status(ceu_0_25702),:terminated)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 50 : col 59) | ==(status(c
                
                    ceux_copy(X->S, (X->base + 0 + 6 + 0) /* local ceu_27522 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 55 : col 25) | (val ceu_27522 )
        
            
                { // IF | (first_game.ceu : lin 51 : col 25) | if ceu_27522 
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 6 + 0) /* local ceu_27522 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (first_game.ceu : lin 51 : col 38) | do (val ceu
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+7, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                { // BLOCK | (first_game.ceu : lin 54 : col 21) | do (val ceu_2
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+7, 1 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        
                // DCL | (first_game.ceu : lin 55 : col 25) | (val ceu_27539 
                
                    
                { // CALL | (first_game.ceu : lin 52 : col 59) | ==(status(c
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 14) /* global {{==}} */));

                    
                        
                { // CALL | (first_game.ceu : lin 52 : col 39) | status(ceu_1_25
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 17) /* global status */));

                    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 4 + 1) /* local ceu_1_25702 */));

                                        
                    

                    ceux_call(X, 1, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 52, col 39) : status(ceu_1_25702)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 52 : col 39) | status(ceu_1_25
                
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_TAG, {.Tag=CEU_TAG_terminated} });
                                        
                    

                    ceux_call(X, 2, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 52, col 59) : {{==}}(status(ceu_1_25702),:terminated)");
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                } // CALL | (first_game.ceu : lin 52 : col 59) | ==(status(c
                
                    ceux_copy(X->S, (X->base + 0 + 7 + 0) /* local ceu_27539 */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 55 : col 25) | (val ceu_27539 )
        
            
                { // IF | (first_game.ceu : lin 53 : col 25) | if ceu_27539 
                    ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 7 + 0) /* local ceu_27539 */));

                    {
                        int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        ceux_pop(X->S, 1);
                        if (v) {
                            
                { // BLOCK | (first_game.ceu : lin 53 : col 38) | true
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+8, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 53 : col 38) | true
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+8, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        } else {
                            
                { // BLOCK | (first_game.ceu : lin 54 : col 32) | ceu_27539
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+8, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 7 + 0) /* local ceu_27539 */));

                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 54 : col 32) | ceu_27539
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+8, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 54 : col 21) | do (val ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+7, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 51 : col 38) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+7, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        } else {
                            
                { // BLOCK | (first_game.ceu : lin 58 : col 32) | ceu_27522
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+7, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        ceux_push(X->S, 1, ceux_peek(X->S, (X->base + 0 + 6 + 0) /* local ceu_27522 */));

                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 58 : col 32) | ceu_27522
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+7, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        }
                    }
                }
                
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 54 : col 21) | do (val ceu_2
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+6, 1, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                {
                    int v = ceu_as_bool(ceux_peek(X->S, XX(-1)));
                        // pop condition:
                        //  1. when false, clear for next iteration
                        //  2. when true,  but return e is given
                        //  3. when true,  but ret=0
                    if (!v) {
                        ceux_pop(X->S, 1);            // (1)
                    } else {
                        
                            ceux_pop(X->S, 1);        // (2)
                            ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 48 : col 35) | nil)
        
                        
                        CEU_BREAK = 1;
                        goto CEU_LOOP_STOP_28992;
                    }
                }
            
                { // YIELD (first_game.ceu : lin 55 : col 29) | yield(nil)
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    X->exe->status = CEU_EXE_STATUS_YIELDED;
                    X->exe->pc = 28986;
                    return 1;   // TODO: args MULTI
                case 28986: // YIELD (first_game.ceu : lin 55 : col 29) | yield(nil)
                    if (X->action == CEU_ACTION_ABORT) {
                        //ceux_push(X->S, 1, (CEU_Value){CEU_VALUE_NIL}); // fake out=1
                        continue;
                    }
                #if CEU >= 4
                    if (X->action == CEU_ACTION_ERROR) {
                        //assert(X->args>1 && CEU_ERROR_IS(X->S) && "TODO: varargs resume");
                        continue;
                    }
                #endif
                    //assert(X->args<=1 && "TODO: varargs resume");
                #if 0
                    // fill missing args with nils
                    {
                        int N = 0 - X->args;
                        assert(N > 0);
                        for (int i=0; i<N; i++) {
                            for (int i=0; i<N; i++) {
                                ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                            }
                        }
                    }
                #endif
                }
            
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 55 : col 29) | yield(nil))
        // DELAY | (first_game.ceu : lin 56 : col 29) | delay
X->exe_task->time = CEU_TIME;
                        
                            CEU_LOOP_STOP_28992:
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 47 : col 25) | (break(nil) i
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : ) !CEU_BREAK ? 0 :  0;
                        ceux_block_leave(X->S, X->base+6, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                    if (CEU_BREAK) {
                        CEU_BREAK = 0;
                    } else {
                        //ceux_pop(X->S, 1);
                        goto CEU_LOOP_START_28992;
                    }
            
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 26 : col 9) | do (val ceu_0
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+4, 2, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                        
                            CEU_LOOP_STOP_28999:
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 24 : col 5) | do (val ceu
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : ) !CEU_BREAK ? 0 :  1;
                        ceux_block_leave(X->S, X->base+4, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                
                    if (CEU_BREAK) {
                        CEU_BREAK = 0;
                    } else {
                        //ceux_pop(X->S, 1);
                        goto CEU_LOOP_START_28999;
                    }
            
                        
                    } while (0);

                    // BLOCK (escape) | (first_game.ceu : lin 47 : col 25) | (var score = 
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 4, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
                if (X->exe->status == CEU_EXE_STATUS_TERMINATED) {
                    continue;
                }
            
        
                }
                } while (0);
                        
                                {
                                    int top = ceux_n_get(X->S);
                                
                                    // task return value in pub(t)
                                    if (top > 0) {
                                        ceu_gc_dec_val(X->exe_task->pub);
                                        X->exe_task->pub = ceux_peek(X->S, XX(-1));
                                        ceu_gc_inc_val(X->exe_task->pub);
                                    }
                                
                                    int ret = ceu_exe_term(X);
                                    if (!CEU_ERROR_IS(X->S) && ret!=0) {
                                        // nrm->err: remove pending return in the stack
                                        ceux_rem(X->S, top-1);
                                    }
                                }
                            } // close switch
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
                    // PROTO | (anon : lin 0 : col 0) | (func () (val
                    int ceu_f_29081 (CEUX* X) {
                        
                        do {
                { // BLOCK | (anon : lin 0 : col 0) | (val dump)(v
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+0, 108 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    
                    {
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_dump_f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 0, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_error_f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 1, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_next_dash_dict_f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 2, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_print_f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 3, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_println_f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 4, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_sup_question__f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 5, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_tags_f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 6, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_to_dash_string_dash_number_f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 7, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_to_dash_string_dash_pointer_f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 8, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_to_dash_string_dash_tag_f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 9, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_to_dash_tag_dash_string_f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 10, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_tuple_f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 11, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_type_f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 12, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_hash_f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 13, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_equals_equals_f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 14, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_slash_equals_f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 15, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_coroutine_f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 16, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_status_f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 17, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_broadcast_plic__f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 18, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_next_dash_tasks_f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 19, clo);
                        }
                        
                        {
                            CEU_Value clo = ceu_create_clo(CEU_VALUE_CLO_FUNC, ceu_tasks_f, 0, 0, 0);
                            ceux_repl(X->S, X->base + 20, clo);
                        }
                        
                    }
                    

                    // defers init
                    
                    ceux_repl(X->S, (1 + 0 + 69) /* global defer */, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        // false: not reached, dont finalize
                
                    
                    do {    
                        
                // DCL | (anon : lin 0 : col 0) | (val dump)
                
            
                // DCL | (anon : lin 0 : col 0) | (val error)
                
            
                // DCL | (anon : lin 0 : col 0) | (val next-dict)
                
            
                // DCL | (anon : lin 0 : col 0) | (val print)
                
            
                // DCL | (anon : lin 0 : col 0) | (val println)
                
            
                // DCL | (anon : lin 0 : col 0) | (val sup?)
                
            
                // DCL | (anon : lin 0 : col 0) | (val tags)
                
            
                // DCL | (anon : lin 0 : col 0) | (val to-string-
                
            
                // DCL | (anon : lin 0 : col 0) | (val to-string-
                
            
                // DCL | (anon : lin 0 : col 0) | (val to-string-
                
            
                // DCL | (anon : lin 0 : col 0) | (val to-tag-str
                
            
                // DCL | (anon : lin 0 : col 0) | (val tuple)
                
            
                // DCL | (anon : lin 0 : col 0) | (val type)
                
            
                // DCL | (anon : lin 0 : col 0) | (val #)
                
            
                // DCL | (anon : lin 0 : col 0) | (val ==)
                
            
                // DCL | (anon : lin 0 : col 0) | (val /=)
                
            
                // DCL | (anon : lin 0 : col 0) | (val coroutine)
                
            
                // DCL | (anon : lin 0 : col 0) | (val status)
                
            
                // DCL | (anon : lin 0 : col 0) | (val broadcast'
                
            
                // DCL | (anon : lin 0 : col 0) | (val next-tasks
                
            
                // DCL | (anon : lin 0 : col 0) | (val tasks)
                
            // DATA | (prelude.ceu : lin 1 : col 6) | (data :Clock = 

                // DCL | (prelude.ceu : lin 3 : col 1) | (val debug = (f
                
                     // CREATE | (prelude.ceu : lin 3 : col 1) | (func (v) pri
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_debug,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 21) /* global debug */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 3 : col 1) | (val debug = (f)
        
            
                // DCL | (prelude.ceu : lin 12 : col 5) | (val + = (f
                
                     // CREATE | (prelude.ceu : lin 12 : col 5) | (func (v1,v2) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_plus,
                        2,  // TODO: remove assert
                        1,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 22) /* global {{+}} */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 12 : col 5) | (val + = (f)
        
            
                // DCL | (prelude.ceu : lin 19 : col 5) | (val - = (f
                
                     // CREATE | (prelude.ceu : lin 19 : col 5) | (func (v1,v2) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_minus,
                        2,  // TODO: remove assert
                        2,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 23) /* global {{-}} */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 19 : col 5) | (val - = (f)
        
            
                // DCL | (prelude.ceu : lin 27 : col 5) | (val * = (f
                
                     // CREATE | (prelude.ceu : lin 27 : col 5) | (func (v1,v2) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_asterisk,
                        2,  // TODO: remove assert
                        1,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 24) /* global {{*}} */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 27 : col 5) | (val * = (f)
        
            
                // DCL | (prelude.ceu : lin 34 : col 5) | (val ** = (
                
                     // CREATE | (prelude.ceu : lin 34 : col 5) | (func (v1,v2) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_asterisk_asterisk,
                        2,  // TODO: remove assert
                        1,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 25) /* global {{**}} */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 34 : col 5) | (val ** = ()
        
            
                // DCL | (prelude.ceu : lin 41 : col 5) | (val / = (f
                
                     // CREATE | (prelude.ceu : lin 41 : col 5) | (func (v1,v2) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_slash,
                        2,  // TODO: remove assert
                        1,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 26) /* global {{/}} */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 41 : col 5) | (val / = (f)
        
            
                // DCL | (prelude.ceu : lin 48 : col 5) | (val // = (
                
                     // CREATE | (prelude.ceu : lin 48 : col 5) | (func (v1,v2) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_slash_slash,
                        2,  // TODO: remove assert
                        1,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 27) /* global {{//}} */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 48 : col 5) | (val // = ()
        
            
                // DCL | (prelude.ceu : lin 55 : col 5) | (val % = (f
                
                     // CREATE | (prelude.ceu : lin 55 : col 5) | (func (v1,v2) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_null,
                        2,  // TODO: remove assert
                        1,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 28) /* global {{%}} */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 55 : col 5) | (val % = (f)
        
            
                // DCL | (prelude.ceu : lin 66 : col 5) | (val > = (f
                
                     // CREATE | (prelude.ceu : lin 66 : col 5) | (func (v1,v2) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_greater,
                        2,  // TODO: remove assert
                        2,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 29) /* global {{>}} */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 66 : col 5) | (val > = (f)
        
            
                // DCL | (prelude.ceu : lin 74 : col 5) | (val < = (f
                
                     // CREATE | (prelude.ceu : lin 74 : col 5) | (func (v1,v2) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_less,
                        2,  // TODO: remove assert
                        1,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 30) /* global {{<}} */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 74 : col 5) | (val < = (f)
        
            
                // DCL | (prelude.ceu : lin 78 : col 5) | (val >= = (
                
                     // CREATE | (prelude.ceu : lin 78 : col 5) | (func (v1,v2) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_greater_equals,
                        2,  // TODO: remove assert
                        1,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 31) /* global {{>=}} */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 78 : col 5) | (val >= = ()
        
            
                // DCL | (prelude.ceu : lin 82 : col 5) | (val <= = (
                
                     // CREATE | (prelude.ceu : lin 82 : col 5) | (func (v1,v2) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_less_equals,
                        2,  // TODO: remove assert
                        1,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 32) /* global {{<=}} */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 82 : col 5) | (val <= = ()
        
            
                // DCL | (prelude.ceu : lin 89 : col 1) | (val assert = (
                
                     // CREATE | (prelude.ceu : lin 89 : col 1) | (func (v,msg) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_assert,
                        2,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 33) /* global assert */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 89 : col 1) | (val assert = ()
        
            
                // DCL | (prelude.ceu : lin 102 : col 1) | (val tag-or = (
                
                     // CREATE | (prelude.ceu : lin 102 : col 1) | (func (t1,t2) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_tag_dash_or,
                        2,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 34) /* global tag-or */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 102 : col 1) | (val tag-or = ()
        
            
                // DCL | (prelude.ceu : lin 112 : col 1) | (val min = (fun
                
                     // CREATE | (prelude.ceu : lin 112 : col 1) | (func (v1,v2) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_min,
                        2,  // TODO: remove assert
                        2,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 35) /* global min */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 112 : col 1) | (val min = (fun)
        
            
                // DCL | (prelude.ceu : lin 116 : col 1) | (val max = (fun
                
                     // CREATE | (prelude.ceu : lin 116 : col 1) | (func (v1,v2) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_max,
                        2,  // TODO: remove assert
                        2,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 36) /* global max */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 116 : col 1) | (val max = (fun)
        
            
                // DCL | (prelude.ceu : lin 120 : col 1) | (val between = 
                
                     // CREATE | (prelude.ceu : lin 120 : col 1) | (func (min_max,
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_between,
                        2,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 37) /* global between */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 120 : col 1) | (val between = )
        
            // DATA | (prelude.ceu : lin 128 : col 6) | (data :Iterator

                // DCL | (prelude.ceu : lin 131 : col 5) | (val iter-tuple
                
                     // CREATE | (prelude.ceu : lin 131 : col 5) | (func (itr :Ite
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_iter_dash_tuple,
                        1,  // TODO: remove assert
                        6,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 38) /* global iter-tuple */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 131 : col 5) | (val iter-tuple)
        
            
                // DCL | (prelude.ceu : lin 147 : col 5) | (val iter-dict 
                
                     // CREATE | (prelude.ceu : lin 147 : col 5) | (func (itr :Ite
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_iter_dash_dict,
                        1,  // TODO: remove assert
                        6,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 39) /* global iter-dict */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 147 : col 5) | (val iter-dict )
        
            
                // DCL | (prelude.ceu : lin 163 : col 5) | (val iter-xcoro
                
                     // CREATE | (prelude.ceu : lin 163 : col 5) | (func (itr :Ite
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_iter_dash_xcoro,
                        1,  // TODO: remove assert
                        2,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 40) /* global iter-xcoro */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 163 : col 5) | (val iter-xcoro)
        
            
                // DCL | (prelude.ceu : lin 172 : col 5) | (val iter-coro 
                
                     // CREATE | (prelude.ceu : lin 172 : col 5) | (func (itr :Ite
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_iter_dash_coro,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 41) /* global iter-coro */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 172 : col 5) | (val iter-coro )
        
            
                // DCL | (prelude.ceu : lin 178 : col 5) | (val iter-tasks
                
                     // CREATE | (prelude.ceu : lin 178 : col 5) | (func (itr :Ite
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_iter_dash_tasks,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 42) /* global iter-tasks */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 178 : col 5) | (val iter-tasks)
        
            
                // DCL | (prelude.ceu : lin 184 : col 5) | (val to-iter = 
                
                     // CREATE | (prelude.ceu : lin 184 : col 5) | (func (v,tp) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_to_dash_iter,
                        2,  // TODO: remove assert
                        9,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 43) /* global to-iter */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 184 : col 5) | (val to-iter = )
        
            
                // DCL | (prelude.ceu : lin 213 : col 1) | (val === = 
                
                     // CREATE | (prelude.ceu : lin 213 : col 1) | (func :rec (v1,
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_equals_equals_equals,
                        2,  // TODO: remove assert
                        7,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 44) /* global {{===}} */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 213 : col 1) | (val === = )
        
            
                // DCL | (prelude.ceu : lin 240 : col 1) | (val =/= = 
                
                     // CREATE | (prelude.ceu : lin 240 : col 1) | (func :rec (v1,
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_equals_slash_equals,
                        2,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 45) /* global {{=/=}} */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 240 : col 1) | (val =/= = )
        
            
                // DCL | (prelude.ceu : lin 244 : col 1) | (val is' = (fun
                
                     // CREATE | (prelude.ceu : lin 244 : col 1) | (func (v1,v2) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_is_plic_,
                        2,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 46) /* global is' */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 244 : col 1) | (val is' = (fun)
        
            
                // DCL | (prelude.ceu : lin 254 : col 1) | (val is-not' = 
                
                     // CREATE | (prelude.ceu : lin 254 : col 1) | (func (v1,v2) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_is_dash_not_plic_,
                        2,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 47) /* global is-not' */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 254 : col 1) | (val is-not' = )
        
            
                // DCL | (prelude.ceu : lin 258 : col 1) | (val in' = (fun
                
                     // CREATE | (prelude.ceu : lin 258 : col 1) | (func (v,xs) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_in_plic_,
                        2,  // TODO: remove assert
                        2,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 48) /* global in' */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 258 : col 1) | (val in' = (fun)
        
            
                // DCL | (prelude.ceu : lin 264 : col 1) | (val in-not' = 
                
                     // CREATE | (prelude.ceu : lin 264 : col 1) | (func (v,xs) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_in_dash_not_plic_,
                        2,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 49) /* global in-not' */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 264 : col 1) | (val in-not' = )
        
            
                // DCL | (prelude.ceu : lin 272 : col 1) | (val string? = 
                
                     // CREATE | (prelude.ceu : lin 272 : col 1) | (func (v) do 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_string_question_,
                        1,  // TODO: remove assert
                        2,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 50) /* global string? */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 272 : col 1) | (val string? = )
        
            
                // DCL | (prelude.ceu : lin 276 : col 1) | (val to-string 
                
                     // CREATE | (prelude.ceu : lin 276 : col 1) | (func :rec (v) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_to_dash_string,
                        1,  // TODO: remove assert
                        7,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 51) /* global to-string */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 276 : col 1) | (val to-string )
        
            
                // DCL | (prelude.ceu : lin 288 : col 1) | (val to-bool = 
                
                     // CREATE | (prelude.ceu : lin 288 : col 1) | (func (v) if 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_to_dash_bool,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 52) /* global to-bool */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 288 : col 1) | (val to-bool = )
        
            
                // DCL | (prelude.ceu : lin 292 : col 1) | (val to-number 
                
                     // CREATE | (prelude.ceu : lin 292 : col 1) | (func (v) do 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_to_dash_number,
                        1,  // TODO: remove assert
                        4,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 53) /* global to-number */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 292 : col 1) | (val to-number )
        
            
                // DCL | (prelude.ceu : lin 301 : col 1) | (val to-tag = (
                
                     // CREATE | (prelude.ceu : lin 301 : col 1) | (func (v) do 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_to_dash_tag,
                        1,  // TODO: remove assert
                        3,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 54) /* global to-tag */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 301 : col 1) | (val to-tag = ()
        
            
                // DCL | (prelude.ceu : lin 309 : col 1) | (val to-pointer
                
                     // CREATE | (prelude.ceu : lin 309 : col 1) | (func (v) do 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_to_dash_pointer,
                        1,  // TODO: remove assert
                        6,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 55) /* global to-pointer */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 309 : col 1) | (val to-pointer)
        
            
                // DCL | (prelude.ceu : lin 324 : col 1) | (val type-stati
                
                     // CREATE | (prelude.ceu : lin 324 : col 1) | (func (v) <
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_type_dash_static_question_,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 56) /* global type-static? */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 324 : col 1) | (val type-stati)
        
            
                // DCL | (prelude.ceu : lin 327 : col 1) | (val type-dynam
                
                     // CREATE | (prelude.ceu : lin 327 : col 1) | (func (v) >
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_type_dash_dynamic_question_,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 57) /* global type-dynamic? */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 327 : col 1) | (val type-dynam)
        
            
                // DCL | (prelude.ceu : lin 333 : col 1) | (val copy = (fu
                
                     // CREATE | (prelude.ceu : lin 333 : col 1) | (func :rec (v) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_copy,
                        1,  // TODO: remove assert
                        7,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 58) /* global copy */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 333 : col 1) | (val copy = (fu)
        
            
                // DCL | (prelude.ceu : lin 351 : col 1) | (val to-vector 
                
                     // CREATE | (prelude.ceu : lin 351 : col 1) | (func (col,tp) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_to_dash_vector,
                        2,  // TODO: remove assert
                        4,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 59) /* global to-vector */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 351 : col 1) | (val to-vector )
        
            
                // DCL | (prelude.ceu : lin 379 : col 1) | (val to-set = (
                
                     // CREATE | (prelude.ceu : lin 379 : col 1) | (func (col) (
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_to_dash_set,
                        1,  // TODO: remove assert
                        3,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 60) /* global to-set */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 379 : col 1) | (val to-set = ()
        
            
                // DCL | (prelude.ceu : lin 391 : col 1) | (val <++ = 
                
                     // CREATE | (prelude.ceu : lin 391 : col 1) | (func (v1,v2) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_less_plus_plus,
                        2,  // TODO: remove assert
                        4,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 61) /* global {{<++}} */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 391 : col 1) | (val <++ = )
        
            
                // DCL | (prelude.ceu : lin 402 : col 1) | (val ++ = (
                
                     // CREATE | (prelude.ceu : lin 402 : col 1) | (func (v1,v2) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_plus_plus,
                        2,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 62) /* global {{++}} */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 402 : col 1) | (val ++ = ()
        
            
                // DCL | (prelude.ceu : lin 408 : col 1) | (val <|< = 
                
                     // CREATE | (prelude.ceu : lin 408 : col 1) | (func (f,g) (
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_less_bar_less,
                        2,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 63) /* global {{<|<}} */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 408 : col 1) | (val <|< = )
        
            
                // DCL | (prelude.ceu : lin 418 : col 1) | (val random-see
                
                     // CREATE | (prelude.ceu : lin 418 : col 1) | (func (n) if 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_random_dash_seed,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 64) /* global random-seed */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 418 : col 1) | (val random-see)
        
            
                // DCL | (prelude.ceu : lin 426 : col 1) | (val random-nex
                
                     // CREATE | (prelude.ceu : lin 426 : col 1) | (func () ```:
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_random_dash_next,
                        0,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 65) /* global random-next */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 426 : col 1) | (val random-nex)
        
            
                // DCL | (prelude.ceu : lin 430 : col 1) | (val math-sin =
                
                     // CREATE | (prelude.ceu : lin 430 : col 1) | (func (v) ```
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_math_dash_sin,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 66) /* global math-sin */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 430 : col 1) | (val math-sin =)
        
            
                // DCL | (prelude.ceu : lin 434 : col 1) | (val math-cos =
                
                     // CREATE | (prelude.ceu : lin 434 : col 1) | (func (v) ```
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_math_dash_cos,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 67) /* global math-cos */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((prelude.ceu : lin 434 : col 1) | (val math-cos =)
        
            
                // DCL | (@/pico/pico.ceu : lin 438 : col 1) | (val math-floor
                
                     // CREATE | (@/pico/pico.ceu : lin 438 : col 1) | (func (v) ```
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_math_dash_floor,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 68) /* global math-floor */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 438 : col 1) | (val math-floor)
        
            pico_init(1);

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 1, col 1) : ```pico_init(1);```");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 1 : col 1) | ```pico_init(1))
        
                ceux_repl(X->S, (1 + 0 + 69) /* global defer */, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=1} });
                        // true: reached, finalize
                ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                // DATA | (@/pico/pico.ceu : lin 6 : col 6) | (data :PICO = [

                // DCL | (@/pico/pico.ceu : lin 7 : col 1) | (val PICO :PICO
                
                    
                { // TUPLE | (@/pico/pico.ceu : lin 7 : col 18) | [false,40]
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_BOOL, {.Bool=0} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=40} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 70) /* global PICO */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 7 : col 1) | (val PICO :PICO)
        
            // DATA | (@/pico/pico.ceu : lin 11 : col 6) | (data :RGBA = [
// DATA | (@/pico/pico.ceu : lin 12 : col 6) | (data :XY = [x,
// DATA | (@/pico/pico.ceu : lin 13 : col 6) | (data :WH = [w,
// DATA | (@/pico/pico.ceu : lin 14 : col 6) | (data :Rect = [

                { // BLOCK | (@/pico/pico.ceu : lin 16 : col 1) | do (data :Pic
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+108, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        // DATA | (@/pico/pico.ceu : lin 16 : col 6) | (data :Pico = [
// DATA | (@/pico/pico.ceu : lin 17 : col 5) | (data :Pico.Any
// DATA | (@/pico/pico.ceu : lin 18 : col 5) | (data :Pico.Qui
// DATA | (@/pico/pico.ceu : lin 19 : col 5) | (data :Pico.Fra
// DATA | (@/pico/pico.ceu : lin 20 : col 5) | (data :Pico.Dra
// DATA | (@/pico/pico.ceu : lin 21 : col 5) | (data :Pico.Key
// DATA | (@/pico/pico.ceu : lin 22 : col 9) | (data :Pico.Key
// DATA | (@/pico/pico.ceu : lin 23 : col 9) | (data :Pico.Key
// DATA | (@/pico/pico.ceu : lin 25 : col 5) | (data :Pico.Mou
// DATA | (@/pico/pico.ceu : lin 26 : col 9) | (data :Pico.Mou
// DATA | (@/pico/pico.ceu : lin 27 : col 9) | (data :Pico.Mou
// DATA | (@/pico/pico.ceu : lin 28 : col 13) | (data :Pico.Mou
// DATA | (@/pico/pico.ceu : lin 29 : col 13) | (data :Pico.Mou

                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 16 : col 1) | do (data :Pic
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  0;
                        ceux_block_leave(X->S, X->base+108, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                // ENUM | (@/pico/pico.ceu : lin 34 : col 1) | enum :HAnchor
// ENUM | (@/pico/pico.ceu : lin 39 : col 1) | enum :Mouse-B
// ENUM | (@/pico/pico.ceu : lin 44 : col 1) | enum :Key-A =

                // DCL | (@/pico/pico.ceu : lin 61 : col 1) | (val pico-input
                
                     // CREATE | (@/pico/pico.ceu : lin 61 : col 1) | (func (ms) ``
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_input_dash_delay,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 71) /* global pico-input-delay */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 61 : col 1) | (val pico-input)
        
            
                // DCL | (@/pico/pico.ceu : lin 65 : col 1) | (val pico-event
                
                     // CREATE | (@/pico/pico.ceu : lin 65 : col 1) | (func (sdl) `
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_event_dash_sdl_dash_ceu,
                        1,  // TODO: remove assert
                        8,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 72) /* global pico-event-sdl-ceu */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 65 : col 1) | (val pico-event)
        
            
                // DCL | (@/pico/pico.ceu : lin 93 : col 1) | (val pico-input
                
                     // CREATE | (@/pico/pico.ceu : lin 93 : col 1) | (func (tag) `
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_input_dash_event,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 73) /* global pico-input-event */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 93 : col 1) | (val pico-input)
        
            
                // DCL | (@/pico/pico.ceu : lin 123 : col 1) | (val pico-input
                
                     // CREATE | (@/pico/pico.ceu : lin 123 : col 1) | (func (tp,time)
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_input_dash_event_dash_timeout,
                        2,  // TODO: remove assert
                        3,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 74) /* global pico-input-event-timeout */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 123 : col 1) | (val pico-input)
        
            
                // DCL | (@/pico/pico.ceu : lin 132 : col 1) | (val pico-outpu
                
                     // CREATE | (@/pico/pico.ceu : lin 132 : col 1) | (func () ```p
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_output_dash_clear,
                        0,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 75) /* global pico-output-clear */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 132 : col 1) | (val pico-outpu)
        
            
                // DCL | (@/pico/pico.ceu : lin 136 : col 1) | (val pico-outpu
                
                     // CREATE | (@/pico/pico.ceu : lin 136 : col 1) | (func (pos :XY,
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_output_dash_draw_dash_image,
                        3,  // TODO: remove assert
                        4,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 76) /* global pico-output-draw-image */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 136 : col 1) | (val pico-outpu)
        
            
                // DCL | (@/pico/pico.ceu : lin 143 : col 1) | (val pico-outpu
                
                     // CREATE | (@/pico/pico.ceu : lin 143 : col 1) | (func (p1 :XY,p
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_output_dash_draw_dash_line,
                        2,  // TODO: remove assert
                        4,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 77) /* global pico-output-draw-line */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 143 : col 1) | (val pico-outpu)
        
            
                // DCL | (@/pico/pico.ceu : lin 152 : col 1) | (val pico-outpu
                
                     // CREATE | (@/pico/pico.ceu : lin 152 : col 1) | (func (r :Rect)
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_output_dash_draw_dash_rect,
                        1,  // TODO: remove assert
                        4,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 78) /* global pico-output-draw-rect */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 152 : col 1) | (val pico-outpu)
        
            
                // DCL | (@/pico/pico.ceu : lin 160 : col 1) | (val pico-outpu
                
                     // CREATE | (@/pico/pico.ceu : lin 160 : col 1) | (func (r :Rect)
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_output_dash_draw_dash_oval,
                        1,  // TODO: remove assert
                        4,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 79) /* global pico-output-draw-oval */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 160 : col 1) | (val pico-outpu)
        
            
                // DCL | (@/pico/pico.ceu : lin 168 : col 1) | (val pico-outpu
                
                     // CREATE | (@/pico/pico.ceu : lin 168 : col 1) | (func (pos :XY)
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_output_dash_draw_dash_pixel,
                        1,  // TODO: remove assert
                        2,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 80) /* global pico-output-draw-pixel */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 168 : col 1) | (val pico-outpu)
        
            
                // DCL | (@/pico/pico.ceu : lin 174 : col 1) | (val pico-outpu
                
                     // CREATE | (@/pico/pico.ceu : lin 174 : col 1) | (func (pos :XY,
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_output_dash_draw_dash_text,
                        2,  // TODO: remove assert
                        2,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 81) /* global pico-output-draw-text */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 174 : col 1) | (val pico-outpu)
        
            
                // DCL | (@/pico/pico.ceu : lin 180 : col 1) | (val pico-outpu
                
                     // CREATE | (@/pico/pico.ceu : lin 180 : col 1) | (func () ```p
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_output_dash_present,
                        0,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 82) /* global pico-output-present */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 180 : col 1) | (val pico-outpu)
        
            
                // DCL | (@/pico/pico.ceu : lin 184 : col 1) | (val pico-outpu
                
                     // CREATE | (@/pico/pico.ceu : lin 184 : col 1) | (func (path) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_output_dash_sound,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 83) /* global pico-output-sound */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 184 : col 1) | (val pico-outpu)
        
            
                // DCL | (@/pico/pico.ceu : lin 188 : col 1) | (val pico-outpu
                
                     // CREATE | (@/pico/pico.ceu : lin 188 : col 1) | (func (txt) `
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_output_dash_write,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 84) /* global pico-output-write */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 188 : col 1) | (val pico-outpu)
        
            
                // DCL | (@/pico/pico.ceu : lin 192 : col 1) | (val pico-outpu
                
                     // CREATE | (@/pico/pico.ceu : lin 192 : col 1) | (func (txt) `
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_output_dash_writeln,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 85) /* global pico-output-writeln */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 192 : col 1) | (val pico-outpu)
        
            
                // DCL | (@/pico/pico.ceu : lin 200 : col 1) | (val pico-state
                
                     // CREATE | (@/pico/pico.ceu : lin 200 : col 1) | (func () /
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_state_dash_get_dash_fps,
                        0,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 86) /* global pico-state-get-fps */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 200 : col 1) | (val pico-state)
        
            
                // DCL | (@/pico/pico.ceu : lin 204 : col 1) | (val pico-state
                
                     // CREATE | (@/pico/pico.ceu : lin 204 : col 1) | (func () ```
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_state_dash_get_dash_size,
                        0,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 87) /* global pico-state-get-size */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 204 : col 1) | (val pico-state)
        
            
                // DCL | (@/pico/pico.ceu : lin 212 : col 1) | (val pico-state
                
                     // CREATE | (@/pico/pico.ceu : lin 212 : col 1) | (func (img) `
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_state_dash_get_dash_size_dash_image,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 88) /* global pico-state-get-size-image */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 212 : col 1) | (val pico-state)
        
            
                // DCL | (@/pico/pico.ceu : lin 222 : col 1) | (val pico-state
                
                     // CREATE | (@/pico/pico.ceu : lin 222 : col 1) | (func (fps) (
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_state_dash_set_dash_fps,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 89) /* global pico-state-set-fps */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 222 : col 1) | (val pico-state)
        
            
                // DCL | (@/pico/pico.ceu : lin 226 : col 1) | (val pico-state
                
                     // CREATE | (@/pico/pico.ceu : lin 226 : col 1) | (func (h,v) `
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_state_dash_set_dash_anchor,
                        2,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 90) /* global pico-state-set-anchor */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 226 : col 1) | (val pico-state)
        
            
                // DCL | (@/pico/pico.ceu : lin 230 : col 1) | (val pico-state
                
                     // CREATE | (@/pico/pico.ceu : lin 230 : col 1) | (func (on) ``
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_state_dash_set_dash_auto,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 91) /* global pico-state-set-auto */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 230 : col 1) | (val pico-state)
        
            
                // DCL | (@/pico/pico.ceu : lin 234 : col 1) | (val pico-state
                
                     // CREATE | (@/pico/pico.ceu : lin 234 : col 1) | (func (clr :RGB
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_state_dash_set_dash_color_dash_clear,
                        1,  // TODO: remove assert
                        4,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 92) /* global pico-state-set-color-clear */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 234 : col 1) | (val pico-state)
        
            
                // DCL | (@/pico/pico.ceu : lin 242 : col 1) | (val pico-state
                
                     // CREATE | (@/pico/pico.ceu : lin 242 : col 1) | (func (clr :RGB
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_state_dash_set_dash_color_dash_draw,
                        1,  // TODO: remove assert
                        4,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 93) /* global pico-state-set-color-draw */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 242 : col 1) | (val pico-state)
        
            
                // DCL | (@/pico/pico.ceu : lin 250 : col 1) | (val pico-state
                
                     // CREATE | (@/pico/pico.ceu : lin 250 : col 1) | (func (pos :XY)
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_state_dash_set_dash_cursor,
                        1,  // TODO: remove assert
                        2,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 94) /* global pico-state-set-cursor */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 250 : col 1) | (val pico-state)
        
            
                // DCL | (@/pico/pico.ceu : lin 256 : col 1) | (val pico-state
                
                     // CREATE | (@/pico/pico.ceu : lin 256 : col 1) | (func (file,h) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_state_dash_set_dash_font,
                        2,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 95) /* global pico-state-set-font */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 256 : col 1) | (val pico-state)
        
            
                // DCL | (@/pico/pico.ceu : lin 260 : col 1) | (val pico-state
                
                     // CREATE | (@/pico/pico.ceu : lin 260 : col 1) | (func (on) ``
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_state_dash_set_dash_grid,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 96) /* global pico-state-set-grid */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 260 : col 1) | (val pico-state)
        
            
                // DCL | (@/pico/pico.ceu : lin 264 : col 1) | (val pico-state
                
                     // CREATE | (@/pico/pico.ceu : lin 264 : col 1) | (func (r :Rect)
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_state_dash_set_dash_image_dash_crop,
                        1,  // TODO: remove assert
                        4,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 97) /* global pico-state-set-image-crop */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 264 : col 1) | (val pico-state)
        
            
                // DCL | (@/pico/pico.ceu : lin 276 : col 1) | (val pico-state
                
                     // CREATE | (@/pico/pico.ceu : lin 276 : col 1) | (func (pos :XY)
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_state_dash_set_dash_pan,
                        1,  // TODO: remove assert
                        2,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 98) /* global pico-state-set-pan */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 276 : col 1) | (val pico-state)
        
            
                // DCL | (@/pico/pico.ceu : lin 282 : col 1) | (val pico-state
                
                     // CREATE | (@/pico/pico.ceu : lin 282 : col 1) | (func (dim :WH)
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_state_dash_set_dash_size,
                        1,  // TODO: remove assert
                        2,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 99) /* global pico-state-set-size */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 282 : col 1) | (val pico-state)
        
            
                // DCL | (@/pico/pico.ceu : lin 288 : col 1) | (val pico-state
                
                     // CREATE | (@/pico/pico.ceu : lin 288 : col 1) | (func (dim :WH)
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_state_dash_set_dash_size_dash_image,
                        1,  // TODO: remove assert
                        2,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 100) /* global pico-state-set-size-image */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 288 : col 1) | (val pico-state)
        
            
                // DCL | (@/pico/pico.ceu : lin 294 : col 1) | (val pico-state
                
                     // CREATE | (@/pico/pico.ceu : lin 294 : col 1) | (func (dim :WH)
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_state_dash_set_dash_size_dash_pixel,
                        1,  // TODO: remove assert
                        2,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 101) /* global pico-state-set-size-pixel */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 294 : col 1) | (val pico-state)
        
            
                // DCL | (@/pico/pico.ceu : lin 300 : col 1) | (val pico-state
                
                     // CREATE | (@/pico/pico.ceu : lin 300 : col 1) | (func (title) 
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_state_dash_set_dash_title,
                        1,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 102) /* global pico-state-set-title */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 300 : col 1) | (val pico-state)
        
            
                // DCL | (@/pico/pico.ceu : lin 306 : col 1) | (val pico-point
                
                     // CREATE | (@/pico/pico.ceu : lin 306 : col 1) | (func (pt :XY,r
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_point_dash_vs_dash_rect_question_,
                        2,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 103) /* global pico-point-vs-rect? */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 306 : col 1) | (val pico-point)
        
            
                // DCL | (@/pico/pico.ceu : lin 316 : col 1) | (val pico-rect-
                
                     // CREATE | (@/pico/pico.ceu : lin 316 : col 1) | (func (r1 :Rect
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_rect_dash_vs_dash_rect_question_,
                        2,  // TODO: remove assert
                        6,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 104) /* global pico-rect-vs-rect? */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 316 : col 1) | (val pico-rect-)
        
            
                // DCL | (@/pico/pico.ceu : lin 333 : col 1) | (val pico-colli
                
                     // CREATE | (@/pico/pico.ceu : lin 333 : col 1) | (func (tsks,f-c
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_collisions,
                        2,  // TODO: remove assert
                        7,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 105) /* global pico-collisions */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 333 : col 1) | (val pico-colli)
        
            
                // DCL | (@/pico/pico.ceu : lin 350 : col 1) | (val pico-quit 
                
                     // CREATE | (@/pico/pico.ceu : lin 350 : col 1) | (func () (set
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_quit,
                        0,  // TODO: remove assert
                        0,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 106) /* global pico-quit */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((@/pico/pico.ceu : lin 350 : col 1) | (val pico-quit )
        
            
                // DCL | (first_game.ceu : lin 354 : col 1) | (val pico-loop 
                
                     // CREATE | (first_game.ceu : lin 354 : col 1) | (func () pico
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_pico_dash_loop,
                        0,  // TODO: remove assert
                        4,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                    ceux_copy(CEU_GLOBAL_X->S, (1 + 0 + 107) /* global pico-loop */, XX(-1));
                    
                    // recursive func requires its self ref upv to be reset to itself
                    
                    
            ceux_pop(X->S,1); // PI0 ((first_game.ceu : lin 354 : col 1) | (val pico-loop )
        
            
                { // CALL | (first_game.ceu : lin 3 : col 1) | pico-state-set-
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 99) /* global pico-state-set-size */));

                    
                        
                { // TUPLE | (first_game.ceu : lin 3 : col 21) | [810,610]
                    ceux_push(X->S, 1, ceu_create_tuple(2));
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=810} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=610} });
                        ceu_tuple_set(&ceux_peek(X->S,XX(-2)).Dyn->Tuple, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 3, col 1) : pico-state-set-size([810,610])");
            
        
                } // CALL | (first_game.ceu : lin 3 : col 1) | pico-state-set-
                
                { // CALL | (first_game.ceu : lin 4 : col 1) | pico-state-set-
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 102) /* global pico-state-set-title */));

                    
                        
                { // VECTOR | (first_game.ceu : lin 4 : col 22) | #['F','i','r','
                    ceux_push(X->S, 1, ceu_create_vector());
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='F'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='i'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='r'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 2, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='s'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 3, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='t'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 4, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='_'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 5, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='G'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 6, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='a'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 7, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='m'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 8, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='e'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 9, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                                        
                    

                    ceux_call(X, 1, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 4, col 1) : pico-state-set-title(#['F','i','r','s','t','_...)");
            
        
                } // CALL | (first_game.ceu : lin 4 : col 1) | pico-state-set-
                
                { // CALL | (first_game.ceu : lin 5 : col 1) | pico-state-set-
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 95) /* global pico-state-set-font */));

                    
                        
                { // VECTOR | (first_game.ceu : lin 5 : col 21) | #['t','i','n','
                    ceux_push(X->S, 1, ceu_create_vector());
                    ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='t'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 0, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='i'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 1, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='n'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 2, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='y'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 3, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='.'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 4, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='t'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 5, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='t'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 6, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_CHAR, {.Char='f'} });
                        ceu_vector_set(&ceux_peek(X->S,XX(-2)).Dyn->Vector, 7, ceux_peek(X->S,XX(-1)));
                        ceux_pop(X->S, 1);
                        
                }
            
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NUMBER, {.Number=10} });
                                        
                    

                    ceux_call(X, 2, 0);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 5, col 1) : pico-state-set-font(#['t','i','n','y','.','t'...)");
            
        
                } // CALL | (first_game.ceu : lin 5 : col 1) | pico-state-set-
                
                { // SPAWN | (first_game.ceu : lin 47 : col 2) | (spawn (task :n
                    
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                     // CREATE | (first_game.ceu : lin 47 : col 9) | (task :nested (
                {
                    
                    CEU_Value clo = ceu_create_clo_task (
                        
                        ceu_f_29002,
                        0,  // TODO: remove assert
                        13,
                        0
                        , NULL
                    );
                    ceux_push(X->S, 1, clo);
                    
                        // TODO: use args+locs+upvs+tmps?
                        //clo.Dyn->Clo_Exe.mem_n = sizeof(CEU_Clo_Mem_29002);                    
                    
                    
                    // UPVALS = 0
                    
                }
                
                    
                    {
                        ceux_spawn(X, 0, X->now);
                        
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 47, col 2) : (spawn (task :nested () { (var score = 0) (va...)");
            
        
                        ceux_pop(X->S, 1);
                    }
                } // SPAWN | (first_game.ceu : lin 47 : col 2) | (spawn (task :n
            
                { // CALL | (first_game.ceu : lin 51 : col 1) | pico-loop()
                    ceux_push(X->S, 1, ceux_peek(CEU_GLOBAL_X->S, (1 + 0 + 107) /* global pico-loop */));

                                        
                    

                    ceux_call(X, 0, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "first_game.ceu : (lin 51, col 1) : pico-loop()");
            
        
                } // CALL | (first_game.ceu : lin 51 : col 1) | pico-loop()
                
                        
                    } while (0);

                    // BLOCK (escape) | (anon : lin 0 : col 0) | (val dump)(v
                    // defers execute
                    
                    if (ceux_peek(X->S,(1 + 0 + 69) /* global defer */).Bool) {     // if true: reached, finalize
                        do {
                            
                { // BLOCK | (@/pico/pico.ceu : lin 2 : col 7) | ```pico_init(
                    // do not clear upvs
                    ceux_block_enter(X->S, X->base+108, 0 CEU4(COMMA X->exe));
                    
                    // GLOBALS (must be after ceux_block_enter)
                    

                    // defers init
                    
                    
                    do {    
                        pico_init(0);

                        
            CEU_ERROR_CHK_STK(continue, "@/pico/pico.ceu : (lin 3, col 5) : ```pico_init(0);```");
            
        
                        ceux_push(X->S, 1, (CEU_Value) { CEU_VALUE_NIL });
                    
                        
                    } while (0);

                    // BLOCK (escape) | (@/pico/pico.ceu : lin 2 : col 7) | ```pico_init(
                    // defers execute
                    
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+108, 0, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                
                        } while (0);    // catch throw
                        assert(!CEU_ERROR_IS(X->S) && "TODO: error in defer");
                        ceux_pop(X->S, 1);
                    }
                
                    
                    // out=0 when loop iterates (!CEU_BREAK)
                    {
                        int out = CEU3(X->action==CEU_ACTION_ABORT ? 0 : )  1;
                        ceux_block_leave(X->S, X->base+0, 108, out);
                    }
                    
                    
            CEU_ERROR_CHK_STK(continue, NULL);
            
        
                }
                } while (0);
                        
                        return CEU3(X->action==CEU_ACTION_ABORT ? 0 :) 1;
                    }
                
    
    int main (int ceu_argc, char** ceu_argv) {
        assert(CEU_TAG_nil == CEU_VALUE_NIL);
        
    #if 0
        // ... args ...
        {
            CEU_Value xxx = ceu_create_tuple(ceu_argc);
            for (int i=0; i<ceu_argc; i++) {
                CEU_Value vec = ceu_vector_from_c_string(ceu_argv[i]);
                ceu_tuple_set(&xxx.Dyn->Tuple, i, vec);
            }
            ceux_push(X->S, 1, xxx);
        }
    #endif
    
        CEU_Stack S = { 0, {} };
        CEUX _X = { &S, -1, -1 CEU3(COMMA CEU_ACTION_INVALID COMMA {.exe=NULL}) CEU4(COMMA CEU_TIME COMMA NULL) };
        CEUX* X = &_X;
        CEU_GLOBAL_X = X;
        
        do {
                { // CALL | (anon : lin 0 : col 0) | (func () (val
                     // CREATE | (anon : lin 0 : col 0) | (func () (val
                {
                    
                    CEU_Value clo = ceu_create_clo (
                        CEU_VALUE_CLO_FUNC,
                        ceu_f_29081,
                        0,  // TODO: remove assert
                        121,
                        0
                        
                    );
                    ceux_push(X->S, 1, clo);
                    
                    
                    // UPVALS = 0
                    
                }
                
                                        
                    

                    ceux_call(X, 0, 1);
                    
                    
            CEU_ERROR_CHK_STK(continue, "anon : (lin 0, col 0) : (func () { (val dump) (val error) (val next-d...)");
            
        
                } // CALL | (anon : lin 0 : col 0) | (func () (val
                } while (0);

        // uncaught throw
    #if CEU >= 2
        if (CEU_ERROR_IS(X->S)) {
            // [...,n,pay,err]
            CEU_Value n = ceux_peek(X->S, XX(-3));
            assert(n.type == CEU_VALUE_NUMBER);
            // ignore i=0 (main call)
            for (int i=1; i<n.Number; i++) {
                printf(" |  ");
                CEU_Value pre = ceux_peek(X->S, XX(-4-i));
                assert(pre.type==CEU_VALUE_POINTER && pre.Pointer!=NULL);
                printf("%s\n", (char*) pre.Pointer);
            }
            CEU_Value pay = ceux_peek(X->S, XX(-2));
            if (pay.type == CEU_VALUE_POINTER) {
                assert(pay.Pointer != NULL);
                printf(" v  %s\n", (char*) pay.Pointer);     // payload is primitive error
            } else {
                printf(" v  error : ");
                ceu_print1(ceux_peek(X->S, XX(-2)));
                puts("");
            }
        }
    #endif

        ceux_n_set(X->S, 0);
        return 0;
    }
    